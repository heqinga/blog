---
title: 结构型设计模式
categories:
  - javascript设计模式
tags:
  - 结构型设计模式
date: 2017-11-27 18:56:20
---
> 结构型设计模式关注于如何将类或者对象组合成更大，更复杂的结构，以简化设计。

<!-- more -->

### 套餐服务---外观模式

> 外观模式（Facade）：为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口，使得对子系统接口的访问更容易，在Javascript中有时也会用于对底层结构兼容性做统一封装来简化用户使用。

```
// 外观模式实现
//提供一个更简单的高级接口，简化了我们对复杂的底层接口不统一的使用要求
function addEvent(dom, type, fn) {
    if(dom.addEventListener) {
        dom.addEventListener(type, fn, false)
    } else if(dom.attachEvent){
        dom.attachEvent('on'+type, fn)
    } else {
        dom['on'+type] = fn;
    }
}

// 使用
var DOM = document.getElementById('dom');
addEvent(Dom, 'click', function() {
    // 绑定的第一个事件
    console.log('绑定的第一个事件')
})
addEvent(Dom, 'click', function() {
    // 绑定的第一个事件
    console.log('绑定的第二个事件')
})

// 获取事件对象
var getEvent = function (event) {
    // 标准浏览器返回event  IE window.event
    return event || window.event;
}
// 获取元素
var getTarget = function(event) {
    var event = getEvent(event);
    // 标准浏览器下event.target  IE下event.srcElement
    return event.target || event.srcElement;
}
// 阻止默认行为
var preventDefault = function (event) {
    var event = getEvent(event);
    // 标准浏览器
    if(event.preventDefault) {
        event.preventDefault
    } else {
        // IE
        event.returnValue = false;
    }
}
//使用
document.onclick = function (e) {
    preventDefault(e);
    if(getTarget(e) === Dom) {
        // do somethihng
    }
}
```
> 总结：外观模式是对接口方法的外层包装，以供上层代码调用以供上层代码使用，因此有时外观模式封装的接口方法不需要接口的具体实现，只需要按照接口使用规则使用即可，这也是对系统与使用者之间的一种松散耦合，使得系统与使用者之间不会因结构的变化而相互影响。

### 水管弯弯---适配器模式

> 适配器模式(Adapter): 将一个类（对象）的接口（方法或属性）转化成另外一个接口，以满足用户需求，使类（对象）之间接口的不兼容问题通过适配器得以解决。

> 生活中的适配器两根垂直相交的水管连接处的的直角弯管，使得两个不同方向的水管可以疏通流水，三角插头手机充电器对于两项插头是不可用的，此时需要一个三项转两项插头电源适配器等等，这些都是适配器。代码写适配器，其实就是为两个代码库所写的代码兼容运行而书写的额外代码，有了这样的适配器，你就不需要特意地重写以前的功能代码了。

> jQuery适配器

某框架A和jQuery代码书写风格很像，加载完jQuery框架后写一个适配器，将我们已有的功能适配到jQuery，假如代码中有两个事件
，一个加载，一个点击，不过这两个事件与jQuery中的写法很像，所以做的改动不会太大，我们的适配器的主要任务是适配两种代码库中不兼容的代码，那么首当其冲的就是全局对象A与jQuery了，

```
window.A = A = jQuery;
```
> 适配异类框架

如果两个框架直接相差太大，对于这种异类框架适配情况就复杂多了，

```
// 定义框架
var A = A|| {}
A.g = function(id) {
    return document.getElementById(id)
}
// 为元素绑定事件
A.on= function(id, type, fn) {
    // 如果传递参数是字符串则以id处理，负责以元素对象处理，
    var dom = typeof id === 'string' ? this.g(id) : id;
    // 标准dom2级添加事件方式
    if(dom.addEventListener) {
        dom.addEventListener(type, fn, false)
    } else if(dom.attachEvent){
        dom.attachEvent('on'+type, fn)
    } else {
        dom['on'+type] = fn;
    }
}
// 使用
A.on(window, 'load', function() {
    A.on('dom', 'click', function() {
        // do something
    })
})
// 引入jQuery来换A库
A.g = function(id) {
    // 通过jQuery获取jQuery对象，然后返回第一个成员
    return $(id).get(0)
}
A.on = function(id, type, fn) {
    // 如果传递参数是字符串则以id处理，否则以元素对象处理，
    var dom = typeof id === 'string' ? $('#' + id) : $(id);
    dom.on(type, fn);
}
// 通过适配器发现如果两种框架的比较相似，适配比较容易，否则写起来复杂很多，因此尽量引入相似框架。
```

> 参数适配器

适配器还有很多用途，比如方法需要传递多个参数
```
function dosomething(name, title, age, color, size, prize) {
    // 记住参数顺序是很困难的，因此我们经常以一个参数对象方式传入
}
var obj = {
    name: name,
    title: title
    ...
}
function dosomething(obj) {}
// 然而调用的时候不知道传递的参数是否完整，如有一些必须参数没有传入，一些参数是有默认值得等等，此时我们通常的做法是用适配器来适配传入的这个参数对象

function doSomething(obj) {
    var _adapter = {
        name: 'me',
        title: '设计模式'，
        age: 24,
        ...
    }
    for(var i in _adapter) {
        _adapter[i] = obj[i] || _adapter[i];
        // 或者 extend(_adapter, obj)   //  此时可能会多添加属性
        // do something
    }
} 
```
> 数据适配

```
var arr = ['javascript',20,'时间'， ‘日期’]
// 我们发现数组中的每个成员代表的意义不同，这种数据结构语义不好，我们通常会将其适配成对象形式，
var obj = {
    name: '',
    age: '',
    time: '',
    data: ''
}
function arrToObjAdapter() {
    return {
        name: arr[0],
        age: arr[1]
        ...
    }
}
// 使用
var adapterData = arrToObjAdapter(arr);
console.log(adapterData)  // {name: 'javascript', age: 20, ...}

```
> 服务器端数据适配

它解决了前后端的数据依赖，前端程序不在为后端传递的数据所束缚，如果后端因为架构改变导致传递的数据结构发生变化，我们只需要写个适配器就可以放心了，如果后端的数据经常变化，无法控制数据的格式，那么我们在dosomething时最好不要直接调用，最好先将传递过来的数据适配成对我们可用的数据在使用。

```
// 为简化模型这里使用jQuery的ajax方法，理想数据是一个一维数组
function ajaxAdapter(data) {
    // 处理数据并返回新数据
    return [data['key1'], data['key2'], ...]
}
$.ajax({
    url: '...',
    // ...
    success: function(data) {
        if(data) {
            doSomethin(ajaxAdapter(data))
        }
    }
})
// 如果以后后端数据有任何变化我们只需相应的更改ajaxAdapter适配器转换格式
```
> 总结：传统设计模式中，适配器模式往往是适配两个类接口不兼容的问题，然而在JavaScript中，适配器的应用范围更广，比如适配两个代码库，适配前后端数据等等。JavaScript中的适配器的应用，更多应用在对象之间，为了使对象可用，通常我们会将对象拆分并重新包装，这样我们就要了解适配对象的内部结构，这也是与外观模式的区别所在，当然适配器模式同样解决了对象之间的耦合度。包装的适配器代码增加了一些资源开销，当然这是微乎其微的。











