{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/VPS&ECS.png","path":"img/VPS&ECS.png","modified":1,"renderable":0},{"_id":"source/img/broswer1.png","path":"img/broswer1.png","modified":1,"renderable":0},{"_id":"source/img/broswer2.png","path":"img/broswer2.png","modified":1,"renderable":0},{"_id":"source/img/wxmoney.png","path":"img/wxmoney.png","modified":1,"renderable":0},{"_id":"source/img/broswer3.png","path":"img/broswer3.png","modified":1,"renderable":0},{"_id":"themes/hexo-theme-xups/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/jelon.jpg","path":"img/jelon.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/scrolltoparrow.png","path":"img/scrolltoparrow.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/share.png","path":"img/share.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/tangtang.jpg","path":"img/tangtang.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/url.png","path":"img/url.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/wechat_jelon.png","path":"img/wechat_jelon.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/wechat_mp.jpg","path":"img/wechat_mp.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/wechat_pay.png","path":"img/wechat_pay.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/js/html5.js","path":"js/html5.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/js/comment.js","path":"js/comment.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/unsigned_avatar.jpg","path":"img/unsigned_avatar.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/lab/banner.jpg","path":"img/lab/banner.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/0.jpg","path":"img/thumbnail/0.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/1.jpg","path":"img/thumbnail/1.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/4.jpg","path":"img/thumbnail/4.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/5.jpg","path":"img/thumbnail/5.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/6.jpg","path":"img/thumbnail/6.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/7.jpg","path":"img/thumbnail/7.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/8.jpg","path":"img/thumbnail/8.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/9.jpg","path":"img/thumbnail/9.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/icomoon/icomoon.ttf","path":"css/fonts/icomoon/icomoon.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/2.jpg","path":"img/thumbnail/2.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/3.jpg","path":"img/thumbnail/3.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/italic.otf","path":"css/fonts/homizio-nova/italic.otf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/italic.ttf","path":"css/fonts/homizio-nova/italic.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/light.otf","path":"css/fonts/homizio-nova/light.otf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/light_italic.otf","path":"css/fonts/homizio-nova/light_italic.otf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/light_italic.ttf","path":"css/fonts/homizio-nova/light_italic.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/regular.otf","path":"css/fonts/homizio-nova/regular.otf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/icomoon/icomoon.eot","path":"css/fonts/icomoon/icomoon.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/icomoon/icomoon.svg","path":"css/fonts/icomoon/icomoon.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/icomoon/icomoon.woff","path":"css/fonts/icomoon/icomoon.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/light.ttf","path":"css/fonts/homizio-nova/light.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/regular.ttf","path":"css/fonts/homizio-nova/regular.ttf","modified":1,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-xups/.DS_Store","hash":"52d97400984aa59237b7e4ebb36156420bdd8e29","modified":1506220396000},{"_id":"themes/hexo-theme-xups/.gitignore","hash":"0d5c2fdbdc974f10150baa12e1fc171a34960ed8","modified":1506220396000},{"_id":"themes/hexo-theme-xups/README.md","hash":"94361356a2a49d68564f06120319ea9abb530ac2","modified":1508206990000},{"_id":"themes/hexo-theme-xups/_config.yml","hash":"7789bd1c004933c363232ba2f50f9eeec6f53074","modified":1509354974000},{"_id":"source/_posts/markdown.md","hash":"eb6947e6d131ea9bdd444e59f36d48561a5037a7","modified":1512285854000},{"_id":"source/about/index.md","hash":"32707ad1a27069c7f30fdbd645da15d25910fb69","modified":1508206120000},{"_id":"source/comment/index.md","hash":"8ebc21dec895c59375e511f921c8eef99cf192e7","modified":1508206130000},{"_id":"source/img/VPS&ECS.png","hash":"e431db60727e7e12b33d8503d8abe81a75482b62","modified":1508727976000},{"_id":"source/img/broswer1.png","hash":"df67868a7f4d73223459d6540ae2672fe29affd6","modified":1508461294000},{"_id":"source/img/broswer2.png","hash":"833735aedd34713060fd5ed98bdbe3f974634c29","modified":1508461372000},{"_id":"source/img/wxmoney.png","hash":"59f5f4d6c8128a6125f7f3d4e9c34c6cf2550334","modified":1508462898000},{"_id":"source/lab/index.md","hash":"756591670a1f2a6819add9f344e59d312eeb4d40","modified":1508206138000},{"_id":"themes/hexo-theme-xups/.git/FETCH_HEAD","hash":"0bcafc4c2e241ddba4e568821de5c4c4bec8fec6","modified":1509363582000},{"_id":"themes/hexo-theme-xups/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1506220396000},{"_id":"themes/hexo-theme-xups/.git/config","hash":"b1eac456c8f1f7cfa9eaa7e773f078fd9af0fb16","modified":1506220396000},{"_id":"themes/hexo-theme-xups/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1506220330000},{"_id":"themes/hexo-theme-xups/.git/index","hash":"c63420d2c428c22653460363028a1372636913fe","modified":1508464662000},{"_id":"themes/hexo-theme-xups/.git/packed-refs","hash":"34026cea14ed1c1e4396051e0d3ea41eb7290042","modified":1506220396000},{"_id":"themes/hexo-theme-xups/__scaffolds/draft.md","hash":"c569840f0ea232daf0865c3bc8f7ef63b235be62","modified":1508219222000},{"_id":"themes/hexo-theme-xups/__scaffolds/page.md","hash":"892cedeb7b62a73e72a3b369daf2bc63dfee47dc","modified":1506220396000},{"_id":"themes/hexo-theme-xups/__scaffolds/post.md","hash":"dddac2b2269831e3b5e69b7d1439f5170115e808","modified":1508219234000},{"_id":"themes/hexo-theme-xups/layout/archive.ejs","hash":"12b1b2f8ea19eb71e60b6ef5c015aaee6edec568","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/category.ejs","hash":"2f270f509a0f5d73e5f847fdc4351ccc1e76cef3","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/index.ejs","hash":"73e85788bc6a985fbbdf9c37279ccf611d53e9ee","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/layout.ejs","hash":"73f60bed976cc4e55eb2f4c1d3bec1e3975e86ba","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/page.ejs","hash":"66c8c314d4083fff38568f2900d98223c407d5ef","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/post.ejs","hash":"6690fe7adb736e9f3d9d7f65a6b964cdc3c21f20","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/tag.ejs","hash":"0a500f20b93139859120443e2e14592cce81e21c","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/.DS_Store","hash":"fba98dc5c9096d5dba9d35076164c00012d98e11","modified":1506220396000},{"_id":"source/_posts/css/css3.md","hash":"b3de85837621bb68ff1be0102737e6948e9b4173","modified":1508720178000},{"_id":"source/_posts/javascript/js继承.md","hash":"0ced61b25d659fbed9a13868d6134d4150ad63a7","modified":1511312164000},{"_id":"source/_posts/javascript/创建型设计模式.md","hash":"eae619cf5ab139e559766e9ce6be9095c8d5ca31","modified":1512031978000},{"_id":"source/_posts/javascript/结构型设计模式.md","hash":"676517f20d5bfc772e65ea11a8547af92309a08e","modified":1512034643000},{"_id":"source/_posts/工具/Git.md","hash":"d5f37d57d0f8fb13fa776f1f8ab2e6f000063d4c","modified":1509363632000},{"_id":"source/_posts/工具/vsCode.md","hash":"52d48c7a854059eb034513a4767fb793d9cc50fb","modified":1512285776000},{"_id":"source/_posts/工具/科学上网.md","hash":"51175e2e4a5906f4ffc701208e713fe369957a44","modified":1508899170000},{"_id":"source/_posts/服务器/虚拟主机&VPS&ECS.md","hash":"5ebcac49e307aeb35489c529222159d0ab6dd45a","modified":1508847970000},{"_id":"source/_posts/浏览器/浏览器工作原理.md","hash":"3dee3cf62ca416d9dfcfb063bb49320ee4c20b7e","modified":1508462498000},{"_id":"source/img/broswer3.png","hash":"b19dccceca4c92755dd05c573027b2cc6f5cfad9","modified":1508461388000},{"_id":"themes/hexo-theme-xups/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1506220330000},{"_id":"themes/hexo-theme-xups/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1506220330000},{"_id":"themes/hexo-theme-xups/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1506220330000},{"_id":"themes/hexo-theme-xups/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1506220330000},{"_id":"themes/hexo-theme-xups/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1506220330000},{"_id":"themes/hexo-theme-xups/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1506220330000},{"_id":"themes/hexo-theme-xups/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1506220330000},{"_id":"themes/hexo-theme-xups/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1506220330000},{"_id":"themes/hexo-theme-xups/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1506220330000},{"_id":"themes/hexo-theme-xups/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1506220330000},{"_id":"themes/hexo-theme-xups/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1506220330000},{"_id":"themes/hexo-theme-xups/.git/logs/HEAD","hash":"039b4bc62aeed6fcd4c08ec37b6c7d7d573ea5de","modified":1506220396000},{"_id":"themes/hexo-theme-xups/__source/about/index.md","hash":"32707ad1a27069c7f30fdbd645da15d25910fb69","modified":1506220396000},{"_id":"themes/hexo-theme-xups/__source/comment/index.md","hash":"8ebc21dec895c59375e511f921c8eef99cf192e7","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_custom/about.ejs","hash":"9baf208ec128388f0fcbd6e5fa352e6934503a19","modified":1508228278000},{"_id":"themes/hexo-theme-xups/__source/lab/index.md","hash":"756591670a1f2a6819add9f344e59d312eeb4d40","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_custom/comment.ejs","hash":"a3c098be0f2b39208ee8bfe4d5a5474293698cc0","modified":1508463666000},{"_id":"themes/hexo-theme-xups/layout/_custom/lab.ejs","hash":"f6f601ddf3e97ffaec9ce85db41b1fdfdf7c3fcc","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_partial/after-footer.ejs","hash":"51e748ed5cdb4abce01a80501e702fbfedd5f147","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_partial/archive-post.ejs","hash":"da5f3721548be63fe312f931d97d5fc45be9a604","modified":1508462326000},{"_id":"themes/hexo-theme-xups/layout/_partial/archive.ejs","hash":"beec255420d7e3ce5a5e681660d3d521859eeb5e","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_partial/article.ejs","hash":"f6282a889cbc29d8d610e360e9c3e4a9a7d160be","modified":1508462322000},{"_id":"themes/hexo-theme-xups/layout/_partial/baidu-analytics.ejs","hash":"9e9e8da02174f708aaefa4385b5b1d6fe45c807e","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_partial/footer.ejs","hash":"2743ceca0aa1a26b838531d1f1e1edec7cdf166b","modified":1508720044000},{"_id":"themes/hexo-theme-xups/layout/_partial/head.ejs","hash":"b74173aa97f1bb843bc3a2091a616f5dd4e723f2","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_partial/header.ejs","hash":"75d704c065424da08b7533b697f432f474716499","modified":1512287629000},{"_id":"themes/hexo-theme-xups/layout/_partial/sidebar.ejs","hash":"1ff3c93c5c4f169ee9c26590034187a2c02de095","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_widget/categorys.ejs","hash":"29687d96d26fb41f0e78ef8fecc3be6da3d0da29","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_widget/friend_links.ejs","hash":"4ff96fbfb9d70b4636108c5deaaf041c6681ceeb","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_widget/tags.ejs","hash":"bc7b5e50b19e5a7f0f5c81d653407b26d8881c25","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_widget/weibo.ejs","hash":"5803954fea40637eabfa96bfb6d38328d3c33005","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/.DS_Store","hash":"7a2750dc6206c6f07303809521f5eb6654cfc3b3","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_extend.styl","hash":"4942d3ad93832e5b1ad559a1b66e89e145e982b9","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_markdown.styl","hash":"0fd8cff5a5bbf93507817758478cd22efd3cfc88","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_variables.styl","hash":"d0314bd375ba70110ae95a716b7f53a949545f69","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/style.styl","hash":"ae25cdd604a9e4643caa04c704593fd4cc70dfd6","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/.DS_Store","hash":"a1bdef3a79e0c0f0c4f92e81c00a875f6422dab5","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/default.png","hash":"a0e8360a185c7516bc2dddb25241daee67b42972","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/jelon.jpg","hash":"5a698f21552a8365ef44f7113665bff8121635cb","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/loading.gif","hash":"92dcf9179379355f05cf2d1c8cceba930a2a674f","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/scrolltoparrow.png","hash":"53bd140adb85b23d535d1e488550eda4624a58bd","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/share.png","hash":"20a860aeb842a556d067deabb99f6bfc024c97d0","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/tangtang.jpg","hash":"d184ae15dfa844b8bae5c6d426d366f64caa31dd","modified":1508207548000},{"_id":"themes/hexo-theme-xups/source/img/url.png","hash":"be1f35666ed5bf03aa3f6db121bd03c407b158a7","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/wechat_jelon.png","hash":"f1e1cab54bfb69e7816b1d5f355100ea8b272ce4","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/wechat_mp.jpg","hash":"d58b7796093ca8cdd4034b2dd28021c147199099","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/wechat_pay.png","hash":"3fb3bbd4b1fae4259578dce0ca838e0696283041","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/js/html5.js","hash":"4fefd28dcad6c973c44719ce8b3a8b82fe670a59","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/js/comment.js","hash":"be7710e6a4ae9868b264e0001094c0b6e0295a66","modified":1508464660000},{"_id":"themes/hexo-theme-xups/source/js/main.js","hash":"f82044bfaee5911d88d987fbe105fc48cfc96d22","modified":1508218896000},{"_id":"themes/hexo-theme-xups/source/img/unsigned_avatar.jpg","hash":"8343a845110fca8317440fcf61aae209eec57edf","modified":1506220396000},{"_id":"themes/hexo-theme-xups/.git/objects/02/3625784f28f3b354eda20403620e9661c3a4fd","hash":"75bb30c28a89b226a6ca2e42abab6b65fd0a22fc","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/05/5a1d04e139a9d10625a9622b891154fa77f629","hash":"ab9174032d130baa26fd55a8fa171f792338b071","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/07/88c51ce319feeb1bb080748537cc35da5172df","hash":"f4509752a341930a3d2537a87a876f199cc7a180","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/09/c4795bee22292233eee1077386e08920c43a7d","hash":"8cfc5691c253651d052a099c8d19cea691d206ae","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/0a/5c67282b5dba810f61e1cb7423e6284d4ddd38","hash":"3b1ccef8911406fccd093dbce83c6090363ca1f0","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/0a/c82eef9557083be88e460179d251a415bb3a1c","hash":"d7aa5ad339ae39101a2b9db1f9187fec9ef1415e","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/0a/dfdab7b06eb9ea445cba64ef40be14f905f962","hash":"d7ac4ade0917efe61dd69c02c4cdb32983c69def","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/0b/d5c02aabf8953a6987008bafb4422ca4365fc7","hash":"2503e6ce0dfe54cbe271d62687fdeb92efae7dc9","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/0f/25f46992eaef9933022b7a1cfa820d5e9f1ac4","hash":"fddba857db379bf7afbfe7d5297dee90fa6fa5e7","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/16/f77a5d1f2ad2afb71fab8f5db13d60915982ea","hash":"37d4e4f45b0caf7f9a8cb844c56e170f3ea2e590","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/1a/3c261c21f50a8138dadf343e0ac1d8d80316c6","hash":"f122b42ddfc1f9a795634c339a7c30823c8454ed","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/1b/b95a064a2fc7b9bb02c0ee5fe4e0cadd4466b3","hash":"e25b0a9e132296b21fa20c4be9fa37cc2158f371","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/1b/cffcf714e3f0a621f7399c25bcffd3e53a482e","hash":"3dbe4e1d9de57cab6aa8c11b6defbbe44ad53e74","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/1c/2d2aff83d314113731eaecf75241a6b1312b58","hash":"cb13a6bdce24e53e15438a9e95a6f7a443d95c5e","modified":1508679578000},{"_id":"themes/hexo-theme-xups/.git/objects/1c/87998c6266c6fd7b4158c0ab19981d39551721","hash":"be9bfa2a420a921c1bb03908ab51baede6dc4d81","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/20/ef9b243c5746f41a2b773946cf69fc3b467bfa","hash":"b8922fa389dd4c6f9759f170b2b971befb699c75","modified":1508679578000},{"_id":"themes/hexo-theme-xups/.git/objects/1d/2c4aeb49f25e97ff062c0ae3ccc6f80952bac8","hash":"313d990c336fdf542d5803338e539e797f486fb1","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/21/fb261968647f5625feb4f4956f8d7956285c90","hash":"80ae3c7ba2ba38411b027117116d0780839d3391","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/28/15221d20d8de97a3b966972523fb6fb4e729df","hash":"451181110c87f4a63898e907f4c3778e136a5dfd","modified":1508679578000},{"_id":"themes/hexo-theme-xups/.git/objects/2a/735c01e0d2d533d5de48f8a976c46ddb82a973","hash":"34b3ce7a2cb1f75161c36640b81bdbccfca0aede","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/30/454533d11049a6f9b4c1df5c02878f94da0af3","hash":"a18b19bd7215b87ca1c126ec13c2dcdc0440c882","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/32/7e24d50b0fbad866e7f006329d409f66fd82c4","hash":"9fa291978f99abec9f1ebf9d59f0514f16172bc0","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/33/92d491b2c78a84aabbb2b1f9dadb494f2d4dbe","hash":"348f8143f9873b01216bd4af5747ef840a074657","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/34/c95e1582dc6e7cdba9b6f21c7473d3fd0a6eda","hash":"7b29ea2c16410cc2402da4cb2685a12c4b5c9f6a","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/37/93b9e02a69f21551eec4436befccede285be6b","hash":"ee0731c0332ac71e5ef5f81ab7556423f9bbb5ff","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/40/88aec8b60be8bef8c9a76ceac7e01ea9c700d5","hash":"4dc13fbcfbd26624a6c7a8a2ba949995961a36b2","modified":1508679578000},{"_id":"themes/hexo-theme-xups/.git/objects/43/e5301ee4ab98687533340372fd65f35c77723b","hash":"5d3b893395b41221acbe7a83204f2beb699a0288","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/44/a14f7497eb9f86ad07c4d96176619487526d6f","hash":"99f356e281158347ee064b36e3c4e07ea58ec45f","modified":1508679578000},{"_id":"themes/hexo-theme-xups/.git/objects/47/c66da03e207f5e578366b6a25e5934d66ba64a","hash":"67e1422f029d85123d1042fcbce506b0bcbcc0bb","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/4a/b3b0bb88ea4fdf4aec8bd0e94a5e7a9c494bbc","hash":"571877c62c3f2839dd8653e72bf14a8bcf9c0f2d","modified":1508679578000},{"_id":"themes/hexo-theme-xups/.git/objects/4d/e0bcb0cf0f5ab78ca0e2a55a558efd55ddafb9","hash":"4197ea7bef62c4654803f66e3b3310e492fdabbb","modified":1508679578000},{"_id":"themes/hexo-theme-xups/.git/objects/5a/82ddbe100d7d52828b4b46db34a6867f7d2d00","hash":"5c052134d36c885ed41a95282ec03082422b7b9c","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/5f/18014b3757c684fc4c2a77b2a72ba9858c355a","hash":"256e38419e8c1218be556d2b51cf325ba504724b","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/65/ffc311c4fa640d4567d3197d6889d66da91f40","hash":"1c0e6a88b5599029f5fd20a692d1a38f22608ff4","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/69/3e0a471c73f140e040edad2e506fbb807c9ba8","hash":"7fb07c169173b3b5700409f5fae1076c52111943","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/69/c5e9cc08c0970b7703dbf12c1f5f119ec4077c","hash":"258ae27f817d668ee0b0207b29ae9a6f95388a47","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/6c/edc7f1c1e6f841f2f0849d41f7fe5d30703493","hash":"d42b0b4f0d6815eac855f609b237a3ad15d80d3b","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/6d/06771be9d2f0e19e64f8bfc2c86d5f270520a2","hash":"c75321a57cc4b5d6d331ed466aec606bfdc7947b","modified":1508679578000},{"_id":"themes/hexo-theme-xups/.git/objects/72/17719bb788fd8f612e605d7b7fe9cc7250dbf1","hash":"c3092be7ae90224b64201bb174d5ca265d86cb40","modified":1508679578000},{"_id":"themes/hexo-theme-xups/.git/objects/72/89429f650491effa3f2c2e881d446757f1682d","hash":"707fd7a130b09b775b6db68fcb33c065d63d8ff3","modified":1508679578000},{"_id":"themes/hexo-theme-xups/.git/objects/73/5468ea8a7c20c50f9568d31075f0c62ee26d19","hash":"b6458d113a31769ed7bdcdf08922fef8a0110fb8","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/7b/d67ebc6d0e2c0123d7bc1e1bfc3bbc26a69336","hash":"b47a378d031f23365aac50bbea31ef109873ddc9","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/85/0d9b170b71c90cb014347bb9d93039777d0b50","hash":"74f684d73c9af56126632627ede2dbbfd36aa85a","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/88/83e959ec8ef7e365d6b5c9622d45b3b1a56331","hash":"f7f8aafaf9094ef34809d163a43679d74ff63ba3","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/8f/d6955083a1ec744133c72de8e7be50d6e217d6","hash":"3fb595695c1b51a59ef82f346e37fcdfc832cfce","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/91/6d557bea88b6355ccb4550d5dc48320910b693","hash":"92ff46cd9bf13c3ce972aa9e20611c7c46f9fc19","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/95/57618caf0355561e4ee16a3ff734b76305adc3","hash":"578ff9be2e2709adb404c81ed20d04633e8cc2dc","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/99/b6bd1ec1debaafe8875958424a020a74ab6a63","hash":"4d9c85b3bccc3a1e7bbba4cec4511372f76c5983","modified":1508679578000},{"_id":"themes/hexo-theme-xups/.git/objects/a3/80fb56a3bad93913300206e839c9e4ff6f7688","hash":"1137a1e9b6bb9453b7a2bbe242e9fde43b44dfb5","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/a4/38b08492663224d8354343ab2ef9f2a45a9bb1","hash":"a8be62e53fa81bdc2490ef639337375144c1d5af","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/af/ecb850eecfcb55e0abe0f92ff2a3f2f4ecc416","hash":"bed96f4e0f56af34d4737b9822ae71a22b53baa8","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/b8/bfe4a486283b8ba87fbb1a0e42eff7fc14a544","hash":"8610e738d6528257820099104c9e94013cf121df","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/b9/680f7de9883eceac4e6834d560b98f875fe9b6","hash":"dd07732d8a8d25ee400c52e0cc7a9e0efa9e4a6e","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/ba/630ac5a7a8bce954aba3401deafa548a751a1b","hash":"845b94114fde7931b7e650db8e36a694595dd375","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/ba/9974f225a155745a377ffe456b6d630c84524c","hash":"3aeab0b8f79fb6fa0f38770c522c75c1b1356a02","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/bc/11c3258d2387c120b76eed80b927e047b1f55d","hash":"b11405e6e4c7aaa42d02172b539aaa69be53da72","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/bd/d0334dce3286472a2f475d78512bb763ef5c08","hash":"7488981d277026023697601c6dec086b79402fe4","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/bf/ceb0d675d535b0b033ffb172b2cbe0aec7ddea","hash":"7363cc843e19f47ae4c8e57661f487502a4f0077","modified":1508679578000},{"_id":"themes/hexo-theme-xups/.git/objects/c3/26f2a80da95f641887df8d6fa61ac48776e198","hash":"76c9a8c618a4ff30ac09991f6f6df7607791eb01","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/c8/612046440e48d45062cbb26436a8c8252cebc1","hash":"bcdaad93aaae420cb54fef585356925169500ac5","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/ce/3fb1ffa476ddc4544e962860ab0c708adc2385","hash":"a21528ea94b7e4622b153a174e90735eef19a14a","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/d2/1a90d911fb7ebe429e94fbdeae364556d07a49","hash":"d451f1a0b5d678ba3e7ca361b620a77f895cc1f6","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/d2/24f73929e1522f5378f6b271731bd4f0a7ef72","hash":"8c7cad9fb186e5d9f78371f697f5ca6fe85c1561","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/d3/119633b1ef55e1354e50603f1de82b6cdc6fef","hash":"f048c82fe5776bd6adb8342ff8f9bfbaaca44624","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/d3/85317245e93a1f3ef1f2c7638a377c37ace0d1","hash":"9737a8d568828b473fcc2501a471e5b6757fc309","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/d6/1a9c04e0bf0ed3be1ca1f2db53f3f824dd65af","hash":"d8cf67aea9de3e2acaa5b15d1e4bd158a718468d","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/d8/1ebd139d54428f69b85ba598e34299aa715f11","hash":"3448f04fcaaa0cf160390ac68f264bb653116d3f","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/d8/3cb36dd6172840ce8ca3549f9f58db76818827","hash":"b5ef87cce326136a6488b3e64fdb3f40501ae6ca","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/d8/d5f931293cd0919db58b51f5dcd378bc99bdbe","hash":"3630c6105dba0aa7fe4fcd1ccb75bf937527668a","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/dc/395a169028dd46eebc2bdfa5c5ed74f0d9cd74","hash":"fbed7b08811b70dd88925e54ee3317dae4b15672","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/e7/cf199fb267d5047fd08e858f5b3bb65c13e8d3","hash":"00667017056877bdaa2a088e8290c7a1a4ebe4d4","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/f5/80eaa7f0e5ee9bb6f8d2ee4cfb6ae62dc7f8b5","hash":"964d4e1abba7f890fbb53af1ae1781fb07a808af","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/pack/pack-12f44147bfecd427e87dadcdb2a2896bc6dad952.idx","hash":"a59a6c82e13c41dcc082e09b3c306d7823921602","modified":1506220400000},{"_id":"themes/hexo-theme-xups/.git/refs/heads/master","hash":"2cb0532b3f83fb9763df827bc2972c05c55cc18b","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_partial/post/category.ejs","hash":"2908913f083b0d95a5cd09a7996cacfe722a3118","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_partial/post/comment.ejs","hash":"d3f2eceb848e750c7a677319cd9ff4904ab61c45","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_partial/post/date.ejs","hash":"848f362936b3f21e067e2a0783efbdbdab338985","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_partial/post/gallery.ejs","hash":"ed531d1970eedabd2a454d51ac92fffcc0697bec","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_partial/post/nav.ejs","hash":"fa8cb2d5c593fa402e19e1089007812219596481","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_partial/post/share.ejs","hash":"c0f861fb0bd74aced347e0bccee5fa7ff37fa7b4","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_partial/post/tag.ejs","hash":"38a0810b82e69ddd105211e7ff4ee9f2fb832ce9","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_partial/post/title.ejs","hash":"4819520155fc4e389b09c80310af5c61fcd57c03","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_base/font.styl","hash":"52895afc3fd1e250d3359d9250f9f6a33e0c797a","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_base/global.styl","hash":"5ba865047a3438ab6c2347e7403c67a9f2085619","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_base/normalize.styl","hash":"3f6122f583b1590d51fe8181ccd310786c04a4c2","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_base/reset.styl","hash":"ee2a445efc1fbfad1fcdf3cd141e81323171bd25","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_partial/.DS_Store","hash":"16121b987e7a7a6c89f78f512e6e63eea583e25a","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_partial/article.styl","hash":"127dd055a12c250b13add12cd0615b707fe21fab","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_partial/comment.styl","hash":"120c5b9f0fcbc8a85cbc7baf24ddecce54bcb93c","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_partial/footer.styl","hash":"e4891d0642ab0816f29b8d42e014b9818def2a62","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_partial/header.styl","hash":"796da02640d3501e269a828e634dcbc89ef41a11","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_partial/highlight.styl","hash":"c1c9655afa9739a4987dc196fff5af50688ea445","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_partial/post.styl","hash":"163988e3cb92deab32674175cb25048ca2f96ae6","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_partial/responsive.styl","hash":"e522f71c84279b2bb041e931b451cde208e913c6","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_partial/searchform.styl","hash":"2a2ae54716da54d90eb1970ddec92a33e6fde6b5","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_partial/sidebar.styl","hash":"0e64e0a73a6befe0be43a9cb9458e7c690fe4883","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_partial/theme.styl","hash":"e1eb40c93a39f2212b042fcb4481be2e901240af","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/fonts/.DS_Store","hash":"db2379b0a524b084530079a6a32ba976f2892009","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/lab/banner.jpg","hash":"daa0b3c13831b17182c3d587920f035c80816ae3","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/0.jpg","hash":"7285bbd93d25a0810df38b499fa2b9c201dd88f2","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/1.jpg","hash":"d56409526e114f07de70b9f6be036ee8939626bb","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/4.jpg","hash":"4ba83c3c4937b8068bcb9ed7002c186053482b86","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/5.jpg","hash":"b30fe3c75c445789d83b3d0f2f7b8d456802d306","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/6.jpg","hash":"767c9f7b42b7faf9966fcf87afc732045bf87167","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/7.jpg","hash":"74a4ed49b8823f7e93cad8dc53ed2bcc07f33254","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/8.jpg","hash":"ed356882b0a3015e7aec619bf22dd98e76a2dac8","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/9.jpg","hash":"64aa3752db2dd53e3dbbc7a84967afd2cdedd43e","modified":1506220396000},{"_id":"themes/hexo-theme-xups/.git/objects/4c/b97e685698aa0517086f5e7d74d390154c21c4","hash":"ce1d58bd5de84645b44e84fd09e80273ad3b3d4f","modified":1508679580000},{"_id":"themes/hexo-theme-xups/source/css/fonts/icomoon/icomoon.ttf","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/2.jpg","hash":"edbd90ed95301d390a8aa8243cd4c08a4d862402","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/3.jpg","hash":"7870fb47e46f645332174f356148bbc8163dfe13","modified":1506220396000},{"_id":"themes/hexo-theme-xups/.git/logs/refs/heads/master","hash":"039b4bc62aeed6fcd4c08ec37b6c7d7d573ea5de","modified":1506220396000},{"_id":"themes/hexo-theme-xups/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1506220396000},{"_id":"themes/hexo-theme-xups/.git/refs/remotes/origin/master","hash":"9117f4e585db2a878870697c08d68f24da8d22b1","modified":1508679580000},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/.DS_Store","hash":"94c491df2256ef547252eed029a8bfb2961da5fe","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/italic.otf","hash":"5b50719da49c1ac26793384b1b68055f01dd4e85","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/italic.ttf","hash":"c62e2ba058f3dc49125dc514bcedde065ce64c5f","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/light.otf","hash":"4afcc511fe6937b8e8d79e649d70dfb4fff6b406","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/light_italic.otf","hash":"29c648cf7caa087f36b1e1e1c479eb63da35af73","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/light_italic.ttf","hash":"de9be5ed440fc380f2cbaa1683e94518d3d44e02","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/regular.otf","hash":"c6e47b88647ac2b729c05d220cc5be19787b7835","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/fonts/icomoon/icomoon.eot","hash":"26de148529b318cb8159c70ef5adbe3667fb3e6d","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/fonts/icomoon/icomoon.svg","hash":"2e3227e11e13917eecb676062ee953b37ea957c0","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/fonts/icomoon/icomoon.woff","hash":"a5a4ffc5ecda60e59beac6b0f096b25b243a2acb","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/light.ttf","hash":"2ba5f36f461b540823978956af8c33b57b0b8ab1","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/regular.ttf","hash":"0ab6cf8e5883d5693ba56065e4973cd8b3e896bc","modified":1506220396000},{"_id":"themes/hexo-theme-xups/.git/logs/refs/remotes/origin/HEAD","hash":"039b4bc62aeed6fcd4c08ec37b6c7d7d573ea5de","modified":1506220396000},{"_id":"themes/hexo-theme-xups/.git/logs/refs/remotes/origin/master","hash":"bf2a1bcf3883e188f15307fbcf5e8ab1e1b21c5a","modified":1508679580000},{"_id":"themes/hexo-theme-xups/xups.png","hash":"22f1fc32dea794370b4e791b885c2afb03c886c6","modified":1506220396000},{"_id":"themes/hexo-theme-xups/.git/objects/pack/pack-12f44147bfecd427e87dadcdb2a2896bc6dad952.pack","hash":"54fb12a32f2fee8e7cefeee8154de16198a79939","modified":1506220400000},{"_id":"public/about/index.html","hash":"5df5e09d27b28a56992516e7dac2d9cb7882160f","modified":1512289064096},{"_id":"public/comment/index.html","hash":"f3d72777a78f521f7061c85ba8b87b002494b6ac","modified":1512289064097},{"_id":"public/lab/index.html","hash":"ec324e584552978d527ded78f67f38565c5683f0","modified":1512289064097},{"_id":"public/2017/10/24/工具/Git/index.html","hash":"01829dcd02053648b8862ccd6c3ab8fcaf063aba","modified":1512289064097},{"_id":"public/2017/10/23/工具/科学上网/index.html","hash":"b62f5211d388eb1ee39421cc98c4ce37bf8a073f","modified":1512289064097},{"_id":"public/2017/10/17/服务器/虚拟主机&VPS&ECS/index.html","hash":"349e34cdb36614b41238e0fba84222ef99f13178","modified":1512289064097},{"_id":"public/archives/index.html","hash":"6c8359e61977db82dcafbb274def2e5dd8f7ad3e","modified":1512289064097},{"_id":"public/archives/2017/index.html","hash":"c8a8d434fb19a733eee2962159c6f15f7a949b3e","modified":1512289064097},{"_id":"public/archives/2017/10/page/2/index.html","hash":"d26c1490bc2d9bd63c68bf00ae2935f2f40f0ca1","modified":1512289064097},{"_id":"public/archives/2017/11/index.html","hash":"4c97fdb086e8ffbc66c28e2412dbaf481abeae99","modified":1512289064097},{"_id":"public/archives/2017/12/index.html","hash":"f2e064a8b40395b7956e0cddde30b7cda3d6b276","modified":1512289064098},{"_id":"public/categories/语法/index.html","hash":"eb0c0d6a47b4ec03c9fec7e1a250be52b01ebd35","modified":1512289064098},{"_id":"public/categories/css/index.html","hash":"e79a36d342ba829b7bd151fce3f9c1a855b842c2","modified":1512289064098},{"_id":"public/categories/javascript设计模式/index.html","hash":"09e67921565c137ac31aa6382d992f6b0a85bc6c","modified":1512289064098},{"_id":"public/categories/工具/index.html","hash":"ab511a8aba45699962558ac38e0d64529e37625a","modified":1512289064098},{"_id":"public/categories/服务器/index.html","hash":"7f0c4e0abd2b59bed5ccb52c165c2350899e426c","modified":1512289064098},{"_id":"public/categories/浏览器/index.html","hash":"d35c7a48873ce6e002977c6d1c58f0352688f941","modified":1512289064098},{"_id":"public/index.html","hash":"5ae4e844907f2b8f94802df8496f592d8676e2cc","modified":1512289064098},{"_id":"public/tags/语法/index.html","hash":"b2e92c30c60c4c6ff2d96bc710cb2b20d205e4a9","modified":1512289064098},{"_id":"public/tags/css3/index.html","hash":"8ae51282f052872e81eb2fb492a7893c4e1a0379","modified":1512289064098},{"_id":"public/tags/js继承/index.html","hash":"4e6002162755eb128d987166bcf65447501f0a21","modified":1512289064098},{"_id":"public/tags/创建型设计模式/index.html","hash":"0766e31a3b5c70f9699b7955c74f72ef4afd0b65","modified":1512289064098},{"_id":"public/tags/结构型设计模式/index.html","hash":"f758a1f6696f3e24236c7fbaca52a46ea073faf4","modified":1512289064098},{"_id":"public/tags/Git/index.html","hash":"d385a0a1779f321220cd6cd9af4a7430c2777da7","modified":1512289064098},{"_id":"public/tags/vsCode插件/index.html","hash":"ff0e51848aa8fd99b7d93bae8f9bd9de21813d7e","modified":1512289064098},{"_id":"public/tags/VPN/index.html","hash":"43922843fdf12a158e7d03649e1abae3d3adf1f1","modified":1512289064099},{"_id":"public/tags/服务器区别/index.html","hash":"1feb1064496386f64d9fb6b3eaf6d0fb7627f14a","modified":1512289064099},{"_id":"public/tags/浏览器/index.html","hash":"975c9022f3c92eff48fd6b591f1dd763013be582","modified":1512289064099},{"_id":"public/2017/12/03/工具/vsCode/index.html","hash":"e911458c6be1387ca46865f16da0bbb7ca8bcc86","modified":1512289064099},{"_id":"public/2017/11/27/javascript/结构型设计模式/index.html","hash":"924a5e6a55f89dfa1d3af1ba01d1778b96e987c0","modified":1512289064099},{"_id":"public/2017/11/20/javascript/创建型设计模式/index.html","hash":"a07fb11b8961392cca057617ae5cc42a26525e6e","modified":1512289064099},{"_id":"public/2017/11/05/javascript/js继承/index.html","hash":"5e0d74098194a26ad0460729d76e2600d28acc8f","modified":1512289064099},{"_id":"public/2017/10/19/浏览器/浏览器工作原理/index.html","hash":"300f0d80590fbeee743dd7cc5d487ee301318b13","modified":1512289064099},{"_id":"public/2017/10/17/css/css3/index.html","hash":"0dc23bd0fceefd90863a44e1de1953e0e6538604","modified":1512289064099},{"_id":"public/2017/10/17/markdown/index.html","hash":"262c32869f7d75acebd50f2403d4d12903eba74f","modified":1512289064099},{"_id":"public/archives/page/2/index.html","hash":"013df4f1786078cd391766b03a06cf811ca03069","modified":1512289064099},{"_id":"public/archives/2017/page/2/index.html","hash":"41add501468fb3aadbfa12100fc79e697b0b33ba","modified":1512289064099},{"_id":"public/archives/2017/10/index.html","hash":"975c7c4140cd7c3de50d3124def770ca27a796e0","modified":1512289064099},{"_id":"public/page/2/index.html","hash":"a72f04f6a2c5f2f42c890b7b77d32667382a8e7a","modified":1512289064099},{"_id":"public/css/fonts/icomoon/icomoon.ttf","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512289064099},{"_id":"public/img/VPS&ECS.png","hash":"e431db60727e7e12b33d8503d8abe81a75482b62","modified":1512289064102},{"_id":"public/img/broswer2.png","hash":"833735aedd34713060fd5ed98bdbe3f974634c29","modified":1512289064102},{"_id":"public/img/broswer1.png","hash":"df67868a7f4d73223459d6540ae2672fe29affd6","modified":1512289064102},{"_id":"public/img/wxmoney.png","hash":"59f5f4d6c8128a6125f7f3d4e9c34c6cf2550334","modified":1512289064102},{"_id":"public/img/default.png","hash":"a0e8360a185c7516bc2dddb25241daee67b42972","modified":1512289064102},{"_id":"public/img/jelon.jpg","hash":"5a698f21552a8365ef44f7113665bff8121635cb","modified":1512289064102},{"_id":"public/img/loading.gif","hash":"92dcf9179379355f05cf2d1c8cceba930a2a674f","modified":1512289064102},{"_id":"public/img/scrolltoparrow.png","hash":"53bd140adb85b23d535d1e488550eda4624a58bd","modified":1512289064102},{"_id":"public/img/share.png","hash":"20a860aeb842a556d067deabb99f6bfc024c97d0","modified":1512289064102},{"_id":"public/img/tangtang.jpg","hash":"d184ae15dfa844b8bae5c6d426d366f64caa31dd","modified":1512289064102},{"_id":"public/img/wechat_jelon.png","hash":"f1e1cab54bfb69e7816b1d5f355100ea8b272ce4","modified":1512289064102},{"_id":"public/img/wechat_mp.jpg","hash":"d58b7796093ca8cdd4034b2dd28021c147199099","modified":1512289064103},{"_id":"public/img/url.png","hash":"be1f35666ed5bf03aa3f6db121bd03c407b158a7","modified":1512289064103},{"_id":"public/img/wechat_pay.png","hash":"3fb3bbd4b1fae4259578dce0ca838e0696283041","modified":1512289064103},{"_id":"public/img/lab/banner.jpg","hash":"daa0b3c13831b17182c3d587920f035c80816ae3","modified":1512289064103},{"_id":"public/img/thumbnail/0.jpg","hash":"7285bbd93d25a0810df38b499fa2b9c201dd88f2","modified":1512289064103},{"_id":"public/img/thumbnail/1.jpg","hash":"d56409526e114f07de70b9f6be036ee8939626bb","modified":1512289064103},{"_id":"public/img/thumbnail/4.jpg","hash":"4ba83c3c4937b8068bcb9ed7002c186053482b86","modified":1512289064103},{"_id":"public/img/thumbnail/6.jpg","hash":"767c9f7b42b7faf9966fcf87afc732045bf87167","modified":1512289064103},{"_id":"public/img/thumbnail/5.jpg","hash":"b30fe3c75c445789d83b3d0f2f7b8d456802d306","modified":1512289064103},{"_id":"public/img/thumbnail/7.jpg","hash":"74a4ed49b8823f7e93cad8dc53ed2bcc07f33254","modified":1512289064103},{"_id":"public/img/thumbnail/8.jpg","hash":"ed356882b0a3015e7aec619bf22dd98e76a2dac8","modified":1512289064103},{"_id":"public/img/thumbnail/9.jpg","hash":"64aa3752db2dd53e3dbbc7a84967afd2cdedd43e","modified":1512289064104},{"_id":"public/css/fonts/homizio-nova/light.otf","hash":"4afcc511fe6937b8e8d79e649d70dfb4fff6b406","modified":1512289064104},{"_id":"public/css/fonts/homizio-nova/italic.otf","hash":"5b50719da49c1ac26793384b1b68055f01dd4e85","modified":1512289064104},{"_id":"public/css/fonts/homizio-nova/italic.ttf","hash":"c62e2ba058f3dc49125dc514bcedde065ce64c5f","modified":1512289064104},{"_id":"public/css/fonts/homizio-nova/light_italic.otf","hash":"29c648cf7caa087f36b1e1e1c479eb63da35af73","modified":1512289064104},{"_id":"public/css/fonts/icomoon/icomoon.eot","hash":"26de148529b318cb8159c70ef5adbe3667fb3e6d","modified":1512289064104},{"_id":"public/css/fonts/homizio-nova/light_italic.ttf","hash":"de9be5ed440fc380f2cbaa1683e94518d3d44e02","modified":1512289064104},{"_id":"public/css/fonts/homizio-nova/regular.otf","hash":"c6e47b88647ac2b729c05d220cc5be19787b7835","modified":1512289064104},{"_id":"public/css/fonts/icomoon/icomoon.woff","hash":"a5a4ffc5ecda60e59beac6b0f096b25b243a2acb","modified":1512289064104},{"_id":"public/css/fonts/icomoon/icomoon.svg","hash":"2e3227e11e13917eecb676062ee953b37ea957c0","modified":1512289064104},{"_id":"public/img/unsigned_avatar.jpg","hash":"8343a845110fca8317440fcf61aae209eec57edf","modified":1512289064369},{"_id":"public/img/thumbnail/2.jpg","hash":"edbd90ed95301d390a8aa8243cd4c08a4d862402","modified":1512289064369},{"_id":"public/img/thumbnail/3.jpg","hash":"7870fb47e46f645332174f356148bbc8163dfe13","modified":1512289064370},{"_id":"public/css/fonts/homizio-nova/light.ttf","hash":"2ba5f36f461b540823978956af8c33b57b0b8ab1","modified":1512289064370},{"_id":"public/css/fonts/homizio-nova/regular.ttf","hash":"0ab6cf8e5883d5693ba56065e4973cd8b3e896bc","modified":1512289064370},{"_id":"public/js/html5.js","hash":"4fefd28dcad6c973c44719ce8b3a8b82fe670a59","modified":1512289064373},{"_id":"public/js/main.js","hash":"457dc472d3a3aecfb57fdbe80d7d475c3ef5baf4","modified":1512289064373},{"_id":"public/css/style.css","hash":"fc634df6728a66aaf5044c026951084aa905114f","modified":1512289064373},{"_id":"public/js/comment.js","hash":"e49749f28b510d1112af57b781f96c1d317d3568","modified":1512289064373},{"_id":"public/img/broswer3.png","hash":"b19dccceca4c92755dd05c573027b2cc6f5cfad9","modified":1512289064373}],"Category":[{"name":"语法","_id":"cjaqhv1gd0005btx16v5pava4"},{"name":"css","_id":"cjaqhv1gs000gbtx1hjjryd05"},{"name":"javascript设计模式","_id":"cjaqhv1gt000jbtx1qtm8ccrf"},{"name":"工具","_id":"cjaqhv1gv000pbtx1dn2l463g"},{"name":"服务器","_id":"cjaqhv1gw000vbtx1w3hpzs42"},{"name":"浏览器","_id":"cjaqhv1gw000xbtx1kmkx0t53"}],"Data":[],"Page":[{"title":"关于","date":"2016-01-31T14:10:28.000Z","pageid":"about","_content":"","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2016-01-31 22:10:28\npageid: about\n---","updated":"2017-10-17T02:08:40.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjaqhv1g10000btx11owib34p","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"留言","date":"2016-02-01T12:29:57.000Z","pageid":"comment","_content":"","source":"comment/index.md","raw":"---\ntitle: 留言\ndate: 2016-02-01 20:29:57\npageid: comment\n---\n","updated":"2017-10-17T02:08:50.000Z","path":"comment/index.html","comments":1,"layout":"page","_id":"cjaqhv1g60002btx1szgs6fpl","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"实验室","date":"2016-02-01T12:29:57.000Z","pageid":"lab","projects":{"blog_demo":{"title":"Blog Demo","time":"2016-10-10T00:00:00.000Z","content":{"1":{"name":"基于 vue + vuex + bootstrap 的 blog demo","link":"https://github.com/jangdelong/vue-blog-demo"}}},"hexo_theme_xups":{"title":"hexo-theme-xups 博客主题","time":"2016-03-12T00:00:00.000Z","content":{"1":{"name":"基于 hexo 静态博客系统的 博客主题 xups","link":"https://github.com/jangdelong/hexo-theme-xups"}}},"typecho_theme_xups":{"title":"Typecho 博客主题","time":"2015-10-15T00:00:00.000Z","content":{"1":{"name":"基于 php 博客系统 typecho 的主题 xups","link":"https://github.com/jangdelong/typecho-theme-xups"}}}},"_content":"","source":"lab/index.md","raw":"---\ntitle: 实验室\ndate: 2016-02-01 20:29:57\npageid: lab\n\nprojects:\n    blog_demo:\n        title: Blog Demo\n        time: 2016-10-10\n        content: \n            1:\n                name: 基于 vue + vuex + bootstrap 的 blog demo\n                link: https://github.com/jangdelong/vue-blog-demo\n    hexo_theme_xups:\n        title: hexo-theme-xups 博客主题\n        time: 2016-03-12\n        content:\n            1:\n                name: 基于 hexo 静态博客系统的 博客主题 xups\n                link: https://github.com/jangdelong/hexo-theme-xups\n    typecho_theme_xups:\n        title: Typecho 博客主题\n        time: 2015-10-15\n        content: \n            1:        \n                name: 基于 php 博客系统 typecho 的主题 xups\n                link: https://github.com/jangdelong/typecho-theme-xups  \n---\n","updated":"2017-10-17T02:08:58.000Z","path":"lab/index.html","comments":1,"layout":"page","_id":"cjaqhv1g60003btx1ou73yw8p","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Markdown","date":"2017-10-17T05:49:58.000Z","_content":"\n> Markdown是一种可以使用普通文本编辑器编写的[标记语言](https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/5964436?fr=aladdin, '标记语言')，通过简单的标记语法，它可以使普通文本内容具有一定的格式\n\n<!-- more -->\n\n## 用途\n> Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客 当然还有其他的用途\n\n## 目标\n> 实现「易读易写」成为一种适用于网络的书写语言，Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然\n\n## Markdown 语法的简要规则\n\n## 1.标题\n\n> 标题是每篇文章都需要也是最常用的格式，Markdown支持两种标题语法，Settext和atx形式。\n\n> Settext形式：利用底线形式，用 = （最高级标题） 和 - （第二级标题）作为底线形式标题的标记。\n\n> atx形式：在行首插入 1 到 6 个 #，对应标题 1 到 6 级（从大到小顺序）。\n\n标题Settext形式\n=====================\n标题Settext形式\n---------------------\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n## 2.引用\n\n> 文章中经常引用别人的话，为区别开来可以用引用标记特别注明。Markdown中使用email形式的 ‘>‘（右尖括号号）。可以在引用段落前加一个，也可以在段落每行前面加一个。如果区块引用由几段组成，引用段落之间需要加一个 >区分引用不同段落（这是引用标记和段落标记的组合）\n\n> This is a blockquote.\n>\n> This is the second paragraph in the blockquote.\n>\n> ## This is an H2 in a blockquote\n\n## 3.段落\n\n> 一篇文章由N个段落组成。一个段落由一个或多个连续的行构成，Markdown通过一个以上的空行区别不同的段落。只要看起来像空行，不管是由空格符还是tab组成的，一律视为空行。\n\n> 多个空格会被看成一个空格。一般段落首行没有缩进，如果需要首行缩进的话可用&emsp; (全方大空白)或 &ensp; （半方大空格）\n\n&emsp;&emsp;这是段落1\n\n&ensp;&ensp;这是段落2\n\n## 4.强调\n\n> Markdown使用星号 * 和底线 _ 标记强调区段。在强调部分前加上标记，在强调部分结束后加上标记限制强调范围。注意星号强调标志与强调内容之间不能有空格存在，不然变成无序列表了。\n\n*强调部分变为斜体*   \n\n_强调部分变为斜体_\n\n**加重强调部分变为粗体**  \n\n__加重强调变为粗体__\n\n***特别强调部分变为粗斜体*** \n\n___特别强调部分变为粗斜体___\n\n## 5.列表\n\n> 列表分为无序列表和有序列表两种。 无序列表使用星号、加号、减号三种中任意一种作为无序列表的项目标记。三种符号可混用，但不建议这样做。注意列表标记和列表项目之间必须至少一个空格。\n\n*  无序列表中一项\n* 子项，以一个tab或者4个空格缩进\n* 无序列表中另一项\n+ 无序列表另一项\n- 无序列表另一项\n\n> 有序列表使用数字接一个英文句点作为项目标记。注意数字和句点间不能有空格，句点和项目内容之间至少有一个空格\n\n1. 有序列表一项\n2. 有序列表另一项\n1. 有序列表最后一项\n\n## 6.链接\n\n> Markdown支持两种形式链接语法\n\n> 1.行内插入链接：要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可\n\n[链接文字链接文字](链接地址)\n\n示例: [github](http://www.github.com)\n\nThis is [an example](http://example.com/ \"Title\") inline link.\n\n[This link](http://example.net/) has no title attribute.\n\n> 2.参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记\n\n[链接文字][链接引用标签]\n\n[链接引用标签]: 链接地址 \"http://www.baidu.com\"\n\n锚点  跳到页面的最后\n\nThis is [an example](#jump) reference-style link.\n\n## 7.图片\n\n> 图片引用类似于链接引用。图片可以是网络图片，也可以是本地图片，本地图片建议放在source/images目录中，按年月建立两层目录放置便于归档。本地图片的url类似为/images/year/month/img.png。\n\n```![alt MyEmail](/images/myemail.png \"MyEmail\")```\n\n![alt MyEmail](/images/myemail.png \"MyEmail\")\n\n## 8.代码\n\n> 第一种：简单文字出现一个代码框。使用`<blockquote>`。（`不是单引号而是左上角的ESC下面~中的`）\n\n> 第二种：大片文字需要实现代码框。使用Tab和四个空格。\n\n`let a = 10;`\n\n        let b = 12;\n        let c = 22;\n\n## 9.水平分割线\n\n> 要生成水平分割线，可以在单独一行里输入3个或以上的短横线（减号）、星号或者下划线实现。短横线和星号之间可以输入任意空格。以下每一行都产生一条水平分割线\n\n-------------------\n**     *\n__  _\n__    _\n\n## 10.表格\n\n## 常用语法\n\n| 输出后的效果 | Markdown | 快捷键 |\n| ------------- |:-------------:| -----:|\n| Bold | **text** | Ctrl/⌘ + B |\n| Emphasize | *text* | Ctrl/⌘ + I |\n| Strike-through | ~~text~~ | Ctrl + Alt + U |\n| Link | [title](http://www.baidu.com)| Ctrl/⌘ + K |\n| Inline Code | `code` | Ctrl/⌘ + Shift + K |\n| Image | ![alt](http://) | Ctrl/⌘ + Shift + I |\n| List | * item |Ctrl + L |\n| Blockquote | > quote | Ctrl + Q |\n| H1 | # H1 | Ctrl/⌘ + I |\n| H2 | ## H2 | Ctrl/⌘ + H |\n| H3 | ### H3 | Ctrl/⌘ + H (x2) |\n\n## 11.片段\n\n这是一个普通段落：\n\n\t这是一个代码区块。\n\n<p>这是一个普通段落：</p>\n<pre>\n<code>这是一个代码区块。</code>\n</pre>\n\n```javascript\n  var ihubo = {\n    nickName  : \"草依山\",\n    site : \"http://jser.me\"\n  }\n```\n<span id = \"jump\">跳转到这里：</span>\n\n## 相关链接：\n\n* [Markdown语法](http://www.appinn.com/markdown/)\n* [Markdown-语法手册](http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C)\n\n\n","source":"_posts/markdown.md","raw":"---\ntitle: Markdown\ndate: 2017-10-17 13:49:58\ncategories:\n- 语法\ntags: 语法\n---\n\n> Markdown是一种可以使用普通文本编辑器编写的[标记语言](https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/5964436?fr=aladdin, '标记语言')，通过简单的标记语法，它可以使普通文本内容具有一定的格式\n\n<!-- more -->\n\n## 用途\n> Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客 当然还有其他的用途\n\n## 目标\n> 实现「易读易写」成为一种适用于网络的书写语言，Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然\n\n## Markdown 语法的简要规则\n\n## 1.标题\n\n> 标题是每篇文章都需要也是最常用的格式，Markdown支持两种标题语法，Settext和atx形式。\n\n> Settext形式：利用底线形式，用 = （最高级标题） 和 - （第二级标题）作为底线形式标题的标记。\n\n> atx形式：在行首插入 1 到 6 个 #，对应标题 1 到 6 级（从大到小顺序）。\n\n标题Settext形式\n=====================\n标题Settext形式\n---------------------\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n## 2.引用\n\n> 文章中经常引用别人的话，为区别开来可以用引用标记特别注明。Markdown中使用email形式的 ‘>‘（右尖括号号）。可以在引用段落前加一个，也可以在段落每行前面加一个。如果区块引用由几段组成，引用段落之间需要加一个 >区分引用不同段落（这是引用标记和段落标记的组合）\n\n> This is a blockquote.\n>\n> This is the second paragraph in the blockquote.\n>\n> ## This is an H2 in a blockquote\n\n## 3.段落\n\n> 一篇文章由N个段落组成。一个段落由一个或多个连续的行构成，Markdown通过一个以上的空行区别不同的段落。只要看起来像空行，不管是由空格符还是tab组成的，一律视为空行。\n\n> 多个空格会被看成一个空格。一般段落首行没有缩进，如果需要首行缩进的话可用&emsp; (全方大空白)或 &ensp; （半方大空格）\n\n&emsp;&emsp;这是段落1\n\n&ensp;&ensp;这是段落2\n\n## 4.强调\n\n> Markdown使用星号 * 和底线 _ 标记强调区段。在强调部分前加上标记，在强调部分结束后加上标记限制强调范围。注意星号强调标志与强调内容之间不能有空格存在，不然变成无序列表了。\n\n*强调部分变为斜体*   \n\n_强调部分变为斜体_\n\n**加重强调部分变为粗体**  \n\n__加重强调变为粗体__\n\n***特别强调部分变为粗斜体*** \n\n___特别强调部分变为粗斜体___\n\n## 5.列表\n\n> 列表分为无序列表和有序列表两种。 无序列表使用星号、加号、减号三种中任意一种作为无序列表的项目标记。三种符号可混用，但不建议这样做。注意列表标记和列表项目之间必须至少一个空格。\n\n*  无序列表中一项\n* 子项，以一个tab或者4个空格缩进\n* 无序列表中另一项\n+ 无序列表另一项\n- 无序列表另一项\n\n> 有序列表使用数字接一个英文句点作为项目标记。注意数字和句点间不能有空格，句点和项目内容之间至少有一个空格\n\n1. 有序列表一项\n2. 有序列表另一项\n1. 有序列表最后一项\n\n## 6.链接\n\n> Markdown支持两种形式链接语法\n\n> 1.行内插入链接：要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可\n\n[链接文字链接文字](链接地址)\n\n示例: [github](http://www.github.com)\n\nThis is [an example](http://example.com/ \"Title\") inline link.\n\n[This link](http://example.net/) has no title attribute.\n\n> 2.参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记\n\n[链接文字][链接引用标签]\n\n[链接引用标签]: 链接地址 \"http://www.baidu.com\"\n\n锚点  跳到页面的最后\n\nThis is [an example](#jump) reference-style link.\n\n## 7.图片\n\n> 图片引用类似于链接引用。图片可以是网络图片，也可以是本地图片，本地图片建议放在source/images目录中，按年月建立两层目录放置便于归档。本地图片的url类似为/images/year/month/img.png。\n\n```![alt MyEmail](/images/myemail.png \"MyEmail\")```\n\n![alt MyEmail](/images/myemail.png \"MyEmail\")\n\n## 8.代码\n\n> 第一种：简单文字出现一个代码框。使用`<blockquote>`。（`不是单引号而是左上角的ESC下面~中的`）\n\n> 第二种：大片文字需要实现代码框。使用Tab和四个空格。\n\n`let a = 10;`\n\n        let b = 12;\n        let c = 22;\n\n## 9.水平分割线\n\n> 要生成水平分割线，可以在单独一行里输入3个或以上的短横线（减号）、星号或者下划线实现。短横线和星号之间可以输入任意空格。以下每一行都产生一条水平分割线\n\n-------------------\n**     *\n__  _\n__    _\n\n## 10.表格\n\n## 常用语法\n\n| 输出后的效果 | Markdown | 快捷键 |\n| ------------- |:-------------:| -----:|\n| Bold | **text** | Ctrl/⌘ + B |\n| Emphasize | *text* | Ctrl/⌘ + I |\n| Strike-through | ~~text~~ | Ctrl + Alt + U |\n| Link | [title](http://www.baidu.com)| Ctrl/⌘ + K |\n| Inline Code | `code` | Ctrl/⌘ + Shift + K |\n| Image | ![alt](http://) | Ctrl/⌘ + Shift + I |\n| List | * item |Ctrl + L |\n| Blockquote | > quote | Ctrl + Q |\n| H1 | # H1 | Ctrl/⌘ + I |\n| H2 | ## H2 | Ctrl/⌘ + H |\n| H3 | ### H3 | Ctrl/⌘ + H (x2) |\n\n## 11.片段\n\n这是一个普通段落：\n\n\t这是一个代码区块。\n\n<p>这是一个普通段落：</p>\n<pre>\n<code>这是一个代码区块。</code>\n</pre>\n\n```javascript\n  var ihubo = {\n    nickName  : \"草依山\",\n    site : \"http://jser.me\"\n  }\n```\n<span id = \"jump\">跳转到这里：</span>\n\n## 相关链接：\n\n* [Markdown语法](http://www.appinn.com/markdown/)\n* [Markdown-语法手册](http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C)\n\n\n","slug":"markdown","published":1,"updated":"2017-12-03T07:24:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaqhv1g30001btx1dbbnfunk","content":"<blockquote>\n<p>Markdown是一种可以使用普通文本编辑器编写的<a href=\"https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/5964436?fr=aladdin,\" title=\"标记语言\" target=\"_blank\" rel=\"noopener\">标记语言</a>，通过简单的标记语法，它可以使普通文本内容具有一定的格式</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h2><blockquote>\n<p>Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客 当然还有其他的用途</p>\n</blockquote>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><blockquote>\n<p>实现「易读易写」成为一种适用于网络的书写语言，Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然</p>\n</blockquote>\n<h2 id=\"Markdown-语法的简要规则\"><a href=\"#Markdown-语法的简要规则\" class=\"headerlink\" title=\"Markdown 语法的简要规则\"></a>Markdown 语法的简要规则</h2><h2 id=\"1-标题\"><a href=\"#1-标题\" class=\"headerlink\" title=\"1.标题\"></a>1.标题</h2><blockquote>\n<p>标题是每篇文章都需要也是最常用的格式，Markdown支持两种标题语法，Settext和atx形式。</p>\n<p>Settext形式：利用底线形式，用 = （最高级标题） 和 - （第二级标题）作为底线形式标题的标记。</p>\n<p>atx形式：在行首插入 1 到 6 个 #，对应标题 1 到 6 级（从大到小顺序）。</p>\n</blockquote>\n<h1 id=\"标题Settext形式\"><a href=\"#标题Settext形式\" class=\"headerlink\" title=\"标题Settext形式\"></a>标题Settext形式</h1><h2 id=\"标题Settext形式-1\"><a href=\"#标题Settext形式-1\" class=\"headerlink\" title=\"标题Settext形式\"></a>标题Settext形式</h2><h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><h6 id=\"六级标题\"><a href=\"#六级标题\" class=\"headerlink\" title=\"六级标题\"></a>六级标题</h6><h2 id=\"2-引用\"><a href=\"#2-引用\" class=\"headerlink\" title=\"2.引用\"></a>2.引用</h2><blockquote>\n<p>文章中经常引用别人的话，为区别开来可以用引用标记特别注明。Markdown中使用email形式的 ‘&gt;‘（右尖括号号）。可以在引用段落前加一个，也可以在段落每行前面加一个。如果区块引用由几段组成，引用段落之间需要加一个 &gt;区分引用不同段落（这是引用标记和段落标记的组合）</p>\n<p>This is a blockquote.</p>\n<p>This is the second paragraph in the blockquote.</p>\n<h2 id=\"This-is-an-H2-in-a-blockquote\"><a href=\"#This-is-an-H2-in-a-blockquote\" class=\"headerlink\" title=\"This is an H2 in a blockquote\"></a>This is an H2 in a blockquote</h2></blockquote>\n<h2 id=\"3-段落\"><a href=\"#3-段落\" class=\"headerlink\" title=\"3.段落\"></a>3.段落</h2><blockquote>\n<p>一篇文章由N个段落组成。一个段落由一个或多个连续的行构成，Markdown通过一个以上的空行区别不同的段落。只要看起来像空行，不管是由空格符还是tab组成的，一律视为空行。</p>\n<p>多个空格会被看成一个空格。一般段落首行没有缩进，如果需要首行缩进的话可用&emsp; (全方大空白)或 &ensp; （半方大空格）</p>\n</blockquote>\n<p>&emsp;&emsp;这是段落1</p>\n<p>&ensp;&ensp;这是段落2</p>\n<h2 id=\"4-强调\"><a href=\"#4-强调\" class=\"headerlink\" title=\"4.强调\"></a>4.强调</h2><blockquote>\n<p>Markdown使用星号 * 和底线 _ 标记强调区段。在强调部分前加上标记，在强调部分结束后加上标记限制强调范围。注意星号强调标志与强调内容之间不能有空格存在，不然变成无序列表了。</p>\n</blockquote>\n<p><em>强调部分变为斜体</em>   </p>\n<p><em>强调部分变为斜体</em></p>\n<p><strong>加重强调部分变为粗体</strong>  </p>\n<p><strong>加重强调变为粗体</strong></p>\n<p><strong><em>特别强调部分变为粗斜体</em></strong> </p>\n<p><strong><em>特别强调部分变为粗斜体</em></strong></p>\n<h2 id=\"5-列表\"><a href=\"#5-列表\" class=\"headerlink\" title=\"5.列表\"></a>5.列表</h2><blockquote>\n<p>列表分为无序列表和有序列表两种。 无序列表使用星号、加号、减号三种中任意一种作为无序列表的项目标记。三种符号可混用，但不建议这样做。注意列表标记和列表项目之间必须至少一个空格。</p>\n</blockquote>\n<ul>\n<li>无序列表中一项</li>\n<li>子项，以一个tab或者4个空格缩进</li>\n<li>无序列表中另一项</li>\n</ul>\n<ul>\n<li>无序列表另一项</li>\n</ul>\n<ul>\n<li>无序列表另一项</li>\n</ul>\n<blockquote>\n<p>有序列表使用数字接一个英文句点作为项目标记。注意数字和句点间不能有空格，句点和项目内容之间至少有一个空格</p>\n</blockquote>\n<ol>\n<li>有序列表一项</li>\n<li>有序列表另一项</li>\n<li>有序列表最后一项</li>\n</ol>\n<h2 id=\"6-链接\"><a href=\"#6-链接\" class=\"headerlink\" title=\"6.链接\"></a>6.链接</h2><blockquote>\n<p>Markdown支持两种形式链接语法</p>\n<p>1.行内插入链接：要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可</p>\n</blockquote>\n<p><a href=\"链接地址\">链接文字链接文字</a></p>\n<p>示例: <a href=\"http://www.github.com\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<p>This is <a href=\"http://example.com/\" title=\"Title\" target=\"_blank\" rel=\"noopener\">an example</a> inline link.</p>\n<p><a href=\"http://example.net/\" target=\"_blank\" rel=\"noopener\">This link</a> has no title attribute.</p>\n<blockquote>\n<p>2.参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记</p>\n</blockquote>\n<p><a href=\"链接地址\" title=\"http://www.baidu.com\">链接文字</a></p>\n<p>锚点  跳到页面的最后</p>\n<p>This is <a href=\"#jump\">an example</a> reference-style link.</p>\n<h2 id=\"7-图片\"><a href=\"#7-图片\" class=\"headerlink\" title=\"7.图片\"></a>7.图片</h2><blockquote>\n<p>图片引用类似于链接引用。图片可以是网络图片，也可以是本地图片，本地图片建议放在source/images目录中，按年月建立两层目录放置便于归档。本地图片的url类似为/images/year/month/img.png。</p>\n</blockquote>\n<figure class=\"highlight plain\"><figcaption><span>MyEmail](/images/myemail.png \"MyEmail\")```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">![alt MyEmail](/images/myemail.png &quot;MyEmail&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">## 8.代码</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 第一种：简单文字出现一个代码框。使用`&lt;blockquote&gt;`。（`不是单引号而是左上角的ESC下面~中的`）</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 第二种：大片文字需要实现代码框。使用Tab和四个空格。</span><br><span class=\"line\"></span><br><span class=\"line\">`let a = 10;`</span><br><span class=\"line\"></span><br><span class=\"line\">        let b = 12;</span><br><span class=\"line\">        let c = 22;</span><br><span class=\"line\"></span><br><span class=\"line\">## 9.水平分割线</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 要生成水平分割线，可以在单独一行里输入3个或以上的短横线（减号）、星号或者下划线实现。短横线和星号之间可以输入任意空格。以下每一行都产生一条水平分割线</span><br><span class=\"line\"></span><br><span class=\"line\">-------------------</span><br><span class=\"line\">**     *</span><br><span class=\"line\">__  _</span><br><span class=\"line\">__    _</span><br><span class=\"line\"></span><br><span class=\"line\">## 10.表格</span><br><span class=\"line\"></span><br><span class=\"line\">## 常用语法</span><br><span class=\"line\"></span><br><span class=\"line\">| 输出后的效果 | Markdown | 快捷键 |</span><br><span class=\"line\">| ------------- |:-------------:| -----:|</span><br><span class=\"line\">| Bold | **text** | Ctrl/⌘ + B |</span><br><span class=\"line\">| Emphasize | *text* | Ctrl/⌘ + I |</span><br><span class=\"line\">| Strike-through | ~~text~~ | Ctrl + Alt + U |</span><br><span class=\"line\">| Link | [title](http://www.baidu.com)| Ctrl/⌘ + K |</span><br><span class=\"line\">| Inline Code | `code` | Ctrl/⌘ + Shift + K |</span><br><span class=\"line\">| Image | ![alt](http://) | Ctrl/⌘ + Shift + I |</span><br><span class=\"line\">| List | * item |Ctrl + L |</span><br><span class=\"line\">| Blockquote | &gt; quote | Ctrl + Q |</span><br><span class=\"line\">| H1 | # H1 | Ctrl/⌘ + I |</span><br><span class=\"line\">| H2 | ## H2 | Ctrl/⌘ + H |</span><br><span class=\"line\">| H3 | ### H3 | Ctrl/⌘ + H (x2) |</span><br><span class=\"line\"></span><br><span class=\"line\">## 11.片段</span><br><span class=\"line\"></span><br><span class=\"line\">这是一个普通段落：</span><br><span class=\"line\"></span><br><span class=\"line\">\t这是一个代码区块。</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;p&gt;这是一个普通段落：&lt;/p&gt;</span><br><span class=\"line\">&lt;pre&gt;</span><br><span class=\"line\">&lt;code&gt;这是一个代码区块。&lt;/code&gt;</span><br><span class=\"line\">&lt;/pre&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">```javascript</span><br><span class=\"line\">  var ihubo = &#123;</span><br><span class=\"line\">    nickName  : &quot;草依山&quot;,</span><br><span class=\"line\">    site : &quot;http://jser.me&quot;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p><span id=\"jump\">跳转到这里：</span></p>\n<h2 id=\"相关链接：\"><a href=\"#相关链接：\" class=\"headerlink\" title=\"相关链接：\"></a>相关链接：</h2><ul>\n<li><a href=\"http://www.appinn.com/markdown/\" target=\"_blank\" rel=\"noopener\">Markdown语法</a></li>\n<li><a href=\"http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C\" target=\"_blank\" rel=\"noopener\">Markdown-语法手册</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Markdown是一种可以使用普通文本编辑器编写的<a href=\"https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/5964436?fr=aladdin,\" title=\"标记语言\" target=\"_blank\" rel=\"noopener\">标记语言</a>，通过简单的标记语法，它可以使普通文本内容具有一定的格式</p>\n</blockquote>","more":"<h2 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h2><blockquote>\n<p>Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客 当然还有其他的用途</p>\n</blockquote>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><blockquote>\n<p>实现「易读易写」成为一种适用于网络的书写语言，Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然</p>\n</blockquote>\n<h2 id=\"Markdown-语法的简要规则\"><a href=\"#Markdown-语法的简要规则\" class=\"headerlink\" title=\"Markdown 语法的简要规则\"></a>Markdown 语法的简要规则</h2><h2 id=\"1-标题\"><a href=\"#1-标题\" class=\"headerlink\" title=\"1.标题\"></a>1.标题</h2><blockquote>\n<p>标题是每篇文章都需要也是最常用的格式，Markdown支持两种标题语法，Settext和atx形式。</p>\n<p>Settext形式：利用底线形式，用 = （最高级标题） 和 - （第二级标题）作为底线形式标题的标记。</p>\n<p>atx形式：在行首插入 1 到 6 个 #，对应标题 1 到 6 级（从大到小顺序）。</p>\n</blockquote>\n<h1 id=\"标题Settext形式\"><a href=\"#标题Settext形式\" class=\"headerlink\" title=\"标题Settext形式\"></a>标题Settext形式</h1><h2 id=\"标题Settext形式-1\"><a href=\"#标题Settext形式-1\" class=\"headerlink\" title=\"标题Settext形式\"></a>标题Settext形式</h2><h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><h6 id=\"六级标题\"><a href=\"#六级标题\" class=\"headerlink\" title=\"六级标题\"></a>六级标题</h6><h2 id=\"2-引用\"><a href=\"#2-引用\" class=\"headerlink\" title=\"2.引用\"></a>2.引用</h2><blockquote>\n<p>文章中经常引用别人的话，为区别开来可以用引用标记特别注明。Markdown中使用email形式的 ‘&gt;‘（右尖括号号）。可以在引用段落前加一个，也可以在段落每行前面加一个。如果区块引用由几段组成，引用段落之间需要加一个 &gt;区分引用不同段落（这是引用标记和段落标记的组合）</p>\n<p>This is a blockquote.</p>\n<p>This is the second paragraph in the blockquote.</p>\n<h2 id=\"This-is-an-H2-in-a-blockquote\"><a href=\"#This-is-an-H2-in-a-blockquote\" class=\"headerlink\" title=\"This is an H2 in a blockquote\"></a>This is an H2 in a blockquote</h2></blockquote>\n<h2 id=\"3-段落\"><a href=\"#3-段落\" class=\"headerlink\" title=\"3.段落\"></a>3.段落</h2><blockquote>\n<p>一篇文章由N个段落组成。一个段落由一个或多个连续的行构成，Markdown通过一个以上的空行区别不同的段落。只要看起来像空行，不管是由空格符还是tab组成的，一律视为空行。</p>\n<p>多个空格会被看成一个空格。一般段落首行没有缩进，如果需要首行缩进的话可用&emsp; (全方大空白)或 &ensp; （半方大空格）</p>\n</blockquote>\n<p>&emsp;&emsp;这是段落1</p>\n<p>&ensp;&ensp;这是段落2</p>\n<h2 id=\"4-强调\"><a href=\"#4-强调\" class=\"headerlink\" title=\"4.强调\"></a>4.强调</h2><blockquote>\n<p>Markdown使用星号 * 和底线 _ 标记强调区段。在强调部分前加上标记，在强调部分结束后加上标记限制强调范围。注意星号强调标志与强调内容之间不能有空格存在，不然变成无序列表了。</p>\n</blockquote>\n<p><em>强调部分变为斜体</em>   </p>\n<p><em>强调部分变为斜体</em></p>\n<p><strong>加重强调部分变为粗体</strong>  </p>\n<p><strong>加重强调变为粗体</strong></p>\n<p><strong><em>特别强调部分变为粗斜体</em></strong> </p>\n<p><strong><em>特别强调部分变为粗斜体</em></strong></p>\n<h2 id=\"5-列表\"><a href=\"#5-列表\" class=\"headerlink\" title=\"5.列表\"></a>5.列表</h2><blockquote>\n<p>列表分为无序列表和有序列表两种。 无序列表使用星号、加号、减号三种中任意一种作为无序列表的项目标记。三种符号可混用，但不建议这样做。注意列表标记和列表项目之间必须至少一个空格。</p>\n</blockquote>\n<ul>\n<li>无序列表中一项</li>\n<li>子项，以一个tab或者4个空格缩进</li>\n<li>无序列表中另一项</li>\n</ul>\n<ul>\n<li>无序列表另一项</li>\n</ul>\n<ul>\n<li>无序列表另一项</li>\n</ul>\n<blockquote>\n<p>有序列表使用数字接一个英文句点作为项目标记。注意数字和句点间不能有空格，句点和项目内容之间至少有一个空格</p>\n</blockquote>\n<ol>\n<li>有序列表一项</li>\n<li>有序列表另一项</li>\n<li>有序列表最后一项</li>\n</ol>\n<h2 id=\"6-链接\"><a href=\"#6-链接\" class=\"headerlink\" title=\"6.链接\"></a>6.链接</h2><blockquote>\n<p>Markdown支持两种形式链接语法</p>\n<p>1.行内插入链接：要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可</p>\n</blockquote>\n<p><a href=\"链接地址\">链接文字链接文字</a></p>\n<p>示例: <a href=\"http://www.github.com\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<p>This is <a href=\"http://example.com/\" title=\"Title\" target=\"_blank\" rel=\"noopener\">an example</a> inline link.</p>\n<p><a href=\"http://example.net/\" target=\"_blank\" rel=\"noopener\">This link</a> has no title attribute.</p>\n<blockquote>\n<p>2.参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记</p>\n</blockquote>\n<p><a href=\"链接地址\" title=\"http://www.baidu.com\">链接文字</a></p>\n<p>锚点  跳到页面的最后</p>\n<p>This is <a href=\"#jump\">an example</a> reference-style link.</p>\n<h2 id=\"7-图片\"><a href=\"#7-图片\" class=\"headerlink\" title=\"7.图片\"></a>7.图片</h2><blockquote>\n<p>图片引用类似于链接引用。图片可以是网络图片，也可以是本地图片，本地图片建议放在source/images目录中，按年月建立两层目录放置便于归档。本地图片的url类似为/images/year/month/img.png。</p>\n</blockquote>\n<figure class=\"highlight plain\"><figcaption><span>MyEmail](/images/myemail.png \"MyEmail\")```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">![alt MyEmail](/images/myemail.png &quot;MyEmail&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">## 8.代码</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 第一种：简单文字出现一个代码框。使用`&lt;blockquote&gt;`。（`不是单引号而是左上角的ESC下面~中的`）</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 第二种：大片文字需要实现代码框。使用Tab和四个空格。</span><br><span class=\"line\"></span><br><span class=\"line\">`let a = 10;`</span><br><span class=\"line\"></span><br><span class=\"line\">        let b = 12;</span><br><span class=\"line\">        let c = 22;</span><br><span class=\"line\"></span><br><span class=\"line\">## 9.水平分割线</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 要生成水平分割线，可以在单独一行里输入3个或以上的短横线（减号）、星号或者下划线实现。短横线和星号之间可以输入任意空格。以下每一行都产生一条水平分割线</span><br><span class=\"line\"></span><br><span class=\"line\">-------------------</span><br><span class=\"line\">**     *</span><br><span class=\"line\">__  _</span><br><span class=\"line\">__    _</span><br><span class=\"line\"></span><br><span class=\"line\">## 10.表格</span><br><span class=\"line\"></span><br><span class=\"line\">## 常用语法</span><br><span class=\"line\"></span><br><span class=\"line\">| 输出后的效果 | Markdown | 快捷键 |</span><br><span class=\"line\">| ------------- |:-------------:| -----:|</span><br><span class=\"line\">| Bold | **text** | Ctrl/⌘ + B |</span><br><span class=\"line\">| Emphasize | *text* | Ctrl/⌘ + I |</span><br><span class=\"line\">| Strike-through | ~~text~~ | Ctrl + Alt + U |</span><br><span class=\"line\">| Link | [title](http://www.baidu.com)| Ctrl/⌘ + K |</span><br><span class=\"line\">| Inline Code | `code` | Ctrl/⌘ + Shift + K |</span><br><span class=\"line\">| Image | ![alt](http://) | Ctrl/⌘ + Shift + I |</span><br><span class=\"line\">| List | * item |Ctrl + L |</span><br><span class=\"line\">| Blockquote | &gt; quote | Ctrl + Q |</span><br><span class=\"line\">| H1 | # H1 | Ctrl/⌘ + I |</span><br><span class=\"line\">| H2 | ## H2 | Ctrl/⌘ + H |</span><br><span class=\"line\">| H3 | ### H3 | Ctrl/⌘ + H (x2) |</span><br><span class=\"line\"></span><br><span class=\"line\">## 11.片段</span><br><span class=\"line\"></span><br><span class=\"line\">这是一个普通段落：</span><br><span class=\"line\"></span><br><span class=\"line\">\t这是一个代码区块。</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;p&gt;这是一个普通段落：&lt;/p&gt;</span><br><span class=\"line\">&lt;pre&gt;</span><br><span class=\"line\">&lt;code&gt;这是一个代码区块。&lt;/code&gt;</span><br><span class=\"line\">&lt;/pre&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">```javascript</span><br><span class=\"line\">  var ihubo = &#123;</span><br><span class=\"line\">    nickName  : &quot;草依山&quot;,</span><br><span class=\"line\">    site : &quot;http://jser.me&quot;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p><span id=\"jump\">跳转到这里：</span></p>\n<h2 id=\"相关链接：\"><a href=\"#相关链接：\" class=\"headerlink\" title=\"相关链接：\"></a>相关链接：</h2><ul>\n<li><a href=\"http://www.appinn.com/markdown/\" target=\"_blank\" rel=\"noopener\">Markdown语法</a></li>\n<li><a href=\"http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C\" target=\"_blank\" rel=\"noopener\">Markdown-语法手册</a></li>\n</ul>"},{"title":"css3","date":"2017-10-17T06:37:12.000Z","_content":"\n* [calc()使用](#0)\n* [边框](#1)\n* [背景](#2)\n* [渐变](#3)\n* [文本效果](#4)\n* [2D转换](#5)\n* [3D转换](#6)\n* [过渡](#7)\n* [动画](#8)\n* [多列](#9)\n* [用户界面](#10)\n* [弹性盒](#11)\n\n## <span id='0'>[calc()使用](http://www.w3cplus.com/css3/how-to-use-css3-calc-function.html)</span>\n\n> 能实现自适应的布局 box-sizing, 浏览器对calc()的兼容性还算不错，在IE9+、FF4.0+、Chrome19+、Safari6+都得到较好支持著作权归作者所有。不过calc()最大的好处就是用在流体布局上(百分比)，可以通过calc()计算得到元素的宽度高度\n<!-- more -->\n```\n    #div{\n        float: left;\n        width: 50%;\n        width:calc(50% - 2px - 80px);\n        height: 100px;\n        background: red;\n        border: thin solid;\n        padding: 40px;\n        //box-sizing: border-box;\n    }\n```\n\n\n## <span id='1'>边框</span>\n\n\n\n> 用 CSS3，你可以创建圆角边框，添加阴影框，并作为边界的形象而不使用设计程序\n\n* border-radius (圆角)\n```\n    <div id='div'></div>\n    #div\n    {\n        width: 200px;\n        height: 200px;\n        border:2px solid;\n        border-radius:25px;\n    }\n```\n* box-shadow  (盒阴影)\n```\n    #div\n        {\n            width: 200px;\n            height: 200px;\n            box-shadow: 20px 20px 20px 0 gold inset;\n            box-shadow: 10px 10px 5px #888888;\n            background: red;\n            margin: 50px;\n            // box-shadow: 10px(向右偏移,可取负数,必填) \n                           10px(向下偏移,可取负数,必填) \n                           20px(模糊距离,可选)\n                           5px(阴影尺寸 可选)                                      \n                           #888888(颜色,可选 默认黑色)\n                           inset(内阴影,可选);\n        }\n```\n* [border-image](http://www.runoob.com/cssref/css3-pr-border-image.html)  (边界图片) ...Internet Explorer 不支持\n\n        border-image:   source(图片路径) \n                        slice(图像边界向内偏移) \n                        width(图像边界的宽度) \n                        outset(用于指定在边框外部绘制 border-image-area 的量) \n                        repeat|initial|inherit(用于设置图像边界是否应重复（repeat）、拉伸（stretch）或铺满（round）);\n    默认border-image: none 100% 1 0 stretch\n\n## <span id='2'>背景</span>\n\n* background-size: 100% 100%(200px 200px)注:(写成px的时候不包含padding 加box-sizing: border-box 一样)   (规定背景的绘制区域)\n\n```\n    #div {\n        width: 200px;\n        height: 200px;\n        padding: 20px;\n        background: #ccc url('http://pic10.nipic.com/20101014/5888301_112136782000_2.jpg') no-repeat;\n        background-size: 100% 100%;\n        box-sizing: border-box;\n        /* background-size: 240px 240px; *\n    }\n\n```\n* background-origin  (content-box(只填充内容区域)、padding-box(包含padding) 或 border-box(包含边框) ) =>  相对于背景图片(背景色完全没有作用  规定背景图片的定位区域)\n\n```\n    #div {\n        width: 200px;\n        height: 200px;\n        padding: 20px;\n        border: 10px dotted red;\n        background: #ccc url('http://pic10.nipic.com/20101014/5888301_112136782000_2.jpg') no-repeat;\n        background-size: 100% 100%;\n        background-origin: content-box;\n        //background-origin: padding-box;\n        //background-origin: border-box;\n    }\n\n```\n* background-clip (content-box(只填充内容区域)、padding-box(包含padding) 或 border-box(包含边框) )=>相对于背景色(对图片的padding content 有作用  对border-box无用(默认就是))  (规定背景图片的尺寸)\n\n```\n    #div {\n        width: 200px;\n        height: 200px;\n        padding: 20px;\n        background:  url('http://pic10.nipic.com/20101014/5888301_112136782000_2.jpg') no-repeat;\n        background-size: 100% 100%;\n        background-color: green;\n        background-clip: border-box;\n        /* background-origin: border-box; */\n        border: 10px dashed red;\n    }\n```\n* background-origin与background-clip区别\n\n1. background-origin只作用于背景图片,对背景色无用, background-clip即可作用于背景图片,也可作用于背景色\n2. 当两者都作用于背景图片时, 不同于border-box 属性,background-origin边框在图片上面, 并且填充了边框,  background-clip 没有填充边框\n\n## <span id='3'>渐变 (线性渐变) (径向渐变)</span>\n\n> 在两个或多个指定的颜色之间显示平稳的过渡,如果你想要在渐变的方向上做更多的控制，你可以定义一个角度(逆时针)，而不用预定义方向（to bottom、to top、to right、to left、to bottom right，等等）\n\n* 线性渐变 background: linear-gradient(direction(90deg), color-stop1, color-stop2, ...);\n\n```\n    #div \n        {\n        width: 200px;\n        height: 200px;\n        background: -webkit-linear-gradient(top, red, blue, green);\n        //background: -webkit-linear-gradient(left, red, blue, green);\n        //background: -webkit-linear-gradient(top left, red, blue, green);\n        //background: -webkit-linear-gradient(left bottom, red, blue, green);\n        //background: -webkit-repeating-linear-gradient(top left, red, blue 10%,green 30%);//重复渐变\n    }\n```\n\n* 径向渐变 background: radial-gradient(center, shape(ellipse/circle) size, start-color, ..., last-color);\n\n```\n    #div\n        {\n            width: 200px;\n            height: 200px;\n            background: -webkit-radial-gradient(red, green, blue);\n            //background: -webkit-radial-gradient(red 5%, green 15%, blue 60%);\n            //background: -webkit-repeating-radial-gradient(red, green 10%, blue 15%);//重复渐变\n        }\n```\n## <span id='4'>文本效果</span>\n\n* text-shadow: 5px(水平阴影)   5px(垂直阴影)   10px(模糊距离)   green;\n```\n    #div\n        {\n            width: 200px;\n            height: 200px;\n            text-shadow: 5px 5px 5px #FF0000;\n            font-size: 40px;\n        }\n```\n* word-wrap:break-word(自动换行)   文字超出会自动换行    字母 数字 标点符号不换  (ps不兼容 Opera)\n\n```\n #div\n    {\n        width: 200px;\n        height: 200px;\n        text-shadow: 5px 5px 5px #FF0000;\n        font-size: 40px;\n        border: 2px solid red;\n        word-wrap:break-word;\n    }\n```\n## <span id='5'>2D转换</span>\n\n > 可以移动，比例化，反过来，旋转，和拉伸元素。\n transform  (IE10 ff  Opera 支持. IE9(-ms-)和Chrome Safari(-webkit-) 要加前缀)\n\n* transform: translate(50px, 50px) (translateX/Y)    (上下 作用偏移,以元素中心点为中心偏移,设置transform-origin属性无用)\n* transform: rotate(90deg) rotate(X/Y)               (旋转,以中心为原点旋转,可改变中心点)\n* transform: scale(2,2) (scaleX/Y)                   (元素尺寸增加或减少倍数,中心点旋转,可改变中心点)\n* transform: skew(10deg,0deg) (skewX/Y)              (元素翻转 x y,中心点旋转,可改变中心点)\n* transform:matrix(0.866,0.5,-0.5,0.866,0,0)         (matrix()方法,六个参数，包含旋转，缩放，移动（平移）和倾斜功能)\n* transform-origin:0 0;                              (允许改变被转换元素的位置,默认元素中心点)\n\n```#div\n    {\n        width: 200px;\n        height: 200px;\n        background: red;\n        //transform:translate(200px,200px);\n        //transform: rotate(30deg);\n        //transform-origin:0 0;\n        //transform: skew(30deg,20deg);\n        transform: scale(2,2)\n        //transform:matrix(0.866,0.5,-0.5,0.866,0,0);\n        margin: 100px auto;\n        transform-origin:0 0;\n        //animation:myfirst 5s linear 2s infinite alternate;\n    }\n    @keyframes myfirst\n        {\n        from {transform: scale(1,1)}\n        to {transform: scale(2,2)}\n        }\n```\n## <span id='6'>3D转换</span>\n\n> 方法 同2D 只是多了Z轴  rotate可以规定X Y Z (transform: rotateX/Y/Z(30deg))\n\n* transform: translate3d(x,y,z)\n* transform: scale3d(x,y,z)\n* transform: rotate3d(x,y,z,angle)\n* perspective: 500 (设置从何处查看一个元素的角度,perspective 属性只影响 3D 转换元素)\n* perspective-origin: 10% 10% (设置一个3D元素的基数位置)\n* transform-style: preserve-3d (让转换的子元素保留3D转换)\n\n## <span id='7'>过渡</span>\n\n> 为了添加某种效果可以从一种样式转变到另一个的时候，无需使用Flash动画或JavaScript\n\n* transition 属性是一个简写属性，用于设置四个过渡属性  (默认all 0 ease 0) (给运动元素加此属性,hover时加要变的属性)\n* transition-property (哪个属性变)\n* transition-duration (完成这个效果的时间  必须设置 否则默认为0)\n* transition-timing-function ([规定速度效果的速度曲线](http://www.runoob.com/cssref/css3-pr-transition-timing-function.html)   linear|ease|ease-in|ease-out|ease-in-out)\n* transition-delay (效果延时多少开始)\n\n```\n    #div\n        {\n            width:100px;\n            height:100px;\n            background:red;\n            transition:width 2s;\n        }\n\n    #div:hover\n        {\n            width:300px;\n        }\n```\n## <span id='8'>动画</span>\n\n* @keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果\n* 先定义动画,然后在动画元素属性里面调用,(animation: 动画名  运动的时间 [速度曲线](http://www.runoob.com/cssref/css3-pr-animation-timing-function.html) 延时多少开始 运动次数(infinite 无数次)  反向播放动画 )\n* animation:myfirst 5s linear 2s infinite alternate;\n* animation-play-state:running/paused (属性规定动画正在运行还是暂停 js中使用 可以控制动画暂停与播放)\n\n```\n    #div \n        {\n            width: 100px;\n            height: 100px;\n            position:relative;\n            animation:myfirst 5s linear 2s infinite alternate;\n            //animation-play-state:paused;\n        }\n    @keyframes myfirst\n        {\n            0%   {background:red; left:0px; top:0px;}\n            25%  {background:yellow; left:200px; top:0px;}\n            50%  {background:blue; left:200px; top:200px;}\n            75%  {background:green; left:0px; top:200px;}\n            100% {background:red; left:0px; top:0px;}\n        } \n```\n\n## <span id='9'>多列</span>\n\n> 可以将文本内容设计成像报纸一样的多列布局\n\n* column-count 属性规定元素应该被分隔的列数  (column-count:3)\n* column-gap 属性规定列之间的间隔 (column-gap:30px)\n* column-rule 属性设置列之间的宽度、样式和颜色规则  (column-rule:4px outset #ff0000)\n* column-width 属性规定列的宽度  (column-width: auto(浏览器决定 没有效果) / 100px)\n* column-span 属性规定元素应横跨多少列  (column-span: 1 / all)\n* columns 属性是一个简写属性，用于设置列宽和列数   (columns:100px(4) 3(1);)\n\n```\n    <div id=\"div\">\n        <h2>英国维斯米斯特教堂碑文</h2>\n        当我年轻的时候，我梦想改变这个世界；当我成熟以后，我发现我不能够改变这个世界，我将目光缩短了些，决定只改变我的国家；当我进入暮年以后，我发现我不能够改变我们的国家，我的最后愿望仅仅是改变一下我的家庭，但是，这也不可能。当我现在躺在床上，行将就木时，我突然意识到：如果一开始我仅仅去改变我自己，然后，我可能改变我的家庭；在家人的帮助和鼓励下，我可能为国家做一些事情；然后，谁知道呢?我甚至可能改变这个世界。\n    </div>\n    #div \n        {\n            column-count: 3;\n            column-gap:90px;\n            column-rule:4px outset #ff0000;\n            //column-rule:4px dotted #ff0000;\n            column-span: all;\n            column-width:100px;\n            //column-span: 1; // 默认\n            //columns:100px 3;\n        }\n        h2\n        {\n            column-span:1;\n            -webkit-column-span:1; /* Safari and Chrome */\n        }\n```\n\n## <span id=\"10\">用户界面</span> \n\n* 调整尺寸(Resizing)\n\n```\n    <div id='div'>调整属性指定一个元素是否由用户可调整大小的</div>\n    #div\n        {\n            border:2px solid;\n            padding:10px 40px; \n            width:300px;\n            resize:both;\n            overflow:auto;\n        }\n```\n* 外形修饰（outline-offset ）\n\n```\n    <div id='div'>\n        这个 div有一个轮廓边界15 px边境外的边缘。Internet Explorer 不兼容 outline-offset属性.\n    </div>\n    #div\n        {\n            margin:20px;\n            width:150px; \n            padding:10px;\n            height:70px;\n            border:2px solid black;\n            outline:2px solid red;\n            outline-offset:15px;\n        }\n```\n\n##  <span id=\"11\">弹性盒</span> \n\n> 弹性盒子是 CSS3 的一种新的布局模式。CSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间\n\n* 弹性盒子 = 弹性容器(Flex container) + 弹性子元素(Flex item)\n* 弹性容器设置 display 属性的值为 flex 或 inline-flex将其定义为弹性容器(弹性容器上)\n* direction: rtl (right-to-left) 修改弹性子元素的排列方式也会改变，页面布局也跟着改变 (弹性容器上)\n* flex-direction 顺序指定了弹性子元素在父容器中的位置 (flex-direction: row | row-reverse | column | column-reverse)(弹性容器上)\n    * row：横向从左到右排列（左对齐），默认\n    * row-reverse：反转横向排列（右对齐，从后往前排，最后一项排在最前面\n    * column：纵向排列\n    * column-reverse：反转纵向排列，从后往前排，最后一项排在最上面\n* justify-content(内容对齐): flex-start | flex-end | center | space-between | space-around (弹性容器上)\n* align-items(设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式): flex-start | flex-end | center | baseline | stretch(弹性容器上)\n* flex-wrap(用于指定弹性盒子的子元素换行方式): nowrap|wrap|wrap-reverse|initial|inherit; (弹性容器上)\n    * nowrap - 默认， 弹性容器为单行。该情况下弹性子项可能会溢出容器。\n    * wrap - 弹性容器为多行。该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行\n    * wrap-reverse -反转 wrap 排列\n* align-content(用于修改 flex-wrap 属性的行为): flex-start | flex-end | center | space-between | space-around | stretch, 类似于 align-items, 但它不是设置弹性子元素的对齐，而是设置各个行的对齐 (弹性容器上)\n    * stretch - 默认。各行将会伸展以占用剩余的空间。\n    * flex-start - 各行向弹性盒容器的起始位置堆叠。\n    * flex-end - 各行向弹性盒容器的结束位置堆叠。\n    * center -各行向弹性盒容器的中间位置堆叠。\n    * space-between -各行在弹性盒容器中平均分布。\n    * space-around - 各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。 \n\n### 弹性子元素属性\n\n* order 属性设置弹性容器内弹性子元素的属性\n* align-self (在弹性子元素上使用。覆盖容器的 align-items 属性): auto | flex-start | flex-end | center | baseline | stretch\n* flex (设置弹性盒子的子元素如何分配空间): auto | initial | none | inherit |  [ flex-grow ] || [ flex-shrink ] || [ flex-basis ]\n\n```\n    <div class=\"flex-container\">\n        <div class=\"flex-item\">flex item 1</div>\n        <div class=\"flex-item\">flex item 2</div>\n        <div class=\"flex-item\">flex item 3</div>\n        <div class=\"flex-item\">flex item 4</div>  \n    </div>\n\n    .flex-container {\n        display: -webkit-flex;\n        display: flex;\n        width: 400px;\n        height: 250px;\n        background-color: lightgrey;\n        //direction: rtl;\n        //flex-direction: row;\n        //flex-direction: row-reverse;\n        //flex-direction: column;\n        //flex-direction: column-reverse;\n        //justify-content: flex-start;\n        //justify-content: flex-end;\n        //justify-content: center;\n        //justify-content: space-between;\n        //justify-content: space-around;\n        //flex-wrap: nowrap;\n        //flex-wrap: wrap;\n        //flex-wrap: wrap-reverse;\n    }\n\n    .flex-item {\n        background-color: cornflowerblue;\n        width: 15%;\n        height: 100px;\n        margin: 10px;\n    }\n```\n","source":"_posts/css/css3.md","raw":"---\ntitle: css3\ndate: 2017-10-17 14:37:12\ntags:\n- css3\ncategories:\n- css\n---\n\n* [calc()使用](#0)\n* [边框](#1)\n* [背景](#2)\n* [渐变](#3)\n* [文本效果](#4)\n* [2D转换](#5)\n* [3D转换](#6)\n* [过渡](#7)\n* [动画](#8)\n* [多列](#9)\n* [用户界面](#10)\n* [弹性盒](#11)\n\n## <span id='0'>[calc()使用](http://www.w3cplus.com/css3/how-to-use-css3-calc-function.html)</span>\n\n> 能实现自适应的布局 box-sizing, 浏览器对calc()的兼容性还算不错，在IE9+、FF4.0+、Chrome19+、Safari6+都得到较好支持著作权归作者所有。不过calc()最大的好处就是用在流体布局上(百分比)，可以通过calc()计算得到元素的宽度高度\n<!-- more -->\n```\n    #div{\n        float: left;\n        width: 50%;\n        width:calc(50% - 2px - 80px);\n        height: 100px;\n        background: red;\n        border: thin solid;\n        padding: 40px;\n        //box-sizing: border-box;\n    }\n```\n\n\n## <span id='1'>边框</span>\n\n\n\n> 用 CSS3，你可以创建圆角边框，添加阴影框，并作为边界的形象而不使用设计程序\n\n* border-radius (圆角)\n```\n    <div id='div'></div>\n    #div\n    {\n        width: 200px;\n        height: 200px;\n        border:2px solid;\n        border-radius:25px;\n    }\n```\n* box-shadow  (盒阴影)\n```\n    #div\n        {\n            width: 200px;\n            height: 200px;\n            box-shadow: 20px 20px 20px 0 gold inset;\n            box-shadow: 10px 10px 5px #888888;\n            background: red;\n            margin: 50px;\n            // box-shadow: 10px(向右偏移,可取负数,必填) \n                           10px(向下偏移,可取负数,必填) \n                           20px(模糊距离,可选)\n                           5px(阴影尺寸 可选)                                      \n                           #888888(颜色,可选 默认黑色)\n                           inset(内阴影,可选);\n        }\n```\n* [border-image](http://www.runoob.com/cssref/css3-pr-border-image.html)  (边界图片) ...Internet Explorer 不支持\n\n        border-image:   source(图片路径) \n                        slice(图像边界向内偏移) \n                        width(图像边界的宽度) \n                        outset(用于指定在边框外部绘制 border-image-area 的量) \n                        repeat|initial|inherit(用于设置图像边界是否应重复（repeat）、拉伸（stretch）或铺满（round）);\n    默认border-image: none 100% 1 0 stretch\n\n## <span id='2'>背景</span>\n\n* background-size: 100% 100%(200px 200px)注:(写成px的时候不包含padding 加box-sizing: border-box 一样)   (规定背景的绘制区域)\n\n```\n    #div {\n        width: 200px;\n        height: 200px;\n        padding: 20px;\n        background: #ccc url('http://pic10.nipic.com/20101014/5888301_112136782000_2.jpg') no-repeat;\n        background-size: 100% 100%;\n        box-sizing: border-box;\n        /* background-size: 240px 240px; *\n    }\n\n```\n* background-origin  (content-box(只填充内容区域)、padding-box(包含padding) 或 border-box(包含边框) ) =>  相对于背景图片(背景色完全没有作用  规定背景图片的定位区域)\n\n```\n    #div {\n        width: 200px;\n        height: 200px;\n        padding: 20px;\n        border: 10px dotted red;\n        background: #ccc url('http://pic10.nipic.com/20101014/5888301_112136782000_2.jpg') no-repeat;\n        background-size: 100% 100%;\n        background-origin: content-box;\n        //background-origin: padding-box;\n        //background-origin: border-box;\n    }\n\n```\n* background-clip (content-box(只填充内容区域)、padding-box(包含padding) 或 border-box(包含边框) )=>相对于背景色(对图片的padding content 有作用  对border-box无用(默认就是))  (规定背景图片的尺寸)\n\n```\n    #div {\n        width: 200px;\n        height: 200px;\n        padding: 20px;\n        background:  url('http://pic10.nipic.com/20101014/5888301_112136782000_2.jpg') no-repeat;\n        background-size: 100% 100%;\n        background-color: green;\n        background-clip: border-box;\n        /* background-origin: border-box; */\n        border: 10px dashed red;\n    }\n```\n* background-origin与background-clip区别\n\n1. background-origin只作用于背景图片,对背景色无用, background-clip即可作用于背景图片,也可作用于背景色\n2. 当两者都作用于背景图片时, 不同于border-box 属性,background-origin边框在图片上面, 并且填充了边框,  background-clip 没有填充边框\n\n## <span id='3'>渐变 (线性渐变) (径向渐变)</span>\n\n> 在两个或多个指定的颜色之间显示平稳的过渡,如果你想要在渐变的方向上做更多的控制，你可以定义一个角度(逆时针)，而不用预定义方向（to bottom、to top、to right、to left、to bottom right，等等）\n\n* 线性渐变 background: linear-gradient(direction(90deg), color-stop1, color-stop2, ...);\n\n```\n    #div \n        {\n        width: 200px;\n        height: 200px;\n        background: -webkit-linear-gradient(top, red, blue, green);\n        //background: -webkit-linear-gradient(left, red, blue, green);\n        //background: -webkit-linear-gradient(top left, red, blue, green);\n        //background: -webkit-linear-gradient(left bottom, red, blue, green);\n        //background: -webkit-repeating-linear-gradient(top left, red, blue 10%,green 30%);//重复渐变\n    }\n```\n\n* 径向渐变 background: radial-gradient(center, shape(ellipse/circle) size, start-color, ..., last-color);\n\n```\n    #div\n        {\n            width: 200px;\n            height: 200px;\n            background: -webkit-radial-gradient(red, green, blue);\n            //background: -webkit-radial-gradient(red 5%, green 15%, blue 60%);\n            //background: -webkit-repeating-radial-gradient(red, green 10%, blue 15%);//重复渐变\n        }\n```\n## <span id='4'>文本效果</span>\n\n* text-shadow: 5px(水平阴影)   5px(垂直阴影)   10px(模糊距离)   green;\n```\n    #div\n        {\n            width: 200px;\n            height: 200px;\n            text-shadow: 5px 5px 5px #FF0000;\n            font-size: 40px;\n        }\n```\n* word-wrap:break-word(自动换行)   文字超出会自动换行    字母 数字 标点符号不换  (ps不兼容 Opera)\n\n```\n #div\n    {\n        width: 200px;\n        height: 200px;\n        text-shadow: 5px 5px 5px #FF0000;\n        font-size: 40px;\n        border: 2px solid red;\n        word-wrap:break-word;\n    }\n```\n## <span id='5'>2D转换</span>\n\n > 可以移动，比例化，反过来，旋转，和拉伸元素。\n transform  (IE10 ff  Opera 支持. IE9(-ms-)和Chrome Safari(-webkit-) 要加前缀)\n\n* transform: translate(50px, 50px) (translateX/Y)    (上下 作用偏移,以元素中心点为中心偏移,设置transform-origin属性无用)\n* transform: rotate(90deg) rotate(X/Y)               (旋转,以中心为原点旋转,可改变中心点)\n* transform: scale(2,2) (scaleX/Y)                   (元素尺寸增加或减少倍数,中心点旋转,可改变中心点)\n* transform: skew(10deg,0deg) (skewX/Y)              (元素翻转 x y,中心点旋转,可改变中心点)\n* transform:matrix(0.866,0.5,-0.5,0.866,0,0)         (matrix()方法,六个参数，包含旋转，缩放，移动（平移）和倾斜功能)\n* transform-origin:0 0;                              (允许改变被转换元素的位置,默认元素中心点)\n\n```#div\n    {\n        width: 200px;\n        height: 200px;\n        background: red;\n        //transform:translate(200px,200px);\n        //transform: rotate(30deg);\n        //transform-origin:0 0;\n        //transform: skew(30deg,20deg);\n        transform: scale(2,2)\n        //transform:matrix(0.866,0.5,-0.5,0.866,0,0);\n        margin: 100px auto;\n        transform-origin:0 0;\n        //animation:myfirst 5s linear 2s infinite alternate;\n    }\n    @keyframes myfirst\n        {\n        from {transform: scale(1,1)}\n        to {transform: scale(2,2)}\n        }\n```\n## <span id='6'>3D转换</span>\n\n> 方法 同2D 只是多了Z轴  rotate可以规定X Y Z (transform: rotateX/Y/Z(30deg))\n\n* transform: translate3d(x,y,z)\n* transform: scale3d(x,y,z)\n* transform: rotate3d(x,y,z,angle)\n* perspective: 500 (设置从何处查看一个元素的角度,perspective 属性只影响 3D 转换元素)\n* perspective-origin: 10% 10% (设置一个3D元素的基数位置)\n* transform-style: preserve-3d (让转换的子元素保留3D转换)\n\n## <span id='7'>过渡</span>\n\n> 为了添加某种效果可以从一种样式转变到另一个的时候，无需使用Flash动画或JavaScript\n\n* transition 属性是一个简写属性，用于设置四个过渡属性  (默认all 0 ease 0) (给运动元素加此属性,hover时加要变的属性)\n* transition-property (哪个属性变)\n* transition-duration (完成这个效果的时间  必须设置 否则默认为0)\n* transition-timing-function ([规定速度效果的速度曲线](http://www.runoob.com/cssref/css3-pr-transition-timing-function.html)   linear|ease|ease-in|ease-out|ease-in-out)\n* transition-delay (效果延时多少开始)\n\n```\n    #div\n        {\n            width:100px;\n            height:100px;\n            background:red;\n            transition:width 2s;\n        }\n\n    #div:hover\n        {\n            width:300px;\n        }\n```\n## <span id='8'>动画</span>\n\n* @keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果\n* 先定义动画,然后在动画元素属性里面调用,(animation: 动画名  运动的时间 [速度曲线](http://www.runoob.com/cssref/css3-pr-animation-timing-function.html) 延时多少开始 运动次数(infinite 无数次)  反向播放动画 )\n* animation:myfirst 5s linear 2s infinite alternate;\n* animation-play-state:running/paused (属性规定动画正在运行还是暂停 js中使用 可以控制动画暂停与播放)\n\n```\n    #div \n        {\n            width: 100px;\n            height: 100px;\n            position:relative;\n            animation:myfirst 5s linear 2s infinite alternate;\n            //animation-play-state:paused;\n        }\n    @keyframes myfirst\n        {\n            0%   {background:red; left:0px; top:0px;}\n            25%  {background:yellow; left:200px; top:0px;}\n            50%  {background:blue; left:200px; top:200px;}\n            75%  {background:green; left:0px; top:200px;}\n            100% {background:red; left:0px; top:0px;}\n        } \n```\n\n## <span id='9'>多列</span>\n\n> 可以将文本内容设计成像报纸一样的多列布局\n\n* column-count 属性规定元素应该被分隔的列数  (column-count:3)\n* column-gap 属性规定列之间的间隔 (column-gap:30px)\n* column-rule 属性设置列之间的宽度、样式和颜色规则  (column-rule:4px outset #ff0000)\n* column-width 属性规定列的宽度  (column-width: auto(浏览器决定 没有效果) / 100px)\n* column-span 属性规定元素应横跨多少列  (column-span: 1 / all)\n* columns 属性是一个简写属性，用于设置列宽和列数   (columns:100px(4) 3(1);)\n\n```\n    <div id=\"div\">\n        <h2>英国维斯米斯特教堂碑文</h2>\n        当我年轻的时候，我梦想改变这个世界；当我成熟以后，我发现我不能够改变这个世界，我将目光缩短了些，决定只改变我的国家；当我进入暮年以后，我发现我不能够改变我们的国家，我的最后愿望仅仅是改变一下我的家庭，但是，这也不可能。当我现在躺在床上，行将就木时，我突然意识到：如果一开始我仅仅去改变我自己，然后，我可能改变我的家庭；在家人的帮助和鼓励下，我可能为国家做一些事情；然后，谁知道呢?我甚至可能改变这个世界。\n    </div>\n    #div \n        {\n            column-count: 3;\n            column-gap:90px;\n            column-rule:4px outset #ff0000;\n            //column-rule:4px dotted #ff0000;\n            column-span: all;\n            column-width:100px;\n            //column-span: 1; // 默认\n            //columns:100px 3;\n        }\n        h2\n        {\n            column-span:1;\n            -webkit-column-span:1; /* Safari and Chrome */\n        }\n```\n\n## <span id=\"10\">用户界面</span> \n\n* 调整尺寸(Resizing)\n\n```\n    <div id='div'>调整属性指定一个元素是否由用户可调整大小的</div>\n    #div\n        {\n            border:2px solid;\n            padding:10px 40px; \n            width:300px;\n            resize:both;\n            overflow:auto;\n        }\n```\n* 外形修饰（outline-offset ）\n\n```\n    <div id='div'>\n        这个 div有一个轮廓边界15 px边境外的边缘。Internet Explorer 不兼容 outline-offset属性.\n    </div>\n    #div\n        {\n            margin:20px;\n            width:150px; \n            padding:10px;\n            height:70px;\n            border:2px solid black;\n            outline:2px solid red;\n            outline-offset:15px;\n        }\n```\n\n##  <span id=\"11\">弹性盒</span> \n\n> 弹性盒子是 CSS3 的一种新的布局模式。CSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间\n\n* 弹性盒子 = 弹性容器(Flex container) + 弹性子元素(Flex item)\n* 弹性容器设置 display 属性的值为 flex 或 inline-flex将其定义为弹性容器(弹性容器上)\n* direction: rtl (right-to-left) 修改弹性子元素的排列方式也会改变，页面布局也跟着改变 (弹性容器上)\n* flex-direction 顺序指定了弹性子元素在父容器中的位置 (flex-direction: row | row-reverse | column | column-reverse)(弹性容器上)\n    * row：横向从左到右排列（左对齐），默认\n    * row-reverse：反转横向排列（右对齐，从后往前排，最后一项排在最前面\n    * column：纵向排列\n    * column-reverse：反转纵向排列，从后往前排，最后一项排在最上面\n* justify-content(内容对齐): flex-start | flex-end | center | space-between | space-around (弹性容器上)\n* align-items(设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式): flex-start | flex-end | center | baseline | stretch(弹性容器上)\n* flex-wrap(用于指定弹性盒子的子元素换行方式): nowrap|wrap|wrap-reverse|initial|inherit; (弹性容器上)\n    * nowrap - 默认， 弹性容器为单行。该情况下弹性子项可能会溢出容器。\n    * wrap - 弹性容器为多行。该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行\n    * wrap-reverse -反转 wrap 排列\n* align-content(用于修改 flex-wrap 属性的行为): flex-start | flex-end | center | space-between | space-around | stretch, 类似于 align-items, 但它不是设置弹性子元素的对齐，而是设置各个行的对齐 (弹性容器上)\n    * stretch - 默认。各行将会伸展以占用剩余的空间。\n    * flex-start - 各行向弹性盒容器的起始位置堆叠。\n    * flex-end - 各行向弹性盒容器的结束位置堆叠。\n    * center -各行向弹性盒容器的中间位置堆叠。\n    * space-between -各行在弹性盒容器中平均分布。\n    * space-around - 各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。 \n\n### 弹性子元素属性\n\n* order 属性设置弹性容器内弹性子元素的属性\n* align-self (在弹性子元素上使用。覆盖容器的 align-items 属性): auto | flex-start | flex-end | center | baseline | stretch\n* flex (设置弹性盒子的子元素如何分配空间): auto | initial | none | inherit |  [ flex-grow ] || [ flex-shrink ] || [ flex-basis ]\n\n```\n    <div class=\"flex-container\">\n        <div class=\"flex-item\">flex item 1</div>\n        <div class=\"flex-item\">flex item 2</div>\n        <div class=\"flex-item\">flex item 3</div>\n        <div class=\"flex-item\">flex item 4</div>  \n    </div>\n\n    .flex-container {\n        display: -webkit-flex;\n        display: flex;\n        width: 400px;\n        height: 250px;\n        background-color: lightgrey;\n        //direction: rtl;\n        //flex-direction: row;\n        //flex-direction: row-reverse;\n        //flex-direction: column;\n        //flex-direction: column-reverse;\n        //justify-content: flex-start;\n        //justify-content: flex-end;\n        //justify-content: center;\n        //justify-content: space-between;\n        //justify-content: space-around;\n        //flex-wrap: nowrap;\n        //flex-wrap: wrap;\n        //flex-wrap: wrap-reverse;\n    }\n\n    .flex-item {\n        background-color: cornflowerblue;\n        width: 15%;\n        height: 100px;\n        margin: 10px;\n    }\n```\n","slug":"css/css3","published":1,"updated":"2017-10-23T00:56:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaqhv1gc0004btx1mmo49hst","content":"<ul>\n<li><a href=\"#0\">calc()使用</a></li>\n<li><a href=\"#1\">边框</a></li>\n<li><a href=\"#2\">背景</a></li>\n<li><a href=\"#3\">渐变</a></li>\n<li><a href=\"#4\">文本效果</a></li>\n<li><a href=\"#5\">2D转换</a></li>\n<li><a href=\"#6\">3D转换</a></li>\n<li><a href=\"#7\">过渡</a></li>\n<li><a href=\"#8\">动画</a></li>\n<li><a href=\"#9\">多列</a></li>\n<li><a href=\"#10\">用户界面</a></li>\n<li><a href=\"#11\">弹性盒</a></li>\n</ul>\n<h2 id=\"calc-使用\"><a href=\"#calc-使用\" class=\"headerlink\" title=\"calc()使用\"></a><span id=\"0\"><a href=\"http://www.w3cplus.com/css3/how-to-use-css3-calc-function.html\" target=\"_blank\" rel=\"noopener\">calc()使用</a></span></h2><blockquote>\n<p>能实现自适应的布局 box-sizing, 浏览器对calc()的兼容性还算不错，在IE9+、FF4.0+、Chrome19+、Safari6+都得到较好支持著作权归作者所有。不过calc()最大的好处就是用在流体布局上(百分比)，可以通过calc()计算得到元素的宽度高度<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#div&#123;</span><br><span class=\"line\">    float: left;</span><br><span class=\"line\">    width: 50%;</span><br><span class=\"line\">    width:calc(50% - 2px - 80px);</span><br><span class=\"line\">    height: 100px;</span><br><span class=\"line\">    background: red;</span><br><span class=\"line\">    border: thin solid;</span><br><span class=\"line\">    padding: 40px;</span><br><span class=\"line\">    //box-sizing: border-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"边框\"><a href=\"#边框\" class=\"headerlink\" title=\"边框\"></a><span id=\"1\">边框</span></h2><blockquote>\n<p>用 CSS3，你可以创建圆角边框，添加阴影框，并作为边界的形象而不使用设计程序</p>\n</blockquote>\n<ul>\n<li><p>border-radius (圆角)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&apos;div&apos;&gt;&lt;/div&gt;</span><br><span class=\"line\">#div</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    border:2px solid;</span><br><span class=\"line\">    border-radius:25px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>box-shadow  (盒阴影)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#div</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        width: 200px;</span><br><span class=\"line\">        height: 200px;</span><br><span class=\"line\">        box-shadow: 20px 20px 20px 0 gold inset;</span><br><span class=\"line\">        box-shadow: 10px 10px 5px #888888;</span><br><span class=\"line\">        background: red;</span><br><span class=\"line\">        margin: 50px;</span><br><span class=\"line\">        // box-shadow: 10px(向右偏移,可取负数,必填) </span><br><span class=\"line\">                       10px(向下偏移,可取负数,必填) </span><br><span class=\"line\">                       20px(模糊距离,可选)</span><br><span class=\"line\">                       5px(阴影尺寸 可选)                                      </span><br><span class=\"line\">                       #888888(颜色,可选 默认黑色)</span><br><span class=\"line\">                       inset(内阴影,可选);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"http://www.runoob.com/cssref/css3-pr-border-image.html\" target=\"_blank\" rel=\"noopener\">border-image</a>  (边界图片) …Internet Explorer 不支持</p>\n<pre><code>border-image:   source(图片路径) \n                slice(图像边界向内偏移) \n                width(图像边界的宽度) \n                outset(用于指定在边框外部绘制 border-image-area 的量) \n                repeat|initial|inherit(用于设置图像边界是否应重复（repeat）、拉伸（stretch）或铺满（round）);\n</code></pre><p>  默认border-image: none 100% 1 0 stretch</p>\n</li>\n</ul>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a><span id=\"2\">背景</span></h2><ul>\n<li>background-size: 100% 100%(200px 200px)注:(写成px的时候不包含padding 加box-sizing: border-box 一样)   (规定背景的绘制区域)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#div &#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    padding: 20px;</span><br><span class=\"line\">    background: #ccc url(&apos;http://pic10.nipic.com/20101014/5888301_112136782000_2.jpg&apos;) no-repeat;</span><br><span class=\"line\">    background-size: 100% 100%;</span><br><span class=\"line\">    box-sizing: border-box;</span><br><span class=\"line\">    /* background-size: 240px 240px; *</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>background-origin  (content-box(只填充内容区域)、padding-box(包含padding) 或 border-box(包含边框) ) =&gt;  相对于背景图片(背景色完全没有作用  规定背景图片的定位区域)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#div &#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    padding: 20px;</span><br><span class=\"line\">    border: 10px dotted red;</span><br><span class=\"line\">    background: #ccc url(&apos;http://pic10.nipic.com/20101014/5888301_112136782000_2.jpg&apos;) no-repeat;</span><br><span class=\"line\">    background-size: 100% 100%;</span><br><span class=\"line\">    background-origin: content-box;</span><br><span class=\"line\">    //background-origin: padding-box;</span><br><span class=\"line\">    //background-origin: border-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>background-clip (content-box(只填充内容区域)、padding-box(包含padding) 或 border-box(包含边框) )=&gt;相对于背景色(对图片的padding content 有作用  对border-box无用(默认就是))  (规定背景图片的尺寸)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#div &#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    padding: 20px;</span><br><span class=\"line\">    background:  url(&apos;http://pic10.nipic.com/20101014/5888301_112136782000_2.jpg&apos;) no-repeat;</span><br><span class=\"line\">    background-size: 100% 100%;</span><br><span class=\"line\">    background-color: green;</span><br><span class=\"line\">    background-clip: border-box;</span><br><span class=\"line\">    /* background-origin: border-box; */</span><br><span class=\"line\">    border: 10px dashed red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>background-origin与background-clip区别</li>\n</ul>\n<ol>\n<li>background-origin只作用于背景图片,对背景色无用, background-clip即可作用于背景图片,也可作用于背景色</li>\n<li>当两者都作用于背景图片时, 不同于border-box 属性,background-origin边框在图片上面, 并且填充了边框,  background-clip 没有填充边框</li>\n</ol>\n<h2 id=\"渐变-线性渐变-径向渐变\"><a href=\"#渐变-线性渐变-径向渐变\" class=\"headerlink\" title=\"渐变 (线性渐变) (径向渐变)\"></a><span id=\"3\">渐变 (线性渐变) (径向渐变)</span></h2><blockquote>\n<p>在两个或多个指定的颜色之间显示平稳的过渡,如果你想要在渐变的方向上做更多的控制，你可以定义一个角度(逆时针)，而不用预定义方向（to bottom、to top、to right、to left、to bottom right，等等）</p>\n</blockquote>\n<ul>\n<li>线性渐变 background: linear-gradient(direction(90deg), color-stop1, color-stop2, …);</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#div </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    background: -webkit-linear-gradient(top, red, blue, green);</span><br><span class=\"line\">    //background: -webkit-linear-gradient(left, red, blue, green);</span><br><span class=\"line\">    //background: -webkit-linear-gradient(top left, red, blue, green);</span><br><span class=\"line\">    //background: -webkit-linear-gradient(left bottom, red, blue, green);</span><br><span class=\"line\">    //background: -webkit-repeating-linear-gradient(top left, red, blue 10%,green 30%);//重复渐变</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>径向渐变 background: radial-gradient(center, shape(ellipse/circle) size, start-color, …, last-color);</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#div</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        width: 200px;</span><br><span class=\"line\">        height: 200px;</span><br><span class=\"line\">        background: -webkit-radial-gradient(red, green, blue);</span><br><span class=\"line\">        //background: -webkit-radial-gradient(red 5%, green 15%, blue 60%);</span><br><span class=\"line\">        //background: -webkit-repeating-radial-gradient(red, green 10%, blue 15%);//重复渐变</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"文本效果\"><a href=\"#文本效果\" class=\"headerlink\" title=\"文本效果\"></a><span id=\"4\">文本效果</span></h2><ul>\n<li><p>text-shadow: 5px(水平阴影)   5px(垂直阴影)   10px(模糊距离)   green;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#div</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        width: 200px;</span><br><span class=\"line\">        height: 200px;</span><br><span class=\"line\">        text-shadow: 5px 5px 5px #FF0000;</span><br><span class=\"line\">        font-size: 40px;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>word-wrap:break-word(自动换行)   文字超出会自动换行    字母 数字 标点符号不换  (ps不兼容 Opera)</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#div</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       width: 200px;</span><br><span class=\"line\">       height: 200px;</span><br><span class=\"line\">       text-shadow: 5px 5px 5px #FF0000;</span><br><span class=\"line\">       font-size: 40px;</span><br><span class=\"line\">       border: 2px solid red;</span><br><span class=\"line\">       word-wrap:break-word;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2D转换\"><a href=\"#2D转换\" class=\"headerlink\" title=\"2D转换\"></a><span id=\"5\">2D转换</span></h2><blockquote>\n<p>可以移动，比例化，反过来，旋转，和拉伸元素。<br> transform  (IE10 ff  Opera 支持. IE9(-ms-)和Chrome Safari(-webkit-) 要加前缀)</p>\n</blockquote>\n<ul>\n<li>transform: translate(50px, 50px) (translateX/Y)    (上下 作用偏移,以元素中心点为中心偏移,设置transform-origin属性无用)</li>\n<li>transform: rotate(90deg) rotate(X/Y)               (旋转,以中心为原点旋转,可改变中心点)</li>\n<li>transform: scale(2,2) (scaleX/Y)                   (元素尺寸增加或减少倍数,中心点旋转,可改变中心点)</li>\n<li>transform: skew(10deg,0deg) (skewX/Y)              (元素翻转 x y,中心点旋转,可改变中心点)</li>\n<li>transform:matrix(0.866,0.5,-0.5,0.866,0,0)         (matrix()方法,六个参数，包含旋转，缩放，移动（平移）和倾斜功能)</li>\n<li>transform-origin:0 0;                              (允许改变被转换元素的位置,默认元素中心点)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    background: red;</span><br><span class=\"line\">    //transform:translate(200px,200px);</span><br><span class=\"line\">    //transform: rotate(30deg);</span><br><span class=\"line\">    //transform-origin:0 0;</span><br><span class=\"line\">    //transform: skew(30deg,20deg);</span><br><span class=\"line\">    transform: scale(2,2)</span><br><span class=\"line\">    //transform:matrix(0.866,0.5,-0.5,0.866,0,0);</span><br><span class=\"line\">    margin: 100px auto;</span><br><span class=\"line\">    transform-origin:0 0;</span><br><span class=\"line\">    //animation:myfirst 5s linear 2s infinite alternate;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@keyframes myfirst</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    from &#123;transform: scale(1,1)&#125;</span><br><span class=\"line\">    to &#123;transform: scale(2,2)&#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3D转换\"><a href=\"#3D转换\" class=\"headerlink\" title=\"3D转换\"></a><span id=\"6\">3D转换</span></h2><blockquote>\n<p>方法 同2D 只是多了Z轴  rotate可以规定X Y Z (transform: rotateX/Y/Z(30deg))</p>\n</blockquote>\n<ul>\n<li>transform: translate3d(x,y,z)</li>\n<li>transform: scale3d(x,y,z)</li>\n<li>transform: rotate3d(x,y,z,angle)</li>\n<li>perspective: 500 (设置从何处查看一个元素的角度,perspective 属性只影响 3D 转换元素)</li>\n<li>perspective-origin: 10% 10% (设置一个3D元素的基数位置)</li>\n<li>transform-style: preserve-3d (让转换的子元素保留3D转换)</li>\n</ul>\n<h2 id=\"过渡\"><a href=\"#过渡\" class=\"headerlink\" title=\"过渡\"></a><span id=\"7\">过渡</span></h2><blockquote>\n<p>为了添加某种效果可以从一种样式转变到另一个的时候，无需使用Flash动画或JavaScript</p>\n</blockquote>\n<ul>\n<li>transition 属性是一个简写属性，用于设置四个过渡属性  (默认all 0 ease 0) (给运动元素加此属性,hover时加要变的属性)</li>\n<li>transition-property (哪个属性变)</li>\n<li>transition-duration (完成这个效果的时间  必须设置 否则默认为0)</li>\n<li>transition-timing-function (<a href=\"http://www.runoob.com/cssref/css3-pr-transition-timing-function.html\" target=\"_blank\" rel=\"noopener\">规定速度效果的速度曲线</a>   linear|ease|ease-in|ease-out|ease-in-out)</li>\n<li>transition-delay (效果延时多少开始)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#div</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        width:100px;</span><br><span class=\"line\">        height:100px;</span><br><span class=\"line\">        background:red;</span><br><span class=\"line\">        transition:width 2s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#div:hover</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        width:300px;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a><span id=\"8\">动画</span></h2><ul>\n<li>@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果</li>\n<li>先定义动画,然后在动画元素属性里面调用,(animation: 动画名  运动的时间 <a href=\"http://www.runoob.com/cssref/css3-pr-animation-timing-function.html\" target=\"_blank\" rel=\"noopener\">速度曲线</a> 延时多少开始 运动次数(infinite 无数次)  反向播放动画 )</li>\n<li>animation:myfirst 5s linear 2s infinite alternate;</li>\n<li>animation-play-state:running/paused (属性规定动画正在运行还是暂停 js中使用 可以控制动画暂停与播放)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#div </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        width: 100px;</span><br><span class=\"line\">        height: 100px;</span><br><span class=\"line\">        position:relative;</span><br><span class=\"line\">        animation:myfirst 5s linear 2s infinite alternate;</span><br><span class=\"line\">        //animation-play-state:paused;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">@keyframes myfirst</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        0%   &#123;background:red; left:0px; top:0px;&#125;</span><br><span class=\"line\">        25%  &#123;background:yellow; left:200px; top:0px;&#125;</span><br><span class=\"line\">        50%  &#123;background:blue; left:200px; top:200px;&#125;</span><br><span class=\"line\">        75%  &#123;background:green; left:0px; top:200px;&#125;</span><br><span class=\"line\">        100% &#123;background:red; left:0px; top:0px;&#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"多列\"><a href=\"#多列\" class=\"headerlink\" title=\"多列\"></a><span id=\"9\">多列</span></h2><blockquote>\n<p>可以将文本内容设计成像报纸一样的多列布局</p>\n</blockquote>\n<ul>\n<li>column-count 属性规定元素应该被分隔的列数  (column-count:3)</li>\n<li>column-gap 属性规定列之间的间隔 (column-gap:30px)</li>\n<li>column-rule 属性设置列之间的宽度、样式和颜色规则  (column-rule:4px outset #ff0000)</li>\n<li>column-width 属性规定列的宽度  (column-width: auto(浏览器决定 没有效果) / 100px)</li>\n<li>column-span 属性规定元素应横跨多少列  (column-span: 1 / all)</li>\n<li>columns 属性是一个简写属性，用于设置列宽和列数   (columns:100px(4) 3(1);)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;div&quot;&gt;</span><br><span class=\"line\">    &lt;h2&gt;英国维斯米斯特教堂碑文&lt;/h2&gt;</span><br><span class=\"line\">    当我年轻的时候，我梦想改变这个世界；当我成熟以后，我发现我不能够改变这个世界，我将目光缩短了些，决定只改变我的国家；当我进入暮年以后，我发现我不能够改变我们的国家，我的最后愿望仅仅是改变一下我的家庭，但是，这也不可能。当我现在躺在床上，行将就木时，我突然意识到：如果一开始我仅仅去改变我自己，然后，我可能改变我的家庭；在家人的帮助和鼓励下，我可能为国家做一些事情；然后，谁知道呢?我甚至可能改变这个世界。</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">#div </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        column-count: 3;</span><br><span class=\"line\">        column-gap:90px;</span><br><span class=\"line\">        column-rule:4px outset #ff0000;</span><br><span class=\"line\">        //column-rule:4px dotted #ff0000;</span><br><span class=\"line\">        column-span: all;</span><br><span class=\"line\">        column-width:100px;</span><br><span class=\"line\">        //column-span: 1; // 默认</span><br><span class=\"line\">        //columns:100px 3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    h2</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        column-span:1;</span><br><span class=\"line\">        -webkit-column-span:1; /* Safari and Chrome */</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"用户界面\"><a href=\"#用户界面\" class=\"headerlink\" title=\"用户界面\"></a><span id=\"10\">用户界面</span></h2><ul>\n<li>调整尺寸(Resizing)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&apos;div&apos;&gt;调整属性指定一个元素是否由用户可调整大小的&lt;/div&gt;</span><br><span class=\"line\">#div</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        border:2px solid;</span><br><span class=\"line\">        padding:10px 40px; </span><br><span class=\"line\">        width:300px;</span><br><span class=\"line\">        resize:both;</span><br><span class=\"line\">        overflow:auto;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>外形修饰（outline-offset ）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&apos;div&apos;&gt;</span><br><span class=\"line\">    这个 div有一个轮廓边界15 px边境外的边缘。Internet Explorer 不兼容 outline-offset属性.</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">#div</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        margin:20px;</span><br><span class=\"line\">        width:150px; </span><br><span class=\"line\">        padding:10px;</span><br><span class=\"line\">        height:70px;</span><br><span class=\"line\">        border:2px solid black;</span><br><span class=\"line\">        outline:2px solid red;</span><br><span class=\"line\">        outline-offset:15px;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"弹性盒\"><a href=\"#弹性盒\" class=\"headerlink\" title=\"弹性盒\"></a><span id=\"11\">弹性盒</span></h2><blockquote>\n<p>弹性盒子是 CSS3 的一种新的布局模式。CSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间</p>\n</blockquote>\n<ul>\n<li>弹性盒子 = 弹性容器(Flex container) + 弹性子元素(Flex item)</li>\n<li>弹性容器设置 display 属性的值为 flex 或 inline-flex将其定义为弹性容器(弹性容器上)</li>\n<li>direction: rtl (right-to-left) 修改弹性子元素的排列方式也会改变，页面布局也跟着改变 (弹性容器上)</li>\n<li>flex-direction 顺序指定了弹性子元素在父容器中的位置 (flex-direction: row | row-reverse | column | column-reverse)(弹性容器上)<ul>\n<li>row：横向从左到右排列（左对齐），默认</li>\n<li>row-reverse：反转横向排列（右对齐，从后往前排，最后一项排在最前面</li>\n<li>column：纵向排列</li>\n<li>column-reverse：反转纵向排列，从后往前排，最后一项排在最上面</li>\n</ul>\n</li>\n<li>justify-content(内容对齐): flex-start | flex-end | center | space-between | space-around (弹性容器上)</li>\n<li>align-items(设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式): flex-start | flex-end | center | baseline | stretch(弹性容器上)</li>\n<li>flex-wrap(用于指定弹性盒子的子元素换行方式): nowrap|wrap|wrap-reverse|initial|inherit; (弹性容器上)<ul>\n<li>nowrap - 默认， 弹性容器为单行。该情况下弹性子项可能会溢出容器。</li>\n<li>wrap - 弹性容器为多行。该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行</li>\n<li>wrap-reverse -反转 wrap 排列</li>\n</ul>\n</li>\n<li>align-content(用于修改 flex-wrap 属性的行为): flex-start | flex-end | center | space-between | space-around | stretch, 类似于 align-items, 但它不是设置弹性子元素的对齐，而是设置各个行的对齐 (弹性容器上)<ul>\n<li>stretch - 默认。各行将会伸展以占用剩余的空间。</li>\n<li>flex-start - 各行向弹性盒容器的起始位置堆叠。</li>\n<li>flex-end - 各行向弹性盒容器的结束位置堆叠。</li>\n<li>center -各行向弹性盒容器的中间位置堆叠。</li>\n<li>space-between -各行在弹性盒容器中平均分布。</li>\n<li>space-around - 各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"弹性子元素属性\"><a href=\"#弹性子元素属性\" class=\"headerlink\" title=\"弹性子元素属性\"></a>弹性子元素属性</h3><ul>\n<li>order 属性设置弹性容器内弹性子元素的属性</li>\n<li>align-self (在弹性子元素上使用。覆盖容器的 align-items 属性): auto | flex-start | flex-end | center | baseline | stretch</li>\n<li>flex (设置弹性盒子的子元素如何分配空间): auto | initial | none | inherit |  [ flex-grow ] || [ flex-shrink ] || [ flex-basis ]</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;flex-container&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;flex-item&quot;&gt;flex item 1&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;flex-item&quot;&gt;flex item 2&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;flex-item&quot;&gt;flex item 3&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;flex-item&quot;&gt;flex item 4&lt;/div&gt;  </span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">.flex-container &#123;</span><br><span class=\"line\">    display: -webkit-flex;</span><br><span class=\"line\">    display: flex;</span><br><span class=\"line\">    width: 400px;</span><br><span class=\"line\">    height: 250px;</span><br><span class=\"line\">    background-color: lightgrey;</span><br><span class=\"line\">    //direction: rtl;</span><br><span class=\"line\">    //flex-direction: row;</span><br><span class=\"line\">    //flex-direction: row-reverse;</span><br><span class=\"line\">    //flex-direction: column;</span><br><span class=\"line\">    //flex-direction: column-reverse;</span><br><span class=\"line\">    //justify-content: flex-start;</span><br><span class=\"line\">    //justify-content: flex-end;</span><br><span class=\"line\">    //justify-content: center;</span><br><span class=\"line\">    //justify-content: space-between;</span><br><span class=\"line\">    //justify-content: space-around;</span><br><span class=\"line\">    //flex-wrap: nowrap;</span><br><span class=\"line\">    //flex-wrap: wrap;</span><br><span class=\"line\">    //flex-wrap: wrap-reverse;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.flex-item &#123;</span><br><span class=\"line\">    background-color: cornflowerblue;</span><br><span class=\"line\">    width: 15%;</span><br><span class=\"line\">    height: 100px;</span><br><span class=\"line\">    margin: 10px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<ul>\n<li><a href=\"#0\">calc()使用</a></li>\n<li><a href=\"#1\">边框</a></li>\n<li><a href=\"#2\">背景</a></li>\n<li><a href=\"#3\">渐变</a></li>\n<li><a href=\"#4\">文本效果</a></li>\n<li><a href=\"#5\">2D转换</a></li>\n<li><a href=\"#6\">3D转换</a></li>\n<li><a href=\"#7\">过渡</a></li>\n<li><a href=\"#8\">动画</a></li>\n<li><a href=\"#9\">多列</a></li>\n<li><a href=\"#10\">用户界面</a></li>\n<li><a href=\"#11\">弹性盒</a></li>\n</ul>\n<h2 id=\"calc-使用\"><a href=\"#calc-使用\" class=\"headerlink\" title=\"calc()使用\"></a><span id=\"0\"><a href=\"http://www.w3cplus.com/css3/how-to-use-css3-calc-function.html\" target=\"_blank\" rel=\"noopener\">calc()使用</a></span></h2><blockquote>\n<p>能实现自适应的布局 box-sizing, 浏览器对calc()的兼容性还算不错，在IE9+、FF4.0+、Chrome19+、Safari6+都得到较好支持著作权归作者所有。不过calc()最大的好处就是用在流体布局上(百分比)，可以通过calc()计算得到元素的宽度高度<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#div&#123;</span><br><span class=\"line\">    float: left;</span><br><span class=\"line\">    width: 50%;</span><br><span class=\"line\">    width:calc(50% - 2px - 80px);</span><br><span class=\"line\">    height: 100px;</span><br><span class=\"line\">    background: red;</span><br><span class=\"line\">    border: thin solid;</span><br><span class=\"line\">    padding: 40px;</span><br><span class=\"line\">    //box-sizing: border-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"边框\"><a href=\"#边框\" class=\"headerlink\" title=\"边框\"></a><span id=\"1\">边框</span></h2><blockquote>\n<p>用 CSS3，你可以创建圆角边框，添加阴影框，并作为边界的形象而不使用设计程序</p>\n</blockquote>\n<ul>\n<li><p>border-radius (圆角)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&apos;div&apos;&gt;&lt;/div&gt;</span><br><span class=\"line\">#div</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    border:2px solid;</span><br><span class=\"line\">    border-radius:25px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>box-shadow  (盒阴影)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#div</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        width: 200px;</span><br><span class=\"line\">        height: 200px;</span><br><span class=\"line\">        box-shadow: 20px 20px 20px 0 gold inset;</span><br><span class=\"line\">        box-shadow: 10px 10px 5px #888888;</span><br><span class=\"line\">        background: red;</span><br><span class=\"line\">        margin: 50px;</span><br><span class=\"line\">        // box-shadow: 10px(向右偏移,可取负数,必填) </span><br><span class=\"line\">                       10px(向下偏移,可取负数,必填) </span><br><span class=\"line\">                       20px(模糊距离,可选)</span><br><span class=\"line\">                       5px(阴影尺寸 可选)                                      </span><br><span class=\"line\">                       #888888(颜色,可选 默认黑色)</span><br><span class=\"line\">                       inset(内阴影,可选);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"http://www.runoob.com/cssref/css3-pr-border-image.html\" target=\"_blank\" rel=\"noopener\">border-image</a>  (边界图片) …Internet Explorer 不支持</p>\n<pre><code>border-image:   source(图片路径) \n                slice(图像边界向内偏移) \n                width(图像边界的宽度) \n                outset(用于指定在边框外部绘制 border-image-area 的量) \n                repeat|initial|inherit(用于设置图像边界是否应重复（repeat）、拉伸（stretch）或铺满（round）);\n</code></pre><p>  默认border-image: none 100% 1 0 stretch</p>\n</li>\n</ul>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a><span id=\"2\">背景</span></h2><ul>\n<li>background-size: 100% 100%(200px 200px)注:(写成px的时候不包含padding 加box-sizing: border-box 一样)   (规定背景的绘制区域)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#div &#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    padding: 20px;</span><br><span class=\"line\">    background: #ccc url(&apos;http://pic10.nipic.com/20101014/5888301_112136782000_2.jpg&apos;) no-repeat;</span><br><span class=\"line\">    background-size: 100% 100%;</span><br><span class=\"line\">    box-sizing: border-box;</span><br><span class=\"line\">    /* background-size: 240px 240px; *</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>background-origin  (content-box(只填充内容区域)、padding-box(包含padding) 或 border-box(包含边框) ) =&gt;  相对于背景图片(背景色完全没有作用  规定背景图片的定位区域)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#div &#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    padding: 20px;</span><br><span class=\"line\">    border: 10px dotted red;</span><br><span class=\"line\">    background: #ccc url(&apos;http://pic10.nipic.com/20101014/5888301_112136782000_2.jpg&apos;) no-repeat;</span><br><span class=\"line\">    background-size: 100% 100%;</span><br><span class=\"line\">    background-origin: content-box;</span><br><span class=\"line\">    //background-origin: padding-box;</span><br><span class=\"line\">    //background-origin: border-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>background-clip (content-box(只填充内容区域)、padding-box(包含padding) 或 border-box(包含边框) )=&gt;相对于背景色(对图片的padding content 有作用  对border-box无用(默认就是))  (规定背景图片的尺寸)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#div &#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    padding: 20px;</span><br><span class=\"line\">    background:  url(&apos;http://pic10.nipic.com/20101014/5888301_112136782000_2.jpg&apos;) no-repeat;</span><br><span class=\"line\">    background-size: 100% 100%;</span><br><span class=\"line\">    background-color: green;</span><br><span class=\"line\">    background-clip: border-box;</span><br><span class=\"line\">    /* background-origin: border-box; */</span><br><span class=\"line\">    border: 10px dashed red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>background-origin与background-clip区别</li>\n</ul>\n<ol>\n<li>background-origin只作用于背景图片,对背景色无用, background-clip即可作用于背景图片,也可作用于背景色</li>\n<li>当两者都作用于背景图片时, 不同于border-box 属性,background-origin边框在图片上面, 并且填充了边框,  background-clip 没有填充边框</li>\n</ol>\n<h2 id=\"渐变-线性渐变-径向渐变\"><a href=\"#渐变-线性渐变-径向渐变\" class=\"headerlink\" title=\"渐变 (线性渐变) (径向渐变)\"></a><span id=\"3\">渐变 (线性渐变) (径向渐变)</span></h2><blockquote>\n<p>在两个或多个指定的颜色之间显示平稳的过渡,如果你想要在渐变的方向上做更多的控制，你可以定义一个角度(逆时针)，而不用预定义方向（to bottom、to top、to right、to left、to bottom right，等等）</p>\n</blockquote>\n<ul>\n<li>线性渐变 background: linear-gradient(direction(90deg), color-stop1, color-stop2, …);</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#div </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    background: -webkit-linear-gradient(top, red, blue, green);</span><br><span class=\"line\">    //background: -webkit-linear-gradient(left, red, blue, green);</span><br><span class=\"line\">    //background: -webkit-linear-gradient(top left, red, blue, green);</span><br><span class=\"line\">    //background: -webkit-linear-gradient(left bottom, red, blue, green);</span><br><span class=\"line\">    //background: -webkit-repeating-linear-gradient(top left, red, blue 10%,green 30%);//重复渐变</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>径向渐变 background: radial-gradient(center, shape(ellipse/circle) size, start-color, …, last-color);</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#div</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        width: 200px;</span><br><span class=\"line\">        height: 200px;</span><br><span class=\"line\">        background: -webkit-radial-gradient(red, green, blue);</span><br><span class=\"line\">        //background: -webkit-radial-gradient(red 5%, green 15%, blue 60%);</span><br><span class=\"line\">        //background: -webkit-repeating-radial-gradient(red, green 10%, blue 15%);//重复渐变</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"文本效果\"><a href=\"#文本效果\" class=\"headerlink\" title=\"文本效果\"></a><span id=\"4\">文本效果</span></h2><ul>\n<li><p>text-shadow: 5px(水平阴影)   5px(垂直阴影)   10px(模糊距离)   green;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#div</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        width: 200px;</span><br><span class=\"line\">        height: 200px;</span><br><span class=\"line\">        text-shadow: 5px 5px 5px #FF0000;</span><br><span class=\"line\">        font-size: 40px;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>word-wrap:break-word(自动换行)   文字超出会自动换行    字母 数字 标点符号不换  (ps不兼容 Opera)</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#div</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       width: 200px;</span><br><span class=\"line\">       height: 200px;</span><br><span class=\"line\">       text-shadow: 5px 5px 5px #FF0000;</span><br><span class=\"line\">       font-size: 40px;</span><br><span class=\"line\">       border: 2px solid red;</span><br><span class=\"line\">       word-wrap:break-word;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2D转换\"><a href=\"#2D转换\" class=\"headerlink\" title=\"2D转换\"></a><span id=\"5\">2D转换</span></h2><blockquote>\n<p>可以移动，比例化，反过来，旋转，和拉伸元素。<br> transform  (IE10 ff  Opera 支持. IE9(-ms-)和Chrome Safari(-webkit-) 要加前缀)</p>\n</blockquote>\n<ul>\n<li>transform: translate(50px, 50px) (translateX/Y)    (上下 作用偏移,以元素中心点为中心偏移,设置transform-origin属性无用)</li>\n<li>transform: rotate(90deg) rotate(X/Y)               (旋转,以中心为原点旋转,可改变中心点)</li>\n<li>transform: scale(2,2) (scaleX/Y)                   (元素尺寸增加或减少倍数,中心点旋转,可改变中心点)</li>\n<li>transform: skew(10deg,0deg) (skewX/Y)              (元素翻转 x y,中心点旋转,可改变中心点)</li>\n<li>transform:matrix(0.866,0.5,-0.5,0.866,0,0)         (matrix()方法,六个参数，包含旋转，缩放，移动（平移）和倾斜功能)</li>\n<li>transform-origin:0 0;                              (允许改变被转换元素的位置,默认元素中心点)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    background: red;</span><br><span class=\"line\">    //transform:translate(200px,200px);</span><br><span class=\"line\">    //transform: rotate(30deg);</span><br><span class=\"line\">    //transform-origin:0 0;</span><br><span class=\"line\">    //transform: skew(30deg,20deg);</span><br><span class=\"line\">    transform: scale(2,2)</span><br><span class=\"line\">    //transform:matrix(0.866,0.5,-0.5,0.866,0,0);</span><br><span class=\"line\">    margin: 100px auto;</span><br><span class=\"line\">    transform-origin:0 0;</span><br><span class=\"line\">    //animation:myfirst 5s linear 2s infinite alternate;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@keyframes myfirst</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    from &#123;transform: scale(1,1)&#125;</span><br><span class=\"line\">    to &#123;transform: scale(2,2)&#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3D转换\"><a href=\"#3D转换\" class=\"headerlink\" title=\"3D转换\"></a><span id=\"6\">3D转换</span></h2><blockquote>\n<p>方法 同2D 只是多了Z轴  rotate可以规定X Y Z (transform: rotateX/Y/Z(30deg))</p>\n</blockquote>\n<ul>\n<li>transform: translate3d(x,y,z)</li>\n<li>transform: scale3d(x,y,z)</li>\n<li>transform: rotate3d(x,y,z,angle)</li>\n<li>perspective: 500 (设置从何处查看一个元素的角度,perspective 属性只影响 3D 转换元素)</li>\n<li>perspective-origin: 10% 10% (设置一个3D元素的基数位置)</li>\n<li>transform-style: preserve-3d (让转换的子元素保留3D转换)</li>\n</ul>\n<h2 id=\"过渡\"><a href=\"#过渡\" class=\"headerlink\" title=\"过渡\"></a><span id=\"7\">过渡</span></h2><blockquote>\n<p>为了添加某种效果可以从一种样式转变到另一个的时候，无需使用Flash动画或JavaScript</p>\n</blockquote>\n<ul>\n<li>transition 属性是一个简写属性，用于设置四个过渡属性  (默认all 0 ease 0) (给运动元素加此属性,hover时加要变的属性)</li>\n<li>transition-property (哪个属性变)</li>\n<li>transition-duration (完成这个效果的时间  必须设置 否则默认为0)</li>\n<li>transition-timing-function (<a href=\"http://www.runoob.com/cssref/css3-pr-transition-timing-function.html\" target=\"_blank\" rel=\"noopener\">规定速度效果的速度曲线</a>   linear|ease|ease-in|ease-out|ease-in-out)</li>\n<li>transition-delay (效果延时多少开始)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#div</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        width:100px;</span><br><span class=\"line\">        height:100px;</span><br><span class=\"line\">        background:red;</span><br><span class=\"line\">        transition:width 2s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#div:hover</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        width:300px;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a><span id=\"8\">动画</span></h2><ul>\n<li>@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果</li>\n<li>先定义动画,然后在动画元素属性里面调用,(animation: 动画名  运动的时间 <a href=\"http://www.runoob.com/cssref/css3-pr-animation-timing-function.html\" target=\"_blank\" rel=\"noopener\">速度曲线</a> 延时多少开始 运动次数(infinite 无数次)  反向播放动画 )</li>\n<li>animation:myfirst 5s linear 2s infinite alternate;</li>\n<li>animation-play-state:running/paused (属性规定动画正在运行还是暂停 js中使用 可以控制动画暂停与播放)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#div </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        width: 100px;</span><br><span class=\"line\">        height: 100px;</span><br><span class=\"line\">        position:relative;</span><br><span class=\"line\">        animation:myfirst 5s linear 2s infinite alternate;</span><br><span class=\"line\">        //animation-play-state:paused;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">@keyframes myfirst</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        0%   &#123;background:red; left:0px; top:0px;&#125;</span><br><span class=\"line\">        25%  &#123;background:yellow; left:200px; top:0px;&#125;</span><br><span class=\"line\">        50%  &#123;background:blue; left:200px; top:200px;&#125;</span><br><span class=\"line\">        75%  &#123;background:green; left:0px; top:200px;&#125;</span><br><span class=\"line\">        100% &#123;background:red; left:0px; top:0px;&#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"多列\"><a href=\"#多列\" class=\"headerlink\" title=\"多列\"></a><span id=\"9\">多列</span></h2><blockquote>\n<p>可以将文本内容设计成像报纸一样的多列布局</p>\n</blockquote>\n<ul>\n<li>column-count 属性规定元素应该被分隔的列数  (column-count:3)</li>\n<li>column-gap 属性规定列之间的间隔 (column-gap:30px)</li>\n<li>column-rule 属性设置列之间的宽度、样式和颜色规则  (column-rule:4px outset #ff0000)</li>\n<li>column-width 属性规定列的宽度  (column-width: auto(浏览器决定 没有效果) / 100px)</li>\n<li>column-span 属性规定元素应横跨多少列  (column-span: 1 / all)</li>\n<li>columns 属性是一个简写属性，用于设置列宽和列数   (columns:100px(4) 3(1);)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;div&quot;&gt;</span><br><span class=\"line\">    &lt;h2&gt;英国维斯米斯特教堂碑文&lt;/h2&gt;</span><br><span class=\"line\">    当我年轻的时候，我梦想改变这个世界；当我成熟以后，我发现我不能够改变这个世界，我将目光缩短了些，决定只改变我的国家；当我进入暮年以后，我发现我不能够改变我们的国家，我的最后愿望仅仅是改变一下我的家庭，但是，这也不可能。当我现在躺在床上，行将就木时，我突然意识到：如果一开始我仅仅去改变我自己，然后，我可能改变我的家庭；在家人的帮助和鼓励下，我可能为国家做一些事情；然后，谁知道呢?我甚至可能改变这个世界。</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">#div </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        column-count: 3;</span><br><span class=\"line\">        column-gap:90px;</span><br><span class=\"line\">        column-rule:4px outset #ff0000;</span><br><span class=\"line\">        //column-rule:4px dotted #ff0000;</span><br><span class=\"line\">        column-span: all;</span><br><span class=\"line\">        column-width:100px;</span><br><span class=\"line\">        //column-span: 1; // 默认</span><br><span class=\"line\">        //columns:100px 3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    h2</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        column-span:1;</span><br><span class=\"line\">        -webkit-column-span:1; /* Safari and Chrome */</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"用户界面\"><a href=\"#用户界面\" class=\"headerlink\" title=\"用户界面\"></a><span id=\"10\">用户界面</span></h2><ul>\n<li>调整尺寸(Resizing)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&apos;div&apos;&gt;调整属性指定一个元素是否由用户可调整大小的&lt;/div&gt;</span><br><span class=\"line\">#div</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        border:2px solid;</span><br><span class=\"line\">        padding:10px 40px; </span><br><span class=\"line\">        width:300px;</span><br><span class=\"line\">        resize:both;</span><br><span class=\"line\">        overflow:auto;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>外形修饰（outline-offset ）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&apos;div&apos;&gt;</span><br><span class=\"line\">    这个 div有一个轮廓边界15 px边境外的边缘。Internet Explorer 不兼容 outline-offset属性.</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">#div</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        margin:20px;</span><br><span class=\"line\">        width:150px; </span><br><span class=\"line\">        padding:10px;</span><br><span class=\"line\">        height:70px;</span><br><span class=\"line\">        border:2px solid black;</span><br><span class=\"line\">        outline:2px solid red;</span><br><span class=\"line\">        outline-offset:15px;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"弹性盒\"><a href=\"#弹性盒\" class=\"headerlink\" title=\"弹性盒\"></a><span id=\"11\">弹性盒</span></h2><blockquote>\n<p>弹性盒子是 CSS3 的一种新的布局模式。CSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间</p>\n</blockquote>\n<ul>\n<li>弹性盒子 = 弹性容器(Flex container) + 弹性子元素(Flex item)</li>\n<li>弹性容器设置 display 属性的值为 flex 或 inline-flex将其定义为弹性容器(弹性容器上)</li>\n<li>direction: rtl (right-to-left) 修改弹性子元素的排列方式也会改变，页面布局也跟着改变 (弹性容器上)</li>\n<li>flex-direction 顺序指定了弹性子元素在父容器中的位置 (flex-direction: row | row-reverse | column | column-reverse)(弹性容器上)<ul>\n<li>row：横向从左到右排列（左对齐），默认</li>\n<li>row-reverse：反转横向排列（右对齐，从后往前排，最后一项排在最前面</li>\n<li>column：纵向排列</li>\n<li>column-reverse：反转纵向排列，从后往前排，最后一项排在最上面</li>\n</ul>\n</li>\n<li>justify-content(内容对齐): flex-start | flex-end | center | space-between | space-around (弹性容器上)</li>\n<li>align-items(设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式): flex-start | flex-end | center | baseline | stretch(弹性容器上)</li>\n<li>flex-wrap(用于指定弹性盒子的子元素换行方式): nowrap|wrap|wrap-reverse|initial|inherit; (弹性容器上)<ul>\n<li>nowrap - 默认， 弹性容器为单行。该情况下弹性子项可能会溢出容器。</li>\n<li>wrap - 弹性容器为多行。该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行</li>\n<li>wrap-reverse -反转 wrap 排列</li>\n</ul>\n</li>\n<li>align-content(用于修改 flex-wrap 属性的行为): flex-start | flex-end | center | space-between | space-around | stretch, 类似于 align-items, 但它不是设置弹性子元素的对齐，而是设置各个行的对齐 (弹性容器上)<ul>\n<li>stretch - 默认。各行将会伸展以占用剩余的空间。</li>\n<li>flex-start - 各行向弹性盒容器的起始位置堆叠。</li>\n<li>flex-end - 各行向弹性盒容器的结束位置堆叠。</li>\n<li>center -各行向弹性盒容器的中间位置堆叠。</li>\n<li>space-between -各行在弹性盒容器中平均分布。</li>\n<li>space-around - 各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"弹性子元素属性\"><a href=\"#弹性子元素属性\" class=\"headerlink\" title=\"弹性子元素属性\"></a>弹性子元素属性</h3><ul>\n<li>order 属性设置弹性容器内弹性子元素的属性</li>\n<li>align-self (在弹性子元素上使用。覆盖容器的 align-items 属性): auto | flex-start | flex-end | center | baseline | stretch</li>\n<li>flex (设置弹性盒子的子元素如何分配空间): auto | initial | none | inherit |  [ flex-grow ] || [ flex-shrink ] || [ flex-basis ]</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;flex-container&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;flex-item&quot;&gt;flex item 1&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;flex-item&quot;&gt;flex item 2&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;flex-item&quot;&gt;flex item 3&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;flex-item&quot;&gt;flex item 4&lt;/div&gt;  </span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">.flex-container &#123;</span><br><span class=\"line\">    display: -webkit-flex;</span><br><span class=\"line\">    display: flex;</span><br><span class=\"line\">    width: 400px;</span><br><span class=\"line\">    height: 250px;</span><br><span class=\"line\">    background-color: lightgrey;</span><br><span class=\"line\">    //direction: rtl;</span><br><span class=\"line\">    //flex-direction: row;</span><br><span class=\"line\">    //flex-direction: row-reverse;</span><br><span class=\"line\">    //flex-direction: column;</span><br><span class=\"line\">    //flex-direction: column-reverse;</span><br><span class=\"line\">    //justify-content: flex-start;</span><br><span class=\"line\">    //justify-content: flex-end;</span><br><span class=\"line\">    //justify-content: center;</span><br><span class=\"line\">    //justify-content: space-between;</span><br><span class=\"line\">    //justify-content: space-around;</span><br><span class=\"line\">    //flex-wrap: nowrap;</span><br><span class=\"line\">    //flex-wrap: wrap;</span><br><span class=\"line\">    //flex-wrap: wrap-reverse;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.flex-item &#123;</span><br><span class=\"line\">    background-color: cornflowerblue;</span><br><span class=\"line\">    width: 15%;</span><br><span class=\"line\">    height: 100px;</span><br><span class=\"line\">    margin: 10px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"js继承","date":"2017-11-05T13:49:20.000Z","_content":"\n> 每个类都有三个部分组成\n\n* 构造函数内的，供实例对象复制用的\n* 构造函数外的，直接通过点语法添加的，这是供类使用的，实例对象访问不到\n* 类的原型中的，实例化对象可以通过其原型链间接的访问到，也是为供所有实例化对象所共有\n\n<!--- more -->\n\n### 子类的原型继承---类式继承\n\n> 类式继承需要将第一个类的实例赋值给第二个类的原型\n\n```\n// 父类\nfunction SuperClass() {\n    this.SuperValue = true;\n}\n// 为父类原型添加方法\nSuperClass.prototype.getSuperValue = function() {\n    // alert(1)\n    return this.SuperValue;\n}\n// console.dir(SuperClass);\nvar supe = new SuperClass();\n// console.dir(supe);\n// supe.getSuperValue();\n// 声明子类\nfunction SubClass() {\n    this.subValue = false;\n}\n// 子类继承父类\nSubClass.prototype = new SuperClass();\n// 为子类添加共有方法\nSubClass.prototype.getSubValue = function() {\n    // alert(2);\n    return this.subValue;\n}\n// console.dir(SubClass);\n// 子类继承父类SuperValue属性，\n// 访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找，这就是原型链。\nvar sub = new SubClass();\n// sub.getSuperValue();\n// sub.getSubValue();\n// console.log(sub.SuperValue);\n// console.log(sub.subValue);\n// console.dir(sub);\n\n```\n\n> 为什么这样做？？？\n\n类的原型对象的作用就是为类的原型添加共有方法，但是累不能直接访问这些属性和方法，必须通过prototype来访问。\n\n我们在实例化一个父类的时候，新创建的对象复制了父类的构造函数内的属性和方法并且将隐氏原型_proto_指向父类的原型对象，这样就拥有了父类的原型对象上的方法和属性。\n\n如果将新创建的对象赋值给子类的原型，那么子类的原型就可以访问到父类的原型上的属性和方法，同样也可以访问从父类构造函数中复制的属性和方法，同样子类也可以访问父类原型上的属性和方法与父类构造函数中复制的属性和方法。\n\n> 检测继承关系\n\ninstanceof通过判断对象的_proto_与构造函数的prototype，来确定这个对象是否是某个类的实例，而不关心对象与类的自身结构\n\n```\nconsole.log(sub instanceof SubClass);         //true\nconsole.log(sub instanceof SuperClass);       //true\nconsole.log(SubClass instanceof SuperClass);  //false\n\nwhy false??\ninstanceof 是判断前面的对象是否是后面类的实例，他并不表示两者的继承，\nconsole.log(SubClass.prototype instanceof SuperClass); //true\n\n```\n\n> 类式继承的缺点\n\n* 由于子类通过其原型Prototype对父类实例化，继承了父类，所以说父类中的共有属性要是引用类型，就会在子类中被所有属性共有，因此一个子类的实例更改子类原型从父类构造函数中继承来的共有属性就会直接影响到其他子类\n\n```\nfunction SuperClass() {\n    this.books = ['javascript', 'html', 'css']\n    this.a = 12\n}\nfunction SubClass() {}\nSubClass.prototype = new SuperClass()\nvar instance1 = new SubClass()\nvar instance2 = new SubClass()\nconsole.log(instance2.books)\ninstance1.books.push('设计模式')\ninstance1.a = 34\nconsole.log(instance2.books)\nconsole.log(instance2.a)\n```\n* 由于子类实现的继承是靠原型prototype对付类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的，因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化。\n\n### 创建即继承---构造函数继承\n\n```\n// 构造函数继承\n// 声明父类\nfunction SuperClass(id) {\n    this.books = ['javascript', 'html', 'css'];\n    this.id = id;\n}\n// 父类声明原型\nSuperClass.prototype.showBooks = function() {\n    console.log(this.books);\n}\n// 声明子类\nfunction SubClass(id) {\n    // 继承父类\n    SuperClass.call(this, id);\n}\n// 创建第一个子类的实例\nvar instance1 = new SubClass(11);\n// 创建第二个子类的实例\nvar instance2 = new SubClass(22);\n// 验证\ninstance1.books.push('设计模式');\nconsole.log(instance1.books);\nconsole.log(instance2.books);\nconsole.log(instance1.id);\nconsole.log(instance2.id);\n\n```\n> 继承原理\n\n* 由于call这个方法可以更改函数的作用域，因此在子类中，对superClass调用这个方法就是将子类中的变量在父类中执行一遍。\n\n* 由于父类中是=给this绑定属性的，因此子类自然也就继承了父类的共有属性\n\n* 由于这种类型的继承没有涉及原型prototype，所以父类的原型方法自然不会被子类继承\n\n> 每个函数都包含两个非继承而来的方法：call()方法和apply()方法。\n\n* 相同点：这两个方法的作用是一样的。\n\n都是在特定的作用域中调用函数，等于设置函数体内this对象的值，以扩充函数赖以运行的作用域。\n\n一般来说，this总是指向调用某个方法的对象，但是使用call()和apply()方法时，就会改变this的指向。\n\n* 不同点：接收参数的方式不同。\n\napply()方法 接收两个参数，一个是函数运行的作用域（this），另一个是参数数组。\n\n### 将有点为我所用---组合继承 \n\n#### 总结前面两种特点\n\n> 类式继承式通过子类的原型prototype对父类实例化来实现的。\n\n> 构造函数式继承式通过在子类的构造函数作用环境中执行一次父类的构造函数来实现。\n\n```\n// 组合式继承\n// 声明父类\n\nfunction SuperClass(name) {\n    this.name = name;\n    this,boob = ['html', 'css', 'javascript'];\n}\n// 父类原型共有方法\nSuperClass.prototype.getName = function() {\n    console.log(this.name);\n}\n// 声明子类\nfunction SubClass(name, time) {\n    // 构造函数式继承父类name 属性\n    SuperClass.call(this, name);\n    // 子类中新增共有属性\n    this.time = time;\n}\n// 类式继承  子类原型继承父类\nSubClass.prototype = new SuperClass();\n// 子类原型方法\nSubClass.prototype.getTime = function() {\n    console.log(this.time);\n}\n// 测试\nvar instance1 = new SubClass('js book', 2017);\ninstance1.books.push('设计模式');\nconsole.log(instance1.books);\ninstance1.getName();\ninstance1.getTime();\nvar instance2 = new SubClass('css book', 2018);\nconsole.log(instance2.books);\ninstance2.getName();\ninstance2.getTime();\n\n```\n> 结合了类式继承和构造函数继承两种方式的优点\n\n> 不足之处\n\n在使用构造函数继承时执行了一遍父类的构造函数，而在实现子类原型的类式继承式又调用了一遍父类的构造函数。因此父类构造函数调用了两遍。\n\n### 洁净的继承者---原型式继承\n\n```\nfunction inheritObject(o) {\n    // 声明一个过渡函数对象\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\n```\n> 和类式继承有点像？？\n\n对，是对类式继承的一个封装，过渡对象相当于类式继承中的子类，只不过在原型式继承中作为一个过渡对象出现的，目的是为了创建要返回的新的实例化对象。\n\n> ??是不是类式继承中的问题在这里也会出现？？？\n\n是的，！！！，不过这种方式由于F过渡类的构造函数中无内容，所以开销比较小，使用起来也比较方便，\n\n```\nvar book = {\n    name: 'js book',\n    alikeBook: ['css book', 'html book']\n}\nvar newBook = inheritObject(book)\nnewBook.name = 'ajax book'\nnewBook.alikeBook.push('xml books')\n\nvar otherBook = inheritObject(book)\notherBook.name = 'flash book'\notherBook.alikeBook.push('as books')\nconsole.log(newBook.name)\nconsole.log(newBook.alikeBook)\n\nconsole.log(otherBook.name)\nconsole.log(otherBook.alikeBook)\n\nconsole.log(book.name)\nconsole.log(book.alikeBook)\n```\n\n和类式继承一样，父类对象book中的值类型的属性被复制，引用类型的属性被共用。\n\n### 如虎添翼---寄生式继承\n\n\n```\n// 寄生式继承\n// 声明基对象\nvar book = {\n    name: 'js book',\n    alikeBook: ['css book', 'html book']\n}\nfunction inheritObject(o) {\n    // 声明一个过渡函数对象\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\n// var c = new inheritObject(book);\n// console.log(c)\nfunction createBook(obj) {\n    // 通过原型继承方式创建新对象\n    var o = new inheritObject(obj)\n    // 拓展新对象\n    o.getName = function() {\n        console.log(name)\n    }\n    return o;\n}\n\nvar a1  = createBook(book)\nvar a2  = createBook(book)\na1.alikeBook.push('设计模式')\nconsole.log(a1.alikeBook)\nconsole.log(a2.alikeBook)\n```\n\n其实寄生式继承就是对原型继承的第二次封装，并且在第二次封装的过程中对继承的对象进行了扩展，这样新创建的对象不仅仅有父类中的属性和方法而且还添加了新的属性和方法。\n\n### 终极继承者---寄生组合式继承\n\n> 之前学习了组合继承，就是将类式继承通构造函数继承组合，这种方式存在的问题就是子类不是父类的实例，而子类的原型式父类的实例，因此才有了寄生组合式继承。是寄生式继承与构造函数继承的组合，但是这里寄生式继承有点特殊，这里他处理的不是对象，而是类的原型。\n\n```\nfunction inheritObject(o) {\n    // 声明一个过渡函数对象\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\n\nfunction inheritPrototype(SubClass, SuperClass) {\n    // 复制一份父类的原型副本保存在变量中\n    var p = inheritObject(SuperClass.prototype);\n    // 修正因为重写子原型导致子类的constructor属性被修改\n    p.constructor = SubClass;\n    // 设置子类的原型\n    SubClass.prototype = p;\n}\n\n```\n\n> 在寄生组合式继承中，通过构造函数继承的属性和方法是没有问题的吗，这里主要探究通过寄生式继承重新继承父类的原型，我们需要继承的仅仅是父类的原型，不在需要调用父类的构造函数，换句话说，在构造函数继承中，我们已经调用了父类的构造函数，因此我们需要的就是父类的原型对象的一个副本，而这个副本我们我们通过原型继承便可得到，但是直接赋值个子类会有问题，因为对父类原型对象复制得到的复制对象p中的constroctor指向的不是SubClass子类对象，因此在寄生式继承中要对复制对象p做一次增强，修复其constroctor属性指向不正确问题，最后将得到的复制对象p赋值给子类的原型，这样子类的原型就继承了父类的原型并且没有执行父类的构造函数。\n\n```\n// 寄生式继承  继承原型\n// 传递参数  SuperClass  父了\n// 传递参数  SubClass    子类\n\nfunction inheritObject(o) {\n    // 声明一个过渡函数对象\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\nfunction inheritPrototype(SubClass, SuperClass) {\n    // 复制一份父类的原型副本保存在变量中\n    var p = inheritObject(SuperClass.prototype);\n    // 修正因为重写子原型导致子类的constructor属性被修改\n    p.constructor = SubClass;\n    // 设置子类的原型\n    SubClass.prototype = p;\n} \nfunction SuperClass(name) {\n    this.name = name;\n    this.colors = ['red', 'blue', 'green']\n}\nSuperClass.prototype.getName = function() {\n    console.log(this.name)\n}\nfunction SubClass(name, time) {\n    // 构造函数继承\n    SuperClass.call(this, name)\n    this.time = time\n}\n// 寄生式继承父类原型\ninheritPrototype(SubClass, SuperClass)\nSubClass.prototype.getTime = function() {\n    console.log(this.time)\n}\n// 创建两个测试方法\nvar instance1 = new SubClass('js book', 2017);\nvar instance2 = new SubClass('css book', 2018);\n\ninstance1.colors.push('black')\nconsole.log(instance1.colors)\nconsole.log(instance2.colors)\ninstance2.getName();\ninstance2.getTime();\n\n```\n\n> 这中继承最大的改变就是对子类原型的处理，被赋予父类原型的一个应用，这是一个对象，因此有一点要注意，就是子类在想添加原型方法必须通过prototype对象，通过点语法的形式一个个添加方法了，否则直接赋予对象就会覆盖掉从父类原型继承的对象了。\n\n","source":"_posts/javascript/js继承.md","raw":"---\ntitle: js继承\ncategories:\n  - javascript设计模式\ntags:\n  - js继承\ndate: 2017-11-05 21:49:20\n---\n\n> 每个类都有三个部分组成\n\n* 构造函数内的，供实例对象复制用的\n* 构造函数外的，直接通过点语法添加的，这是供类使用的，实例对象访问不到\n* 类的原型中的，实例化对象可以通过其原型链间接的访问到，也是为供所有实例化对象所共有\n\n<!--- more -->\n\n### 子类的原型继承---类式继承\n\n> 类式继承需要将第一个类的实例赋值给第二个类的原型\n\n```\n// 父类\nfunction SuperClass() {\n    this.SuperValue = true;\n}\n// 为父类原型添加方法\nSuperClass.prototype.getSuperValue = function() {\n    // alert(1)\n    return this.SuperValue;\n}\n// console.dir(SuperClass);\nvar supe = new SuperClass();\n// console.dir(supe);\n// supe.getSuperValue();\n// 声明子类\nfunction SubClass() {\n    this.subValue = false;\n}\n// 子类继承父类\nSubClass.prototype = new SuperClass();\n// 为子类添加共有方法\nSubClass.prototype.getSubValue = function() {\n    // alert(2);\n    return this.subValue;\n}\n// console.dir(SubClass);\n// 子类继承父类SuperValue属性，\n// 访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找，这就是原型链。\nvar sub = new SubClass();\n// sub.getSuperValue();\n// sub.getSubValue();\n// console.log(sub.SuperValue);\n// console.log(sub.subValue);\n// console.dir(sub);\n\n```\n\n> 为什么这样做？？？\n\n类的原型对象的作用就是为类的原型添加共有方法，但是累不能直接访问这些属性和方法，必须通过prototype来访问。\n\n我们在实例化一个父类的时候，新创建的对象复制了父类的构造函数内的属性和方法并且将隐氏原型_proto_指向父类的原型对象，这样就拥有了父类的原型对象上的方法和属性。\n\n如果将新创建的对象赋值给子类的原型，那么子类的原型就可以访问到父类的原型上的属性和方法，同样也可以访问从父类构造函数中复制的属性和方法，同样子类也可以访问父类原型上的属性和方法与父类构造函数中复制的属性和方法。\n\n> 检测继承关系\n\ninstanceof通过判断对象的_proto_与构造函数的prototype，来确定这个对象是否是某个类的实例，而不关心对象与类的自身结构\n\n```\nconsole.log(sub instanceof SubClass);         //true\nconsole.log(sub instanceof SuperClass);       //true\nconsole.log(SubClass instanceof SuperClass);  //false\n\nwhy false??\ninstanceof 是判断前面的对象是否是后面类的实例，他并不表示两者的继承，\nconsole.log(SubClass.prototype instanceof SuperClass); //true\n\n```\n\n> 类式继承的缺点\n\n* 由于子类通过其原型Prototype对父类实例化，继承了父类，所以说父类中的共有属性要是引用类型，就会在子类中被所有属性共有，因此一个子类的实例更改子类原型从父类构造函数中继承来的共有属性就会直接影响到其他子类\n\n```\nfunction SuperClass() {\n    this.books = ['javascript', 'html', 'css']\n    this.a = 12\n}\nfunction SubClass() {}\nSubClass.prototype = new SuperClass()\nvar instance1 = new SubClass()\nvar instance2 = new SubClass()\nconsole.log(instance2.books)\ninstance1.books.push('设计模式')\ninstance1.a = 34\nconsole.log(instance2.books)\nconsole.log(instance2.a)\n```\n* 由于子类实现的继承是靠原型prototype对付类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的，因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化。\n\n### 创建即继承---构造函数继承\n\n```\n// 构造函数继承\n// 声明父类\nfunction SuperClass(id) {\n    this.books = ['javascript', 'html', 'css'];\n    this.id = id;\n}\n// 父类声明原型\nSuperClass.prototype.showBooks = function() {\n    console.log(this.books);\n}\n// 声明子类\nfunction SubClass(id) {\n    // 继承父类\n    SuperClass.call(this, id);\n}\n// 创建第一个子类的实例\nvar instance1 = new SubClass(11);\n// 创建第二个子类的实例\nvar instance2 = new SubClass(22);\n// 验证\ninstance1.books.push('设计模式');\nconsole.log(instance1.books);\nconsole.log(instance2.books);\nconsole.log(instance1.id);\nconsole.log(instance2.id);\n\n```\n> 继承原理\n\n* 由于call这个方法可以更改函数的作用域，因此在子类中，对superClass调用这个方法就是将子类中的变量在父类中执行一遍。\n\n* 由于父类中是=给this绑定属性的，因此子类自然也就继承了父类的共有属性\n\n* 由于这种类型的继承没有涉及原型prototype，所以父类的原型方法自然不会被子类继承\n\n> 每个函数都包含两个非继承而来的方法：call()方法和apply()方法。\n\n* 相同点：这两个方法的作用是一样的。\n\n都是在特定的作用域中调用函数，等于设置函数体内this对象的值，以扩充函数赖以运行的作用域。\n\n一般来说，this总是指向调用某个方法的对象，但是使用call()和apply()方法时，就会改变this的指向。\n\n* 不同点：接收参数的方式不同。\n\napply()方法 接收两个参数，一个是函数运行的作用域（this），另一个是参数数组。\n\n### 将有点为我所用---组合继承 \n\n#### 总结前面两种特点\n\n> 类式继承式通过子类的原型prototype对父类实例化来实现的。\n\n> 构造函数式继承式通过在子类的构造函数作用环境中执行一次父类的构造函数来实现。\n\n```\n// 组合式继承\n// 声明父类\n\nfunction SuperClass(name) {\n    this.name = name;\n    this,boob = ['html', 'css', 'javascript'];\n}\n// 父类原型共有方法\nSuperClass.prototype.getName = function() {\n    console.log(this.name);\n}\n// 声明子类\nfunction SubClass(name, time) {\n    // 构造函数式继承父类name 属性\n    SuperClass.call(this, name);\n    // 子类中新增共有属性\n    this.time = time;\n}\n// 类式继承  子类原型继承父类\nSubClass.prototype = new SuperClass();\n// 子类原型方法\nSubClass.prototype.getTime = function() {\n    console.log(this.time);\n}\n// 测试\nvar instance1 = new SubClass('js book', 2017);\ninstance1.books.push('设计模式');\nconsole.log(instance1.books);\ninstance1.getName();\ninstance1.getTime();\nvar instance2 = new SubClass('css book', 2018);\nconsole.log(instance2.books);\ninstance2.getName();\ninstance2.getTime();\n\n```\n> 结合了类式继承和构造函数继承两种方式的优点\n\n> 不足之处\n\n在使用构造函数继承时执行了一遍父类的构造函数，而在实现子类原型的类式继承式又调用了一遍父类的构造函数。因此父类构造函数调用了两遍。\n\n### 洁净的继承者---原型式继承\n\n```\nfunction inheritObject(o) {\n    // 声明一个过渡函数对象\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\n```\n> 和类式继承有点像？？\n\n对，是对类式继承的一个封装，过渡对象相当于类式继承中的子类，只不过在原型式继承中作为一个过渡对象出现的，目的是为了创建要返回的新的实例化对象。\n\n> ??是不是类式继承中的问题在这里也会出现？？？\n\n是的，！！！，不过这种方式由于F过渡类的构造函数中无内容，所以开销比较小，使用起来也比较方便，\n\n```\nvar book = {\n    name: 'js book',\n    alikeBook: ['css book', 'html book']\n}\nvar newBook = inheritObject(book)\nnewBook.name = 'ajax book'\nnewBook.alikeBook.push('xml books')\n\nvar otherBook = inheritObject(book)\notherBook.name = 'flash book'\notherBook.alikeBook.push('as books')\nconsole.log(newBook.name)\nconsole.log(newBook.alikeBook)\n\nconsole.log(otherBook.name)\nconsole.log(otherBook.alikeBook)\n\nconsole.log(book.name)\nconsole.log(book.alikeBook)\n```\n\n和类式继承一样，父类对象book中的值类型的属性被复制，引用类型的属性被共用。\n\n### 如虎添翼---寄生式继承\n\n\n```\n// 寄生式继承\n// 声明基对象\nvar book = {\n    name: 'js book',\n    alikeBook: ['css book', 'html book']\n}\nfunction inheritObject(o) {\n    // 声明一个过渡函数对象\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\n// var c = new inheritObject(book);\n// console.log(c)\nfunction createBook(obj) {\n    // 通过原型继承方式创建新对象\n    var o = new inheritObject(obj)\n    // 拓展新对象\n    o.getName = function() {\n        console.log(name)\n    }\n    return o;\n}\n\nvar a1  = createBook(book)\nvar a2  = createBook(book)\na1.alikeBook.push('设计模式')\nconsole.log(a1.alikeBook)\nconsole.log(a2.alikeBook)\n```\n\n其实寄生式继承就是对原型继承的第二次封装，并且在第二次封装的过程中对继承的对象进行了扩展，这样新创建的对象不仅仅有父类中的属性和方法而且还添加了新的属性和方法。\n\n### 终极继承者---寄生组合式继承\n\n> 之前学习了组合继承，就是将类式继承通构造函数继承组合，这种方式存在的问题就是子类不是父类的实例，而子类的原型式父类的实例，因此才有了寄生组合式继承。是寄生式继承与构造函数继承的组合，但是这里寄生式继承有点特殊，这里他处理的不是对象，而是类的原型。\n\n```\nfunction inheritObject(o) {\n    // 声明一个过渡函数对象\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\n\nfunction inheritPrototype(SubClass, SuperClass) {\n    // 复制一份父类的原型副本保存在变量中\n    var p = inheritObject(SuperClass.prototype);\n    // 修正因为重写子原型导致子类的constructor属性被修改\n    p.constructor = SubClass;\n    // 设置子类的原型\n    SubClass.prototype = p;\n}\n\n```\n\n> 在寄生组合式继承中，通过构造函数继承的属性和方法是没有问题的吗，这里主要探究通过寄生式继承重新继承父类的原型，我们需要继承的仅仅是父类的原型，不在需要调用父类的构造函数，换句话说，在构造函数继承中，我们已经调用了父类的构造函数，因此我们需要的就是父类的原型对象的一个副本，而这个副本我们我们通过原型继承便可得到，但是直接赋值个子类会有问题，因为对父类原型对象复制得到的复制对象p中的constroctor指向的不是SubClass子类对象，因此在寄生式继承中要对复制对象p做一次增强，修复其constroctor属性指向不正确问题，最后将得到的复制对象p赋值给子类的原型，这样子类的原型就继承了父类的原型并且没有执行父类的构造函数。\n\n```\n// 寄生式继承  继承原型\n// 传递参数  SuperClass  父了\n// 传递参数  SubClass    子类\n\nfunction inheritObject(o) {\n    // 声明一个过渡函数对象\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\nfunction inheritPrototype(SubClass, SuperClass) {\n    // 复制一份父类的原型副本保存在变量中\n    var p = inheritObject(SuperClass.prototype);\n    // 修正因为重写子原型导致子类的constructor属性被修改\n    p.constructor = SubClass;\n    // 设置子类的原型\n    SubClass.prototype = p;\n} \nfunction SuperClass(name) {\n    this.name = name;\n    this.colors = ['red', 'blue', 'green']\n}\nSuperClass.prototype.getName = function() {\n    console.log(this.name)\n}\nfunction SubClass(name, time) {\n    // 构造函数继承\n    SuperClass.call(this, name)\n    this.time = time\n}\n// 寄生式继承父类原型\ninheritPrototype(SubClass, SuperClass)\nSubClass.prototype.getTime = function() {\n    console.log(this.time)\n}\n// 创建两个测试方法\nvar instance1 = new SubClass('js book', 2017);\nvar instance2 = new SubClass('css book', 2018);\n\ninstance1.colors.push('black')\nconsole.log(instance1.colors)\nconsole.log(instance2.colors)\ninstance2.getName();\ninstance2.getTime();\n\n```\n\n> 这中继承最大的改变就是对子类原型的处理，被赋予父类原型的一个应用，这是一个对象，因此有一点要注意，就是子类在想添加原型方法必须通过prototype对象，通过点语法的形式一个个添加方法了，否则直接赋予对象就会覆盖掉从父类原型继承的对象了。\n\n","slug":"javascript/js继承","published":1,"updated":"2017-11-22T00:56:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaqhv1gf0007btx1xptx4a6q","content":"<blockquote>\n<p>每个类都有三个部分组成</p>\n</blockquote>\n<ul>\n<li>构造函数内的，供实例对象复制用的</li>\n<li>构造函数外的，直接通过点语法添加的，这是供类使用的，实例对象访问不到</li>\n<li>类的原型中的，实例化对象可以通过其原型链间接的访问到，也是为供所有实例化对象所共有</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"子类的原型继承—类式继承\"><a href=\"#子类的原型继承—类式继承\" class=\"headerlink\" title=\"子类的原型继承—类式继承\"></a>子类的原型继承—类式继承</h3><blockquote>\n<p>类式继承需要将第一个类的实例赋值给第二个类的原型</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 父类</span><br><span class=\"line\">function SuperClass() &#123;</span><br><span class=\"line\">    this.SuperValue = true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 为父类原型添加方法</span><br><span class=\"line\">SuperClass.prototype.getSuperValue = function() &#123;</span><br><span class=\"line\">    // alert(1)</span><br><span class=\"line\">    return this.SuperValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// console.dir(SuperClass);</span><br><span class=\"line\">var supe = new SuperClass();</span><br><span class=\"line\">// console.dir(supe);</span><br><span class=\"line\">// supe.getSuperValue();</span><br><span class=\"line\">// 声明子类</span><br><span class=\"line\">function SubClass() &#123;</span><br><span class=\"line\">    this.subValue = false;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 子类继承父类</span><br><span class=\"line\">SubClass.prototype = new SuperClass();</span><br><span class=\"line\">// 为子类添加共有方法</span><br><span class=\"line\">SubClass.prototype.getSubValue = function() &#123;</span><br><span class=\"line\">    // alert(2);</span><br><span class=\"line\">    return this.subValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// console.dir(SubClass);</span><br><span class=\"line\">// 子类继承父类SuperValue属性，</span><br><span class=\"line\">// 访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找，这就是原型链。</span><br><span class=\"line\">var sub = new SubClass();</span><br><span class=\"line\">// sub.getSuperValue();</span><br><span class=\"line\">// sub.getSubValue();</span><br><span class=\"line\">// console.log(sub.SuperValue);</span><br><span class=\"line\">// console.log(sub.subValue);</span><br><span class=\"line\">// console.dir(sub);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>为什么这样做？？？</p>\n</blockquote>\n<p>类的原型对象的作用就是为类的原型添加共有方法，但是累不能直接访问这些属性和方法，必须通过prototype来访问。</p>\n<p>我们在实例化一个父类的时候，新创建的对象复制了父类的构造函数内的属性和方法并且将隐氏原型<em>proto</em>指向父类的原型对象，这样就拥有了父类的原型对象上的方法和属性。</p>\n<p>如果将新创建的对象赋值给子类的原型，那么子类的原型就可以访问到父类的原型上的属性和方法，同样也可以访问从父类构造函数中复制的属性和方法，同样子类也可以访问父类原型上的属性和方法与父类构造函数中复制的属性和方法。</p>\n<blockquote>\n<p>检测继承关系</p>\n</blockquote>\n<p>instanceof通过判断对象的<em>proto</em>与构造函数的prototype，来确定这个对象是否是某个类的实例，而不关心对象与类的自身结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(sub instanceof SubClass);         //true</span><br><span class=\"line\">console.log(sub instanceof SuperClass);       //true</span><br><span class=\"line\">console.log(SubClass instanceof SuperClass);  //false</span><br><span class=\"line\"></span><br><span class=\"line\">why false??</span><br><span class=\"line\">instanceof 是判断前面的对象是否是后面类的实例，他并不表示两者的继承，</span><br><span class=\"line\">console.log(SubClass.prototype instanceof SuperClass); //true</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>类式继承的缺点</p>\n</blockquote>\n<ul>\n<li>由于子类通过其原型Prototype对父类实例化，继承了父类，所以说父类中的共有属性要是引用类型，就会在子类中被所有属性共有，因此一个子类的实例更改子类原型从父类构造函数中继承来的共有属性就会直接影响到其他子类</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function SuperClass() &#123;</span><br><span class=\"line\">    this.books = [&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;]</span><br><span class=\"line\">    this.a = 12</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function SubClass() &#123;&#125;</span><br><span class=\"line\">SubClass.prototype = new SuperClass()</span><br><span class=\"line\">var instance1 = new SubClass()</span><br><span class=\"line\">var instance2 = new SubClass()</span><br><span class=\"line\">console.log(instance2.books)</span><br><span class=\"line\">instance1.books.push(&apos;设计模式&apos;)</span><br><span class=\"line\">instance1.a = 34</span><br><span class=\"line\">console.log(instance2.books)</span><br><span class=\"line\">console.log(instance2.a)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>由于子类实现的继承是靠原型prototype对付类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的，因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化。</li>\n</ul>\n<h3 id=\"创建即继承—构造函数继承\"><a href=\"#创建即继承—构造函数继承\" class=\"headerlink\" title=\"创建即继承—构造函数继承\"></a>创建即继承—构造函数继承</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 构造函数继承</span><br><span class=\"line\">// 声明父类</span><br><span class=\"line\">function SuperClass(id) &#123;</span><br><span class=\"line\">    this.books = [&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;];</span><br><span class=\"line\">    this.id = id;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 父类声明原型</span><br><span class=\"line\">SuperClass.prototype.showBooks = function() &#123;</span><br><span class=\"line\">    console.log(this.books);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 声明子类</span><br><span class=\"line\">function SubClass(id) &#123;</span><br><span class=\"line\">    // 继承父类</span><br><span class=\"line\">    SuperClass.call(this, id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 创建第一个子类的实例</span><br><span class=\"line\">var instance1 = new SubClass(11);</span><br><span class=\"line\">// 创建第二个子类的实例</span><br><span class=\"line\">var instance2 = new SubClass(22);</span><br><span class=\"line\">// 验证</span><br><span class=\"line\">instance1.books.push(&apos;设计模式&apos;);</span><br><span class=\"line\">console.log(instance1.books);</span><br><span class=\"line\">console.log(instance2.books);</span><br><span class=\"line\">console.log(instance1.id);</span><br><span class=\"line\">console.log(instance2.id);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>继承原理</p>\n</blockquote>\n<ul>\n<li><p>由于call这个方法可以更改函数的作用域，因此在子类中，对superClass调用这个方法就是将子类中的变量在父类中执行一遍。</p>\n</li>\n<li><p>由于父类中是=给this绑定属性的，因此子类自然也就继承了父类的共有属性</p>\n</li>\n<li><p>由于这种类型的继承没有涉及原型prototype，所以父类的原型方法自然不会被子类继承</p>\n</li>\n</ul>\n<blockquote>\n<p>每个函数都包含两个非继承而来的方法：call()方法和apply()方法。</p>\n</blockquote>\n<ul>\n<li>相同点：这两个方法的作用是一样的。</li>\n</ul>\n<p>都是在特定的作用域中调用函数，等于设置函数体内this对象的值，以扩充函数赖以运行的作用域。</p>\n<p>一般来说，this总是指向调用某个方法的对象，但是使用call()和apply()方法时，就会改变this的指向。</p>\n<ul>\n<li>不同点：接收参数的方式不同。</li>\n</ul>\n<p>apply()方法 接收两个参数，一个是函数运行的作用域（this），另一个是参数数组。</p>\n<h3 id=\"将有点为我所用—组合继承\"><a href=\"#将有点为我所用—组合继承\" class=\"headerlink\" title=\"将有点为我所用—组合继承\"></a>将有点为我所用—组合继承</h3><h4 id=\"总结前面两种特点\"><a href=\"#总结前面两种特点\" class=\"headerlink\" title=\"总结前面两种特点\"></a>总结前面两种特点</h4><blockquote>\n<p>类式继承式通过子类的原型prototype对父类实例化来实现的。</p>\n<p>构造函数式继承式通过在子类的构造函数作用环境中执行一次父类的构造函数来实现。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 组合式继承</span><br><span class=\"line\">// 声明父类</span><br><span class=\"line\"></span><br><span class=\"line\">function SuperClass(name) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">    this,boob = [&apos;html&apos;, &apos;css&apos;, &apos;javascript&apos;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 父类原型共有方法</span><br><span class=\"line\">SuperClass.prototype.getName = function() &#123;</span><br><span class=\"line\">    console.log(this.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 声明子类</span><br><span class=\"line\">function SubClass(name, time) &#123;</span><br><span class=\"line\">    // 构造函数式继承父类name 属性</span><br><span class=\"line\">    SuperClass.call(this, name);</span><br><span class=\"line\">    // 子类中新增共有属性</span><br><span class=\"line\">    this.time = time;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 类式继承  子类原型继承父类</span><br><span class=\"line\">SubClass.prototype = new SuperClass();</span><br><span class=\"line\">// 子类原型方法</span><br><span class=\"line\">SubClass.prototype.getTime = function() &#123;</span><br><span class=\"line\">    console.log(this.time);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 测试</span><br><span class=\"line\">var instance1 = new SubClass(&apos;js book&apos;, 2017);</span><br><span class=\"line\">instance1.books.push(&apos;设计模式&apos;);</span><br><span class=\"line\">console.log(instance1.books);</span><br><span class=\"line\">instance1.getName();</span><br><span class=\"line\">instance1.getTime();</span><br><span class=\"line\">var instance2 = new SubClass(&apos;css book&apos;, 2018);</span><br><span class=\"line\">console.log(instance2.books);</span><br><span class=\"line\">instance2.getName();</span><br><span class=\"line\">instance2.getTime();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>结合了类式继承和构造函数继承两种方式的优点</p>\n<p>不足之处</p>\n</blockquote>\n<p>在使用构造函数继承时执行了一遍父类的构造函数，而在实现子类原型的类式继承式又调用了一遍父类的构造函数。因此父类构造函数调用了两遍。</p>\n<h3 id=\"洁净的继承者—原型式继承\"><a href=\"#洁净的继承者—原型式继承\" class=\"headerlink\" title=\"洁净的继承者—原型式继承\"></a>洁净的继承者—原型式继承</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function inheritObject(o) &#123;</span><br><span class=\"line\">    // 声明一个过渡函数对象</span><br><span class=\"line\">    function F() &#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>和类式继承有点像？？</p>\n</blockquote>\n<p>对，是对类式继承的一个封装，过渡对象相当于类式继承中的子类，只不过在原型式继承中作为一个过渡对象出现的，目的是为了创建要返回的新的实例化对象。</p>\n<blockquote>\n<p>??是不是类式继承中的问题在这里也会出现？？？</p>\n</blockquote>\n<p>是的，！！！，不过这种方式由于F过渡类的构造函数中无内容，所以开销比较小，使用起来也比较方便，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var book = &#123;</span><br><span class=\"line\">    name: &apos;js book&apos;,</span><br><span class=\"line\">    alikeBook: [&apos;css book&apos;, &apos;html book&apos;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var newBook = inheritObject(book)</span><br><span class=\"line\">newBook.name = &apos;ajax book&apos;</span><br><span class=\"line\">newBook.alikeBook.push(&apos;xml books&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">var otherBook = inheritObject(book)</span><br><span class=\"line\">otherBook.name = &apos;flash book&apos;</span><br><span class=\"line\">otherBook.alikeBook.push(&apos;as books&apos;)</span><br><span class=\"line\">console.log(newBook.name)</span><br><span class=\"line\">console.log(newBook.alikeBook)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(otherBook.name)</span><br><span class=\"line\">console.log(otherBook.alikeBook)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(book.name)</span><br><span class=\"line\">console.log(book.alikeBook)</span><br></pre></td></tr></table></figure>\n<p>和类式继承一样，父类对象book中的值类型的属性被复制，引用类型的属性被共用。</p>\n<h3 id=\"如虎添翼—寄生式继承\"><a href=\"#如虎添翼—寄生式继承\" class=\"headerlink\" title=\"如虎添翼—寄生式继承\"></a>如虎添翼—寄生式继承</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 寄生式继承</span><br><span class=\"line\">// 声明基对象</span><br><span class=\"line\">var book = &#123;</span><br><span class=\"line\">    name: &apos;js book&apos;,</span><br><span class=\"line\">    alikeBook: [&apos;css book&apos;, &apos;html book&apos;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function inheritObject(o) &#123;</span><br><span class=\"line\">    // 声明一个过渡函数对象</span><br><span class=\"line\">    function F() &#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// var c = new inheritObject(book);</span><br><span class=\"line\">// console.log(c)</span><br><span class=\"line\">function createBook(obj) &#123;</span><br><span class=\"line\">    // 通过原型继承方式创建新对象</span><br><span class=\"line\">    var o = new inheritObject(obj)</span><br><span class=\"line\">    // 拓展新对象</span><br><span class=\"line\">    o.getName = function() &#123;</span><br><span class=\"line\">        console.log(name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var a1  = createBook(book)</span><br><span class=\"line\">var a2  = createBook(book)</span><br><span class=\"line\">a1.alikeBook.push(&apos;设计模式&apos;)</span><br><span class=\"line\">console.log(a1.alikeBook)</span><br><span class=\"line\">console.log(a2.alikeBook)</span><br></pre></td></tr></table></figure>\n<p>其实寄生式继承就是对原型继承的第二次封装，并且在第二次封装的过程中对继承的对象进行了扩展，这样新创建的对象不仅仅有父类中的属性和方法而且还添加了新的属性和方法。</p>\n<h3 id=\"终极继承者—寄生组合式继承\"><a href=\"#终极继承者—寄生组合式继承\" class=\"headerlink\" title=\"终极继承者—寄生组合式继承\"></a>终极继承者—寄生组合式继承</h3><blockquote>\n<p>之前学习了组合继承，就是将类式继承通构造函数继承组合，这种方式存在的问题就是子类不是父类的实例，而子类的原型式父类的实例，因此才有了寄生组合式继承。是寄生式继承与构造函数继承的组合，但是这里寄生式继承有点特殊，这里他处理的不是对象，而是类的原型。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function inheritObject(o) &#123;</span><br><span class=\"line\">    // 声明一个过渡函数对象</span><br><span class=\"line\">    function F() &#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function inheritPrototype(SubClass, SuperClass) &#123;</span><br><span class=\"line\">    // 复制一份父类的原型副本保存在变量中</span><br><span class=\"line\">    var p = inheritObject(SuperClass.prototype);</span><br><span class=\"line\">    // 修正因为重写子原型导致子类的constructor属性被修改</span><br><span class=\"line\">    p.constructor = SubClass;</span><br><span class=\"line\">    // 设置子类的原型</span><br><span class=\"line\">    SubClass.prototype = p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在寄生组合式继承中，通过构造函数继承的属性和方法是没有问题的吗，这里主要探究通过寄生式继承重新继承父类的原型，我们需要继承的仅仅是父类的原型，不在需要调用父类的构造函数，换句话说，在构造函数继承中，我们已经调用了父类的构造函数，因此我们需要的就是父类的原型对象的一个副本，而这个副本我们我们通过原型继承便可得到，但是直接赋值个子类会有问题，因为对父类原型对象复制得到的复制对象p中的constroctor指向的不是SubClass子类对象，因此在寄生式继承中要对复制对象p做一次增强，修复其constroctor属性指向不正确问题，最后将得到的复制对象p赋值给子类的原型，这样子类的原型就继承了父类的原型并且没有执行父类的构造函数。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 寄生式继承  继承原型</span><br><span class=\"line\">// 传递参数  SuperClass  父了</span><br><span class=\"line\">// 传递参数  SubClass    子类</span><br><span class=\"line\"></span><br><span class=\"line\">function inheritObject(o) &#123;</span><br><span class=\"line\">    // 声明一个过渡函数对象</span><br><span class=\"line\">    function F() &#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function inheritPrototype(SubClass, SuperClass) &#123;</span><br><span class=\"line\">    // 复制一份父类的原型副本保存在变量中</span><br><span class=\"line\">    var p = inheritObject(SuperClass.prototype);</span><br><span class=\"line\">    // 修正因为重写子原型导致子类的constructor属性被修改</span><br><span class=\"line\">    p.constructor = SubClass;</span><br><span class=\"line\">    // 设置子类的原型</span><br><span class=\"line\">    SubClass.prototype = p;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">function SuperClass(name) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">    this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperClass.prototype.getName = function() &#123;</span><br><span class=\"line\">    console.log(this.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function SubClass(name, time) &#123;</span><br><span class=\"line\">    // 构造函数继承</span><br><span class=\"line\">    SuperClass.call(this, name)</span><br><span class=\"line\">    this.time = time</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 寄生式继承父类原型</span><br><span class=\"line\">inheritPrototype(SubClass, SuperClass)</span><br><span class=\"line\">SubClass.prototype.getTime = function() &#123;</span><br><span class=\"line\">    console.log(this.time)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 创建两个测试方法</span><br><span class=\"line\">var instance1 = new SubClass(&apos;js book&apos;, 2017);</span><br><span class=\"line\">var instance2 = new SubClass(&apos;css book&apos;, 2018);</span><br><span class=\"line\"></span><br><span class=\"line\">instance1.colors.push(&apos;black&apos;)</span><br><span class=\"line\">console.log(instance1.colors)</span><br><span class=\"line\">console.log(instance2.colors)</span><br><span class=\"line\">instance2.getName();</span><br><span class=\"line\">instance2.getTime();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这中继承最大的改变就是对子类原型的处理，被赋予父类原型的一个应用，这是一个对象，因此有一点要注意，就是子类在想添加原型方法必须通过prototype对象，通过点语法的形式一个个添加方法了，否则直接赋予对象就会覆盖掉从父类原型继承的对象了。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>每个类都有三个部分组成</p>\n</blockquote>\n<ul>\n<li>构造函数内的，供实例对象复制用的</li>\n<li>构造函数外的，直接通过点语法添加的，这是供类使用的，实例对象访问不到</li>\n<li>类的原型中的，实例化对象可以通过其原型链间接的访问到，也是为供所有实例化对象所共有</li>\n</ul>","more":"<h3 id=\"子类的原型继承—类式继承\"><a href=\"#子类的原型继承—类式继承\" class=\"headerlink\" title=\"子类的原型继承—类式继承\"></a>子类的原型继承—类式继承</h3><blockquote>\n<p>类式继承需要将第一个类的实例赋值给第二个类的原型</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 父类</span><br><span class=\"line\">function SuperClass() &#123;</span><br><span class=\"line\">    this.SuperValue = true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 为父类原型添加方法</span><br><span class=\"line\">SuperClass.prototype.getSuperValue = function() &#123;</span><br><span class=\"line\">    // alert(1)</span><br><span class=\"line\">    return this.SuperValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// console.dir(SuperClass);</span><br><span class=\"line\">var supe = new SuperClass();</span><br><span class=\"line\">// console.dir(supe);</span><br><span class=\"line\">// supe.getSuperValue();</span><br><span class=\"line\">// 声明子类</span><br><span class=\"line\">function SubClass() &#123;</span><br><span class=\"line\">    this.subValue = false;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 子类继承父类</span><br><span class=\"line\">SubClass.prototype = new SuperClass();</span><br><span class=\"line\">// 为子类添加共有方法</span><br><span class=\"line\">SubClass.prototype.getSubValue = function() &#123;</span><br><span class=\"line\">    // alert(2);</span><br><span class=\"line\">    return this.subValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// console.dir(SubClass);</span><br><span class=\"line\">// 子类继承父类SuperValue属性，</span><br><span class=\"line\">// 访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找，这就是原型链。</span><br><span class=\"line\">var sub = new SubClass();</span><br><span class=\"line\">// sub.getSuperValue();</span><br><span class=\"line\">// sub.getSubValue();</span><br><span class=\"line\">// console.log(sub.SuperValue);</span><br><span class=\"line\">// console.log(sub.subValue);</span><br><span class=\"line\">// console.dir(sub);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>为什么这样做？？？</p>\n</blockquote>\n<p>类的原型对象的作用就是为类的原型添加共有方法，但是累不能直接访问这些属性和方法，必须通过prototype来访问。</p>\n<p>我们在实例化一个父类的时候，新创建的对象复制了父类的构造函数内的属性和方法并且将隐氏原型<em>proto</em>指向父类的原型对象，这样就拥有了父类的原型对象上的方法和属性。</p>\n<p>如果将新创建的对象赋值给子类的原型，那么子类的原型就可以访问到父类的原型上的属性和方法，同样也可以访问从父类构造函数中复制的属性和方法，同样子类也可以访问父类原型上的属性和方法与父类构造函数中复制的属性和方法。</p>\n<blockquote>\n<p>检测继承关系</p>\n</blockquote>\n<p>instanceof通过判断对象的<em>proto</em>与构造函数的prototype，来确定这个对象是否是某个类的实例，而不关心对象与类的自身结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(sub instanceof SubClass);         //true</span><br><span class=\"line\">console.log(sub instanceof SuperClass);       //true</span><br><span class=\"line\">console.log(SubClass instanceof SuperClass);  //false</span><br><span class=\"line\"></span><br><span class=\"line\">why false??</span><br><span class=\"line\">instanceof 是判断前面的对象是否是后面类的实例，他并不表示两者的继承，</span><br><span class=\"line\">console.log(SubClass.prototype instanceof SuperClass); //true</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>类式继承的缺点</p>\n</blockquote>\n<ul>\n<li>由于子类通过其原型Prototype对父类实例化，继承了父类，所以说父类中的共有属性要是引用类型，就会在子类中被所有属性共有，因此一个子类的实例更改子类原型从父类构造函数中继承来的共有属性就会直接影响到其他子类</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function SuperClass() &#123;</span><br><span class=\"line\">    this.books = [&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;]</span><br><span class=\"line\">    this.a = 12</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function SubClass() &#123;&#125;</span><br><span class=\"line\">SubClass.prototype = new SuperClass()</span><br><span class=\"line\">var instance1 = new SubClass()</span><br><span class=\"line\">var instance2 = new SubClass()</span><br><span class=\"line\">console.log(instance2.books)</span><br><span class=\"line\">instance1.books.push(&apos;设计模式&apos;)</span><br><span class=\"line\">instance1.a = 34</span><br><span class=\"line\">console.log(instance2.books)</span><br><span class=\"line\">console.log(instance2.a)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>由于子类实现的继承是靠原型prototype对付类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的，因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化。</li>\n</ul>\n<h3 id=\"创建即继承—构造函数继承\"><a href=\"#创建即继承—构造函数继承\" class=\"headerlink\" title=\"创建即继承—构造函数继承\"></a>创建即继承—构造函数继承</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 构造函数继承</span><br><span class=\"line\">// 声明父类</span><br><span class=\"line\">function SuperClass(id) &#123;</span><br><span class=\"line\">    this.books = [&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;];</span><br><span class=\"line\">    this.id = id;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 父类声明原型</span><br><span class=\"line\">SuperClass.prototype.showBooks = function() &#123;</span><br><span class=\"line\">    console.log(this.books);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 声明子类</span><br><span class=\"line\">function SubClass(id) &#123;</span><br><span class=\"line\">    // 继承父类</span><br><span class=\"line\">    SuperClass.call(this, id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 创建第一个子类的实例</span><br><span class=\"line\">var instance1 = new SubClass(11);</span><br><span class=\"line\">// 创建第二个子类的实例</span><br><span class=\"line\">var instance2 = new SubClass(22);</span><br><span class=\"line\">// 验证</span><br><span class=\"line\">instance1.books.push(&apos;设计模式&apos;);</span><br><span class=\"line\">console.log(instance1.books);</span><br><span class=\"line\">console.log(instance2.books);</span><br><span class=\"line\">console.log(instance1.id);</span><br><span class=\"line\">console.log(instance2.id);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>继承原理</p>\n</blockquote>\n<ul>\n<li><p>由于call这个方法可以更改函数的作用域，因此在子类中，对superClass调用这个方法就是将子类中的变量在父类中执行一遍。</p>\n</li>\n<li><p>由于父类中是=给this绑定属性的，因此子类自然也就继承了父类的共有属性</p>\n</li>\n<li><p>由于这种类型的继承没有涉及原型prototype，所以父类的原型方法自然不会被子类继承</p>\n</li>\n</ul>\n<blockquote>\n<p>每个函数都包含两个非继承而来的方法：call()方法和apply()方法。</p>\n</blockquote>\n<ul>\n<li>相同点：这两个方法的作用是一样的。</li>\n</ul>\n<p>都是在特定的作用域中调用函数，等于设置函数体内this对象的值，以扩充函数赖以运行的作用域。</p>\n<p>一般来说，this总是指向调用某个方法的对象，但是使用call()和apply()方法时，就会改变this的指向。</p>\n<ul>\n<li>不同点：接收参数的方式不同。</li>\n</ul>\n<p>apply()方法 接收两个参数，一个是函数运行的作用域（this），另一个是参数数组。</p>\n<h3 id=\"将有点为我所用—组合继承\"><a href=\"#将有点为我所用—组合继承\" class=\"headerlink\" title=\"将有点为我所用—组合继承\"></a>将有点为我所用—组合继承</h3><h4 id=\"总结前面两种特点\"><a href=\"#总结前面两种特点\" class=\"headerlink\" title=\"总结前面两种特点\"></a>总结前面两种特点</h4><blockquote>\n<p>类式继承式通过子类的原型prototype对父类实例化来实现的。</p>\n<p>构造函数式继承式通过在子类的构造函数作用环境中执行一次父类的构造函数来实现。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 组合式继承</span><br><span class=\"line\">// 声明父类</span><br><span class=\"line\"></span><br><span class=\"line\">function SuperClass(name) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">    this,boob = [&apos;html&apos;, &apos;css&apos;, &apos;javascript&apos;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 父类原型共有方法</span><br><span class=\"line\">SuperClass.prototype.getName = function() &#123;</span><br><span class=\"line\">    console.log(this.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 声明子类</span><br><span class=\"line\">function SubClass(name, time) &#123;</span><br><span class=\"line\">    // 构造函数式继承父类name 属性</span><br><span class=\"line\">    SuperClass.call(this, name);</span><br><span class=\"line\">    // 子类中新增共有属性</span><br><span class=\"line\">    this.time = time;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 类式继承  子类原型继承父类</span><br><span class=\"line\">SubClass.prototype = new SuperClass();</span><br><span class=\"line\">// 子类原型方法</span><br><span class=\"line\">SubClass.prototype.getTime = function() &#123;</span><br><span class=\"line\">    console.log(this.time);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 测试</span><br><span class=\"line\">var instance1 = new SubClass(&apos;js book&apos;, 2017);</span><br><span class=\"line\">instance1.books.push(&apos;设计模式&apos;);</span><br><span class=\"line\">console.log(instance1.books);</span><br><span class=\"line\">instance1.getName();</span><br><span class=\"line\">instance1.getTime();</span><br><span class=\"line\">var instance2 = new SubClass(&apos;css book&apos;, 2018);</span><br><span class=\"line\">console.log(instance2.books);</span><br><span class=\"line\">instance2.getName();</span><br><span class=\"line\">instance2.getTime();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>结合了类式继承和构造函数继承两种方式的优点</p>\n<p>不足之处</p>\n</blockquote>\n<p>在使用构造函数继承时执行了一遍父类的构造函数，而在实现子类原型的类式继承式又调用了一遍父类的构造函数。因此父类构造函数调用了两遍。</p>\n<h3 id=\"洁净的继承者—原型式继承\"><a href=\"#洁净的继承者—原型式继承\" class=\"headerlink\" title=\"洁净的继承者—原型式继承\"></a>洁净的继承者—原型式继承</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function inheritObject(o) &#123;</span><br><span class=\"line\">    // 声明一个过渡函数对象</span><br><span class=\"line\">    function F() &#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>和类式继承有点像？？</p>\n</blockquote>\n<p>对，是对类式继承的一个封装，过渡对象相当于类式继承中的子类，只不过在原型式继承中作为一个过渡对象出现的，目的是为了创建要返回的新的实例化对象。</p>\n<blockquote>\n<p>??是不是类式继承中的问题在这里也会出现？？？</p>\n</blockquote>\n<p>是的，！！！，不过这种方式由于F过渡类的构造函数中无内容，所以开销比较小，使用起来也比较方便，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var book = &#123;</span><br><span class=\"line\">    name: &apos;js book&apos;,</span><br><span class=\"line\">    alikeBook: [&apos;css book&apos;, &apos;html book&apos;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var newBook = inheritObject(book)</span><br><span class=\"line\">newBook.name = &apos;ajax book&apos;</span><br><span class=\"line\">newBook.alikeBook.push(&apos;xml books&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">var otherBook = inheritObject(book)</span><br><span class=\"line\">otherBook.name = &apos;flash book&apos;</span><br><span class=\"line\">otherBook.alikeBook.push(&apos;as books&apos;)</span><br><span class=\"line\">console.log(newBook.name)</span><br><span class=\"line\">console.log(newBook.alikeBook)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(otherBook.name)</span><br><span class=\"line\">console.log(otherBook.alikeBook)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(book.name)</span><br><span class=\"line\">console.log(book.alikeBook)</span><br></pre></td></tr></table></figure>\n<p>和类式继承一样，父类对象book中的值类型的属性被复制，引用类型的属性被共用。</p>\n<h3 id=\"如虎添翼—寄生式继承\"><a href=\"#如虎添翼—寄生式继承\" class=\"headerlink\" title=\"如虎添翼—寄生式继承\"></a>如虎添翼—寄生式继承</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 寄生式继承</span><br><span class=\"line\">// 声明基对象</span><br><span class=\"line\">var book = &#123;</span><br><span class=\"line\">    name: &apos;js book&apos;,</span><br><span class=\"line\">    alikeBook: [&apos;css book&apos;, &apos;html book&apos;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function inheritObject(o) &#123;</span><br><span class=\"line\">    // 声明一个过渡函数对象</span><br><span class=\"line\">    function F() &#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// var c = new inheritObject(book);</span><br><span class=\"line\">// console.log(c)</span><br><span class=\"line\">function createBook(obj) &#123;</span><br><span class=\"line\">    // 通过原型继承方式创建新对象</span><br><span class=\"line\">    var o = new inheritObject(obj)</span><br><span class=\"line\">    // 拓展新对象</span><br><span class=\"line\">    o.getName = function() &#123;</span><br><span class=\"line\">        console.log(name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var a1  = createBook(book)</span><br><span class=\"line\">var a2  = createBook(book)</span><br><span class=\"line\">a1.alikeBook.push(&apos;设计模式&apos;)</span><br><span class=\"line\">console.log(a1.alikeBook)</span><br><span class=\"line\">console.log(a2.alikeBook)</span><br></pre></td></tr></table></figure>\n<p>其实寄生式继承就是对原型继承的第二次封装，并且在第二次封装的过程中对继承的对象进行了扩展，这样新创建的对象不仅仅有父类中的属性和方法而且还添加了新的属性和方法。</p>\n<h3 id=\"终极继承者—寄生组合式继承\"><a href=\"#终极继承者—寄生组合式继承\" class=\"headerlink\" title=\"终极继承者—寄生组合式继承\"></a>终极继承者—寄生组合式继承</h3><blockquote>\n<p>之前学习了组合继承，就是将类式继承通构造函数继承组合，这种方式存在的问题就是子类不是父类的实例，而子类的原型式父类的实例，因此才有了寄生组合式继承。是寄生式继承与构造函数继承的组合，但是这里寄生式继承有点特殊，这里他处理的不是对象，而是类的原型。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function inheritObject(o) &#123;</span><br><span class=\"line\">    // 声明一个过渡函数对象</span><br><span class=\"line\">    function F() &#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function inheritPrototype(SubClass, SuperClass) &#123;</span><br><span class=\"line\">    // 复制一份父类的原型副本保存在变量中</span><br><span class=\"line\">    var p = inheritObject(SuperClass.prototype);</span><br><span class=\"line\">    // 修正因为重写子原型导致子类的constructor属性被修改</span><br><span class=\"line\">    p.constructor = SubClass;</span><br><span class=\"line\">    // 设置子类的原型</span><br><span class=\"line\">    SubClass.prototype = p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在寄生组合式继承中，通过构造函数继承的属性和方法是没有问题的吗，这里主要探究通过寄生式继承重新继承父类的原型，我们需要继承的仅仅是父类的原型，不在需要调用父类的构造函数，换句话说，在构造函数继承中，我们已经调用了父类的构造函数，因此我们需要的就是父类的原型对象的一个副本，而这个副本我们我们通过原型继承便可得到，但是直接赋值个子类会有问题，因为对父类原型对象复制得到的复制对象p中的constroctor指向的不是SubClass子类对象，因此在寄生式继承中要对复制对象p做一次增强，修复其constroctor属性指向不正确问题，最后将得到的复制对象p赋值给子类的原型，这样子类的原型就继承了父类的原型并且没有执行父类的构造函数。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 寄生式继承  继承原型</span><br><span class=\"line\">// 传递参数  SuperClass  父了</span><br><span class=\"line\">// 传递参数  SubClass    子类</span><br><span class=\"line\"></span><br><span class=\"line\">function inheritObject(o) &#123;</span><br><span class=\"line\">    // 声明一个过渡函数对象</span><br><span class=\"line\">    function F() &#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function inheritPrototype(SubClass, SuperClass) &#123;</span><br><span class=\"line\">    // 复制一份父类的原型副本保存在变量中</span><br><span class=\"line\">    var p = inheritObject(SuperClass.prototype);</span><br><span class=\"line\">    // 修正因为重写子原型导致子类的constructor属性被修改</span><br><span class=\"line\">    p.constructor = SubClass;</span><br><span class=\"line\">    // 设置子类的原型</span><br><span class=\"line\">    SubClass.prototype = p;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">function SuperClass(name) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">    this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperClass.prototype.getName = function() &#123;</span><br><span class=\"line\">    console.log(this.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function SubClass(name, time) &#123;</span><br><span class=\"line\">    // 构造函数继承</span><br><span class=\"line\">    SuperClass.call(this, name)</span><br><span class=\"line\">    this.time = time</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 寄生式继承父类原型</span><br><span class=\"line\">inheritPrototype(SubClass, SuperClass)</span><br><span class=\"line\">SubClass.prototype.getTime = function() &#123;</span><br><span class=\"line\">    console.log(this.time)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 创建两个测试方法</span><br><span class=\"line\">var instance1 = new SubClass(&apos;js book&apos;, 2017);</span><br><span class=\"line\">var instance2 = new SubClass(&apos;css book&apos;, 2018);</span><br><span class=\"line\"></span><br><span class=\"line\">instance1.colors.push(&apos;black&apos;)</span><br><span class=\"line\">console.log(instance1.colors)</span><br><span class=\"line\">console.log(instance2.colors)</span><br><span class=\"line\">instance2.getName();</span><br><span class=\"line\">instance2.getTime();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这中继承最大的改变就是对子类原型的处理，被赋予父类原型的一个应用，这是一个对象，因此有一点要注意，就是子类在想添加原型方法必须通过prototype对象，通过点语法的形式一个个添加方法了，否则直接赋予对象就会覆盖掉从父类原型继承的对象了。</p>\n</blockquote>"},{"title":"创建型设计模式","date":"2017-11-20T13:03:20.000Z","_content":"\n> 创建型设计模式是一类处理对象创建的设计模式，通过某种方法控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度。\n\n<!-- more -->\n### 神奇的魔术师---简单工厂模式\n\n> 简单工厂模式，有叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例，主要用来创建同一类对象。\n\n```\n//例子  用登录注册提示\nvar LoginAlert = function(text) {\n    this.content = text;\n}\nLoginAlert.prototype.show = function() {\n    alert(this.content)\n}\nvar userNameAlert = new LoginAlert('用户名不能多于16个字母数字')\nuserNameAlert.show()\nvar passWordAlert = new LoginAlert('输入的密码不正确')\npassWordAlert.show()\n\nvar LoginConfirm = function(text) {\n    this.content = text;\n}\nLoginConfirm.prototype.show = function() {\n    alert(this.content)\n}\nvar loginFailConfirm = new LoginConfirm('用户名不能多于16个字母数字')\nloginFailConfirm.show();\n\n\nvar LoginPrompt = function(text) {\n    this.content = text;\n}\nLoginPrompt.prototype.show = function() {\n    alert(this.content)\n}\n// ...................\n```\n\n> 如果类太多，那么提供一个。\n\n别人想借用我的方法，写注册模块，缺点类名太多，其他人每次创建还要找到对应的类，太麻烦，而且是以login开头，最好封装在一个函数里，其他人只需要记住这个函数名，通过这个函数就可以创建我需要的对象为我所用，这个函数通常被称为工厂函数，这种模式叫简单工厂模式。\n\n```\nvar PopFactory= function(name) {\n    switch(name) {\n        case 'alert' :\n            return new LoginAlert()\n        case 'confirm' :\n            return new LoginConfirm()\n        case 'prompt' :\n            return new LoginPrompt()\n    }\n}\n// 这三个类有很多地方是相同的，是可以抽象提取出来共用的，也可用简单工厂方式实现它们。\n```\n\n> 一个对象有时也可代替许多类\n\n简单工厂模式的理念就是创建对象，上面这种方式是对不同的类实例化，除此之外简单工厂模式还可以用来创建相似对象，上面创建的几个类很多地方都比较相似，提取相似，针对不相似处理，\n\n```\nfunction createPop(type, text) {\n    var o = new Object();\n    o.content = text;\n    o.show= function() {\n        // 显示方法\n    };\n    if(type == 'alert') {\n        // 差异部分\n    }\n    if(type == 'prompt') {\n        // 差异部分\n    }\n    if(type == 'confirm') {\n        // 差异部分\n    }\n    return o;\n}\n// 调用，创建提示框\nvar userNameAlert = createPop('alert', '提示文字')\n```\n> 总结：两种创建方式区别，第一种通过实例化对象创建，如果这些类继承同一父类，父类原型上的方法可以共用，第二种通过创建一个新对象然后包装增强其属性和功能来实现，每个对象都是一个新的个体，方法不能共用，选择哪种看实际需求。\n\n### 给我一张名片---工厂方法模式\n\n> 通过对产品类的抽象使其创建业务主要负责用于创建多类产品的实例。\n\n```\n需求，新来一批广告资源需要投资，一批java,一批php等等，不同课程字体颜色和大小不同。\n\n// 简单工厂\nvar Java = function(content) {\n    // .......\n}\nvar Php = function(content) {\n    // .......\n}\nvar Javascript = function(content) {\n    // .......\n}\n// 学科工厂\nfunction JobFactory(type, content) {\n    switch(type) {\n        case 'java' : \n            return new Java(content)\n        case 'php' : \n            return new Php(content)\n        case 'Javascript' : \n            return new Javascript(content)\n    }\n}\n// 测试案例\nJobFactory('Javascript', 'content');\n\n```\n\n问题？又来一批课程，需求各不同，之前的需求一直在变，不仅要添加类，还要修改工厂函数，可能未来的需求还会在变。引申相互工厂方法模式，这样以后每需要一个类，只需要添加这个类。\n\n> 工厂方法模式本意是说将实际创建对象工作推迟到子类当中，这样核心类就成了抽象类，不过对应javascript不必这么深究，javascript没有像传统创建抽象类那样的方式轻易创建抽象了类，所以在javascript中实现工厂方法模式我们只需要参考它的核心思想即可，所以我们可以将工厂方法看做是一个实例化对象的工厂类，安全起见，我们采用安全模式类，而我们将创建对象的基类放在工厂方法类的原型中即可。\n\n#### 安全的工厂方法\n\n```\n// 安全模式创建的工厂类\nvar Factory = function(type, content) {\n    if(this instanceof Factory) {\n        var s = new this[type] (content);\n        return s;\n    } else {\n        return new Factory(type, content);\n    }\n}\n// 工厂原型中设置创建所用类型数据对象的基类\nFactory.prototype = {\n    Java: function(content) {\n        // ....\n    },\n    javascript: function(content) {\n        // ....\n    },\n    UI: function(content) {\n        this.content = content;\n        (function(content)) {\n            var div = documnet.createElement('div');\n            div.innerHTML = content;\n            div.style.border = '1pc solid #ccc';\n            document.getElementById('container').appendChild(div);\n        }\n    }(content)\n}\nvar data = [{type: 'java', content: 'jajaja'},{type: 'php', content: 'phphphp'}]\ndata.map(function(item) {\n    Factory(item.type, item.content);\n})\n```\n> 优点，如果添加类，只需在Factory.prototype中添加，适用于创建多类对象，同时避免使用者与对象之间的耦合，用户不必关心创建该对象的具体类，只需调用工厂方法即可。\n\n### 出现的都是幻觉---抽象工厂模式\n\n> 通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建每一类产品的实例。\n\n抽象工厂模式一般不用来创建具体对象，一般用它作为父类来创建一个子类。\n\n```\n// 抽象工厂方法\nvar VericleFactory = function(subType, superType) {\n    // 判断抽象工厂中是否有该抽象类\n    if(typeof VericleFactory[superType] === 'function') {\n        function F() {}\n        // 继承父类属性方法\n        F.prototype = new VericleFactory[superType]();\n        // 将子类constructor指向子类\n        subType.constructor = superType;\n        // 子类原型继承父类\n        subType.prototype = new F();\n    } else {\n        // 不存在该抽象类抛出错误 \n        return new Error('未创建该抽象类')\n    }   \n}\n// 某一个车的抽象类\nVericleFactory.Truck = function() {\n    this.type = 'truck'\n}\nVericleFactory.Truck.prototype = {\n    getPrice: function() {\n        return new Error('抽象方法不可调用')\n    },\n    getTrainload: function() {\n        return new Error('抽象方法不可调用')\n    }\n}\n// 奔驰汽车子类\nvar BenzTruck = function(price, trainLoad) {\n    this.price = price;\n    this.trainLoad = trainLoad;\n}\n// 抽象方法实现对Truck抽象类的继承\nVericleFactory(BenzTruck, \"Truck\");\nBenzTruck.prototype.getPrice = function() {\n    return this.price;\n}\nBenzTruck.prototype.getTrainload = function() {\n    return this.getTrainload;\n}\n// 测试\nvar truck = new BenzTruck(100, 10000);\nconsole.log(truck.getPrice)   // 100\nconsole.log(truck.type)       // truck\n\n```\n\n> 总结：抽象工厂模式是设计模式中最抽象的一种，也是创建模式中唯一一种抽象化创建模式，该模式创建出的结果不是一个真实的对象实例，而是一个类簇，它制定了类的结构，这也就区别于简单工厂模式创建单一对象，工厂方法模式创建多类对象，当然由于JavaScript中不支持抽象化创建与虚拟方法，所以导致这种模式不能像其他面向对象语言中应用的那么广泛。\n\n### 分即是合---建造者模式\n\n> 将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示。\n\n创建对象的另一种新式：建造者模式\n\n建造者模式更注重的是创建的细节。\n\n### 语言之魂---原型模式\n\n> 用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法。\n\n```\nfunction prototypeExtend() {\n  var F = function() {},\n  args = arguments,\n    i = 0,\n    len = args.length;\n    // console.log(arguments)\n  for (; i < len; i++) {\n    for (var j in args[i]) {\n      F.prototype[j] = args[i][j];\n      console.log(F.prototype)\n    }\n  }\n  return new F();\n}\n\nvar penguin = prototypeExtend(\n  {\n    speed: 20,\n    swim: function() {\n      console.log(\".......1\");\n    }\n  },\n  {\n    sd: 300,\n    run: function(speed) {\n      console.log(\"......2\"+ speed);\n    }\n  },\n  {\n    jump: function() {\n      console.log(\".........3\");\n    }\n  }\n);\npenguin.swim()\npenguin.run(10)\npenguin.jump()\n\n```\n\n> 总结：原型模式可以让多个对象分享同一个原型对象的属性和方法，这也是一种继承方式，不过这种继承的实现是不需要创建的，而是将原型对象分享给那些继承的对象，当然有时需要让每个继承对象独立拥有一份原型对象，此时我们就需要对原型对象进行复制。\n\n由此可以看出，原型对象更适合在创建复杂的对象时，对于那些需求一直在变化而导致对象结构不停的改变时，将那些比较稳定的属性与方法共用而提取的继承的实现。\n\n### 一个人的寂寞---单例模式\n\n> 单例模式：有被称为单体模式，是只允许实例化一次的对象类，有时我们也用一个对象来规划一个命名空间，井井有条地管理对象上的属性个方法。\n\nJavaScript中最常见的一种模式，这种模式经常为我们提供一个命名空间，如我们使用过的jQuery库，单例模式就为它提供利润一个命名空间jQuery。\n\n> 命名空间？？？？\n\n就是nameSpace，解决一类问题：为了让代码更易懂，人们常常用单词或者拼音定义变量或者方法，但由于有限的单词量，所以不同的人定义的变量使用的单词名称很有可能重复，此时就需要用命名空间来约束每个人定义的变量来解决这类问题。\n\n```\nfunction g(id) {\n    return document.getElementById(id)\n}\nfunction css(id, key, value) {\n    g(id).style[key] = value;\n}\nfunction on(id ,type, fn) {\n    g(id)['on' + type] = fn;\n}\n// ................\n\n// 命名空间\nvar My = {\n    g: function() {\n        return document.getElementById(id)\n    },\n    css: function() {\n        this.g(id).style[key] = value;\n    },\n    on: function() {\n        this.g(id)['on' + type] = fn;\n    }\n}\n\n```\n> 单例模式的其他作用：就是通过单例模式来控制自己的每个功能模块。\n\n> 创建一个小型代码库\n\n```\nvar A= {\n    Util: {\n        util_1: function() {},\n         util_2: function() {}\n    },\n    Tool: {\n        tool_1: function() {},\n        tool_2: function() {}\n    },\n    Ajax: function () {\n        ajax_1: function() {},\n        ajax_2: function() {}\n    }\n}\n\nA.Util.util_1();\n// ........\n\n```\n> 无法修改的静态变量\n\n用单例模式管理静态变量\n\n```\nvar Conf = (function() {\n    var conf = {\n        MAX_NUM: 100,\n        MIN_NUM: 1,\n        COUNT: 1000\n    }\n    return {\n        get: function(name) {\n            return conf[name] ? conf[name] : null\n        }\n    }\n})()\nvar COUNT = Conf.get('COUNT')\n\n```\n> 惰性单例\n\n有时候对于单例对象需要延迟创建，所以在单例中还存在一种延迟创建的形式，有人也称之为‘惰性创建’。\n\n```\n// 惰性载入单例\nvar LazySingle = (function() {\n    // 单例实例引用\n    var instance = null;\n    // 单例\n    function Single() {\n        // 这里定义私有属性和方法\n        return {\n            publicMethod: function() {},\n            punlicProperty: '1.0'\n        }\n    }\n    // 获取单例对象接口\n    if(!instance) {\n        instance = Single()\n    }\n    // 返回单例\n    return instance;\n} )()\n\nconsole.log(LazySingle().punlicProperty);  // 1.0\n\n```\n","source":"_posts/javascript/创建型设计模式.md","raw":"---\ntitle: 创建型设计模式\ncategories:\n  - javascript设计模式\ntags:\n  - 创建型设计模式\ndate: 2017-11-20 21:03:20\n---\n\n> 创建型设计模式是一类处理对象创建的设计模式，通过某种方法控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度。\n\n<!-- more -->\n### 神奇的魔术师---简单工厂模式\n\n> 简单工厂模式，有叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例，主要用来创建同一类对象。\n\n```\n//例子  用登录注册提示\nvar LoginAlert = function(text) {\n    this.content = text;\n}\nLoginAlert.prototype.show = function() {\n    alert(this.content)\n}\nvar userNameAlert = new LoginAlert('用户名不能多于16个字母数字')\nuserNameAlert.show()\nvar passWordAlert = new LoginAlert('输入的密码不正确')\npassWordAlert.show()\n\nvar LoginConfirm = function(text) {\n    this.content = text;\n}\nLoginConfirm.prototype.show = function() {\n    alert(this.content)\n}\nvar loginFailConfirm = new LoginConfirm('用户名不能多于16个字母数字')\nloginFailConfirm.show();\n\n\nvar LoginPrompt = function(text) {\n    this.content = text;\n}\nLoginPrompt.prototype.show = function() {\n    alert(this.content)\n}\n// ...................\n```\n\n> 如果类太多，那么提供一个。\n\n别人想借用我的方法，写注册模块，缺点类名太多，其他人每次创建还要找到对应的类，太麻烦，而且是以login开头，最好封装在一个函数里，其他人只需要记住这个函数名，通过这个函数就可以创建我需要的对象为我所用，这个函数通常被称为工厂函数，这种模式叫简单工厂模式。\n\n```\nvar PopFactory= function(name) {\n    switch(name) {\n        case 'alert' :\n            return new LoginAlert()\n        case 'confirm' :\n            return new LoginConfirm()\n        case 'prompt' :\n            return new LoginPrompt()\n    }\n}\n// 这三个类有很多地方是相同的，是可以抽象提取出来共用的，也可用简单工厂方式实现它们。\n```\n\n> 一个对象有时也可代替许多类\n\n简单工厂模式的理念就是创建对象，上面这种方式是对不同的类实例化，除此之外简单工厂模式还可以用来创建相似对象，上面创建的几个类很多地方都比较相似，提取相似，针对不相似处理，\n\n```\nfunction createPop(type, text) {\n    var o = new Object();\n    o.content = text;\n    o.show= function() {\n        // 显示方法\n    };\n    if(type == 'alert') {\n        // 差异部分\n    }\n    if(type == 'prompt') {\n        // 差异部分\n    }\n    if(type == 'confirm') {\n        // 差异部分\n    }\n    return o;\n}\n// 调用，创建提示框\nvar userNameAlert = createPop('alert', '提示文字')\n```\n> 总结：两种创建方式区别，第一种通过实例化对象创建，如果这些类继承同一父类，父类原型上的方法可以共用，第二种通过创建一个新对象然后包装增强其属性和功能来实现，每个对象都是一个新的个体，方法不能共用，选择哪种看实际需求。\n\n### 给我一张名片---工厂方法模式\n\n> 通过对产品类的抽象使其创建业务主要负责用于创建多类产品的实例。\n\n```\n需求，新来一批广告资源需要投资，一批java,一批php等等，不同课程字体颜色和大小不同。\n\n// 简单工厂\nvar Java = function(content) {\n    // .......\n}\nvar Php = function(content) {\n    // .......\n}\nvar Javascript = function(content) {\n    // .......\n}\n// 学科工厂\nfunction JobFactory(type, content) {\n    switch(type) {\n        case 'java' : \n            return new Java(content)\n        case 'php' : \n            return new Php(content)\n        case 'Javascript' : \n            return new Javascript(content)\n    }\n}\n// 测试案例\nJobFactory('Javascript', 'content');\n\n```\n\n问题？又来一批课程，需求各不同，之前的需求一直在变，不仅要添加类，还要修改工厂函数，可能未来的需求还会在变。引申相互工厂方法模式，这样以后每需要一个类，只需要添加这个类。\n\n> 工厂方法模式本意是说将实际创建对象工作推迟到子类当中，这样核心类就成了抽象类，不过对应javascript不必这么深究，javascript没有像传统创建抽象类那样的方式轻易创建抽象了类，所以在javascript中实现工厂方法模式我们只需要参考它的核心思想即可，所以我们可以将工厂方法看做是一个实例化对象的工厂类，安全起见，我们采用安全模式类，而我们将创建对象的基类放在工厂方法类的原型中即可。\n\n#### 安全的工厂方法\n\n```\n// 安全模式创建的工厂类\nvar Factory = function(type, content) {\n    if(this instanceof Factory) {\n        var s = new this[type] (content);\n        return s;\n    } else {\n        return new Factory(type, content);\n    }\n}\n// 工厂原型中设置创建所用类型数据对象的基类\nFactory.prototype = {\n    Java: function(content) {\n        // ....\n    },\n    javascript: function(content) {\n        // ....\n    },\n    UI: function(content) {\n        this.content = content;\n        (function(content)) {\n            var div = documnet.createElement('div');\n            div.innerHTML = content;\n            div.style.border = '1pc solid #ccc';\n            document.getElementById('container').appendChild(div);\n        }\n    }(content)\n}\nvar data = [{type: 'java', content: 'jajaja'},{type: 'php', content: 'phphphp'}]\ndata.map(function(item) {\n    Factory(item.type, item.content);\n})\n```\n> 优点，如果添加类，只需在Factory.prototype中添加，适用于创建多类对象，同时避免使用者与对象之间的耦合，用户不必关心创建该对象的具体类，只需调用工厂方法即可。\n\n### 出现的都是幻觉---抽象工厂模式\n\n> 通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建每一类产品的实例。\n\n抽象工厂模式一般不用来创建具体对象，一般用它作为父类来创建一个子类。\n\n```\n// 抽象工厂方法\nvar VericleFactory = function(subType, superType) {\n    // 判断抽象工厂中是否有该抽象类\n    if(typeof VericleFactory[superType] === 'function') {\n        function F() {}\n        // 继承父类属性方法\n        F.prototype = new VericleFactory[superType]();\n        // 将子类constructor指向子类\n        subType.constructor = superType;\n        // 子类原型继承父类\n        subType.prototype = new F();\n    } else {\n        // 不存在该抽象类抛出错误 \n        return new Error('未创建该抽象类')\n    }   \n}\n// 某一个车的抽象类\nVericleFactory.Truck = function() {\n    this.type = 'truck'\n}\nVericleFactory.Truck.prototype = {\n    getPrice: function() {\n        return new Error('抽象方法不可调用')\n    },\n    getTrainload: function() {\n        return new Error('抽象方法不可调用')\n    }\n}\n// 奔驰汽车子类\nvar BenzTruck = function(price, trainLoad) {\n    this.price = price;\n    this.trainLoad = trainLoad;\n}\n// 抽象方法实现对Truck抽象类的继承\nVericleFactory(BenzTruck, \"Truck\");\nBenzTruck.prototype.getPrice = function() {\n    return this.price;\n}\nBenzTruck.prototype.getTrainload = function() {\n    return this.getTrainload;\n}\n// 测试\nvar truck = new BenzTruck(100, 10000);\nconsole.log(truck.getPrice)   // 100\nconsole.log(truck.type)       // truck\n\n```\n\n> 总结：抽象工厂模式是设计模式中最抽象的一种，也是创建模式中唯一一种抽象化创建模式，该模式创建出的结果不是一个真实的对象实例，而是一个类簇，它制定了类的结构，这也就区别于简单工厂模式创建单一对象，工厂方法模式创建多类对象，当然由于JavaScript中不支持抽象化创建与虚拟方法，所以导致这种模式不能像其他面向对象语言中应用的那么广泛。\n\n### 分即是合---建造者模式\n\n> 将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示。\n\n创建对象的另一种新式：建造者模式\n\n建造者模式更注重的是创建的细节。\n\n### 语言之魂---原型模式\n\n> 用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法。\n\n```\nfunction prototypeExtend() {\n  var F = function() {},\n  args = arguments,\n    i = 0,\n    len = args.length;\n    // console.log(arguments)\n  for (; i < len; i++) {\n    for (var j in args[i]) {\n      F.prototype[j] = args[i][j];\n      console.log(F.prototype)\n    }\n  }\n  return new F();\n}\n\nvar penguin = prototypeExtend(\n  {\n    speed: 20,\n    swim: function() {\n      console.log(\".......1\");\n    }\n  },\n  {\n    sd: 300,\n    run: function(speed) {\n      console.log(\"......2\"+ speed);\n    }\n  },\n  {\n    jump: function() {\n      console.log(\".........3\");\n    }\n  }\n);\npenguin.swim()\npenguin.run(10)\npenguin.jump()\n\n```\n\n> 总结：原型模式可以让多个对象分享同一个原型对象的属性和方法，这也是一种继承方式，不过这种继承的实现是不需要创建的，而是将原型对象分享给那些继承的对象，当然有时需要让每个继承对象独立拥有一份原型对象，此时我们就需要对原型对象进行复制。\n\n由此可以看出，原型对象更适合在创建复杂的对象时，对于那些需求一直在变化而导致对象结构不停的改变时，将那些比较稳定的属性与方法共用而提取的继承的实现。\n\n### 一个人的寂寞---单例模式\n\n> 单例模式：有被称为单体模式，是只允许实例化一次的对象类，有时我们也用一个对象来规划一个命名空间，井井有条地管理对象上的属性个方法。\n\nJavaScript中最常见的一种模式，这种模式经常为我们提供一个命名空间，如我们使用过的jQuery库，单例模式就为它提供利润一个命名空间jQuery。\n\n> 命名空间？？？？\n\n就是nameSpace，解决一类问题：为了让代码更易懂，人们常常用单词或者拼音定义变量或者方法，但由于有限的单词量，所以不同的人定义的变量使用的单词名称很有可能重复，此时就需要用命名空间来约束每个人定义的变量来解决这类问题。\n\n```\nfunction g(id) {\n    return document.getElementById(id)\n}\nfunction css(id, key, value) {\n    g(id).style[key] = value;\n}\nfunction on(id ,type, fn) {\n    g(id)['on' + type] = fn;\n}\n// ................\n\n// 命名空间\nvar My = {\n    g: function() {\n        return document.getElementById(id)\n    },\n    css: function() {\n        this.g(id).style[key] = value;\n    },\n    on: function() {\n        this.g(id)['on' + type] = fn;\n    }\n}\n\n```\n> 单例模式的其他作用：就是通过单例模式来控制自己的每个功能模块。\n\n> 创建一个小型代码库\n\n```\nvar A= {\n    Util: {\n        util_1: function() {},\n         util_2: function() {}\n    },\n    Tool: {\n        tool_1: function() {},\n        tool_2: function() {}\n    },\n    Ajax: function () {\n        ajax_1: function() {},\n        ajax_2: function() {}\n    }\n}\n\nA.Util.util_1();\n// ........\n\n```\n> 无法修改的静态变量\n\n用单例模式管理静态变量\n\n```\nvar Conf = (function() {\n    var conf = {\n        MAX_NUM: 100,\n        MIN_NUM: 1,\n        COUNT: 1000\n    }\n    return {\n        get: function(name) {\n            return conf[name] ? conf[name] : null\n        }\n    }\n})()\nvar COUNT = Conf.get('COUNT')\n\n```\n> 惰性单例\n\n有时候对于单例对象需要延迟创建，所以在单例中还存在一种延迟创建的形式，有人也称之为‘惰性创建’。\n\n```\n// 惰性载入单例\nvar LazySingle = (function() {\n    // 单例实例引用\n    var instance = null;\n    // 单例\n    function Single() {\n        // 这里定义私有属性和方法\n        return {\n            publicMethod: function() {},\n            punlicProperty: '1.0'\n        }\n    }\n    // 获取单例对象接口\n    if(!instance) {\n        instance = Single()\n    }\n    // 返回单例\n    return instance;\n} )()\n\nconsole.log(LazySingle().punlicProperty);  // 1.0\n\n```\n","slug":"javascript/创建型设计模式","published":1,"updated":"2017-11-30T08:52:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaqhv1gg0008btx1hnvvrqg2","content":"<blockquote>\n<p>创建型设计模式是一类处理对象创建的设计模式，通过某种方法控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"神奇的魔术师—简单工厂模式\"><a href=\"#神奇的魔术师—简单工厂模式\" class=\"headerlink\" title=\"神奇的魔术师—简单工厂模式\"></a>神奇的魔术师—简单工厂模式</h3><blockquote>\n<p>简单工厂模式，有叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例，主要用来创建同一类对象。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//例子  用登录注册提示</span><br><span class=\"line\">var LoginAlert = function(text) &#123;</span><br><span class=\"line\">    this.content = text;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">LoginAlert.prototype.show = function() &#123;</span><br><span class=\"line\">    alert(this.content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var userNameAlert = new LoginAlert(&apos;用户名不能多于16个字母数字&apos;)</span><br><span class=\"line\">userNameAlert.show()</span><br><span class=\"line\">var passWordAlert = new LoginAlert(&apos;输入的密码不正确&apos;)</span><br><span class=\"line\">passWordAlert.show()</span><br><span class=\"line\"></span><br><span class=\"line\">var LoginConfirm = function(text) &#123;</span><br><span class=\"line\">    this.content = text;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">LoginConfirm.prototype.show = function() &#123;</span><br><span class=\"line\">    alert(this.content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var loginFailConfirm = new LoginConfirm(&apos;用户名不能多于16个字母数字&apos;)</span><br><span class=\"line\">loginFailConfirm.show();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var LoginPrompt = function(text) &#123;</span><br><span class=\"line\">    this.content = text;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">LoginPrompt.prototype.show = function() &#123;</span><br><span class=\"line\">    alert(this.content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// ...................</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果类太多，那么提供一个。</p>\n</blockquote>\n<p>别人想借用我的方法，写注册模块，缺点类名太多，其他人每次创建还要找到对应的类，太麻烦，而且是以login开头，最好封装在一个函数里，其他人只需要记住这个函数名，通过这个函数就可以创建我需要的对象为我所用，这个函数通常被称为工厂函数，这种模式叫简单工厂模式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var PopFactory= function(name) &#123;</span><br><span class=\"line\">    switch(name) &#123;</span><br><span class=\"line\">        case &apos;alert&apos; :</span><br><span class=\"line\">            return new LoginAlert()</span><br><span class=\"line\">        case &apos;confirm&apos; :</span><br><span class=\"line\">            return new LoginConfirm()</span><br><span class=\"line\">        case &apos;prompt&apos; :</span><br><span class=\"line\">            return new LoginPrompt()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 这三个类有很多地方是相同的，是可以抽象提取出来共用的，也可用简单工厂方式实现它们。</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>一个对象有时也可代替许多类</p>\n</blockquote>\n<p>简单工厂模式的理念就是创建对象，上面这种方式是对不同的类实例化，除此之外简单工厂模式还可以用来创建相似对象，上面创建的几个类很多地方都比较相似，提取相似，针对不相似处理，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createPop(type, text) &#123;</span><br><span class=\"line\">    var o = new Object();</span><br><span class=\"line\">    o.content = text;</span><br><span class=\"line\">    o.show= function() &#123;</span><br><span class=\"line\">        // 显示方法</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    if(type == &apos;alert&apos;) &#123;</span><br><span class=\"line\">        // 差异部分</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(type == &apos;prompt&apos;) &#123;</span><br><span class=\"line\">        // 差异部分</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(type == &apos;confirm&apos;) &#123;</span><br><span class=\"line\">        // 差异部分</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 调用，创建提示框</span><br><span class=\"line\">var userNameAlert = createPop(&apos;alert&apos;, &apos;提示文字&apos;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>总结：两种创建方式区别，第一种通过实例化对象创建，如果这些类继承同一父类，父类原型上的方法可以共用，第二种通过创建一个新对象然后包装增强其属性和功能来实现，每个对象都是一个新的个体，方法不能共用，选择哪种看实际需求。</p>\n</blockquote>\n<h3 id=\"给我一张名片—工厂方法模式\"><a href=\"#给我一张名片—工厂方法模式\" class=\"headerlink\" title=\"给我一张名片—工厂方法模式\"></a>给我一张名片—工厂方法模式</h3><blockquote>\n<p>通过对产品类的抽象使其创建业务主要负责用于创建多类产品的实例。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">需求，新来一批广告资源需要投资，一批java,一批php等等，不同课程字体颜色和大小不同。</span><br><span class=\"line\"></span><br><span class=\"line\">// 简单工厂</span><br><span class=\"line\">var Java = function(content) &#123;</span><br><span class=\"line\">    // .......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var Php = function(content) &#123;</span><br><span class=\"line\">    // .......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var Javascript = function(content) &#123;</span><br><span class=\"line\">    // .......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 学科工厂</span><br><span class=\"line\">function JobFactory(type, content) &#123;</span><br><span class=\"line\">    switch(type) &#123;</span><br><span class=\"line\">        case &apos;java&apos; : </span><br><span class=\"line\">            return new Java(content)</span><br><span class=\"line\">        case &apos;php&apos; : </span><br><span class=\"line\">            return new Php(content)</span><br><span class=\"line\">        case &apos;Javascript&apos; : </span><br><span class=\"line\">            return new Javascript(content)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 测试案例</span><br><span class=\"line\">JobFactory(&apos;Javascript&apos;, &apos;content&apos;);</span><br></pre></td></tr></table></figure>\n<p>问题？又来一批课程，需求各不同，之前的需求一直在变，不仅要添加类，还要修改工厂函数，可能未来的需求还会在变。引申相互工厂方法模式，这样以后每需要一个类，只需要添加这个类。</p>\n<blockquote>\n<p>工厂方法模式本意是说将实际创建对象工作推迟到子类当中，这样核心类就成了抽象类，不过对应javascript不必这么深究，javascript没有像传统创建抽象类那样的方式轻易创建抽象了类，所以在javascript中实现工厂方法模式我们只需要参考它的核心思想即可，所以我们可以将工厂方法看做是一个实例化对象的工厂类，安全起见，我们采用安全模式类，而我们将创建对象的基类放在工厂方法类的原型中即可。</p>\n</blockquote>\n<h4 id=\"安全的工厂方法\"><a href=\"#安全的工厂方法\" class=\"headerlink\" title=\"安全的工厂方法\"></a>安全的工厂方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 安全模式创建的工厂类</span><br><span class=\"line\">var Factory = function(type, content) &#123;</span><br><span class=\"line\">    if(this instanceof Factory) &#123;</span><br><span class=\"line\">        var s = new this[type] (content);</span><br><span class=\"line\">        return s;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return new Factory(type, content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 工厂原型中设置创建所用类型数据对象的基类</span><br><span class=\"line\">Factory.prototype = &#123;</span><br><span class=\"line\">    Java: function(content) &#123;</span><br><span class=\"line\">        // ....</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    javascript: function(content) &#123;</span><br><span class=\"line\">        // ....</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    UI: function(content) &#123;</span><br><span class=\"line\">        this.content = content;</span><br><span class=\"line\">        (function(content)) &#123;</span><br><span class=\"line\">            var div = documnet.createElement(&apos;div&apos;);</span><br><span class=\"line\">            div.innerHTML = content;</span><br><span class=\"line\">            div.style.border = &apos;1pc solid #ccc&apos;;</span><br><span class=\"line\">            document.getElementById(&apos;container&apos;).appendChild(div);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;(content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var data = [&#123;type: &apos;java&apos;, content: &apos;jajaja&apos;&#125;,&#123;type: &apos;php&apos;, content: &apos;phphphp&apos;&#125;]</span><br><span class=\"line\">data.map(function(item) &#123;</span><br><span class=\"line\">    Factory(item.type, item.content);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>优点，如果添加类，只需在Factory.prototype中添加，适用于创建多类对象，同时避免使用者与对象之间的耦合，用户不必关心创建该对象的具体类，只需调用工厂方法即可。</p>\n</blockquote>\n<h3 id=\"出现的都是幻觉—抽象工厂模式\"><a href=\"#出现的都是幻觉—抽象工厂模式\" class=\"headerlink\" title=\"出现的都是幻觉—抽象工厂模式\"></a>出现的都是幻觉—抽象工厂模式</h3><blockquote>\n<p>通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建每一类产品的实例。</p>\n</blockquote>\n<p>抽象工厂模式一般不用来创建具体对象，一般用它作为父类来创建一个子类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 抽象工厂方法</span><br><span class=\"line\">var VericleFactory = function(subType, superType) &#123;</span><br><span class=\"line\">    // 判断抽象工厂中是否有该抽象类</span><br><span class=\"line\">    if(typeof VericleFactory[superType] === &apos;function&apos;) &#123;</span><br><span class=\"line\">        function F() &#123;&#125;</span><br><span class=\"line\">        // 继承父类属性方法</span><br><span class=\"line\">        F.prototype = new VericleFactory[superType]();</span><br><span class=\"line\">        // 将子类constructor指向子类</span><br><span class=\"line\">        subType.constructor = superType;</span><br><span class=\"line\">        // 子类原型继承父类</span><br><span class=\"line\">        subType.prototype = new F();</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        // 不存在该抽象类抛出错误 </span><br><span class=\"line\">        return new Error(&apos;未创建该抽象类&apos;)</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 某一个车的抽象类</span><br><span class=\"line\">VericleFactory.Truck = function() &#123;</span><br><span class=\"line\">    this.type = &apos;truck&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">VericleFactory.Truck.prototype = &#123;</span><br><span class=\"line\">    getPrice: function() &#123;</span><br><span class=\"line\">        return new Error(&apos;抽象方法不可调用&apos;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getTrainload: function() &#123;</span><br><span class=\"line\">        return new Error(&apos;抽象方法不可调用&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 奔驰汽车子类</span><br><span class=\"line\">var BenzTruck = function(price, trainLoad) &#123;</span><br><span class=\"line\">    this.price = price;</span><br><span class=\"line\">    this.trainLoad = trainLoad;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 抽象方法实现对Truck抽象类的继承</span><br><span class=\"line\">VericleFactory(BenzTruck, &quot;Truck&quot;);</span><br><span class=\"line\">BenzTruck.prototype.getPrice = function() &#123;</span><br><span class=\"line\">    return this.price;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">BenzTruck.prototype.getTrainload = function() &#123;</span><br><span class=\"line\">    return this.getTrainload;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 测试</span><br><span class=\"line\">var truck = new BenzTruck(100, 10000);</span><br><span class=\"line\">console.log(truck.getPrice)   // 100</span><br><span class=\"line\">console.log(truck.type)       // truck</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>总结：抽象工厂模式是设计模式中最抽象的一种，也是创建模式中唯一一种抽象化创建模式，该模式创建出的结果不是一个真实的对象实例，而是一个类簇，它制定了类的结构，这也就区别于简单工厂模式创建单一对象，工厂方法模式创建多类对象，当然由于JavaScript中不支持抽象化创建与虚拟方法，所以导致这种模式不能像其他面向对象语言中应用的那么广泛。</p>\n</blockquote>\n<h3 id=\"分即是合—建造者模式\"><a href=\"#分即是合—建造者模式\" class=\"headerlink\" title=\"分即是合—建造者模式\"></a>分即是合—建造者模式</h3><blockquote>\n<p>将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示。</p>\n</blockquote>\n<p>创建对象的另一种新式：建造者模式</p>\n<p>建造者模式更注重的是创建的细节。</p>\n<h3 id=\"语言之魂—原型模式\"><a href=\"#语言之魂—原型模式\" class=\"headerlink\" title=\"语言之魂—原型模式\"></a>语言之魂—原型模式</h3><blockquote>\n<p>用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function prototypeExtend() &#123;</span><br><span class=\"line\">  var F = function() &#123;&#125;,</span><br><span class=\"line\">  args = arguments,</span><br><span class=\"line\">    i = 0,</span><br><span class=\"line\">    len = args.length;</span><br><span class=\"line\">    // console.log(arguments)</span><br><span class=\"line\">  for (; i &lt; len; i++) &#123;</span><br><span class=\"line\">    for (var j in args[i]) &#123;</span><br><span class=\"line\">      F.prototype[j] = args[i][j];</span><br><span class=\"line\">      console.log(F.prototype)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var penguin = prototypeExtend(</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    speed: 20,</span><br><span class=\"line\">    swim: function() &#123;</span><br><span class=\"line\">      console.log(&quot;.......1&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    sd: 300,</span><br><span class=\"line\">    run: function(speed) &#123;</span><br><span class=\"line\">      console.log(&quot;......2&quot;+ speed);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    jump: function() &#123;</span><br><span class=\"line\">      console.log(&quot;.........3&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\">penguin.swim()</span><br><span class=\"line\">penguin.run(10)</span><br><span class=\"line\">penguin.jump()</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>总结：原型模式可以让多个对象分享同一个原型对象的属性和方法，这也是一种继承方式，不过这种继承的实现是不需要创建的，而是将原型对象分享给那些继承的对象，当然有时需要让每个继承对象独立拥有一份原型对象，此时我们就需要对原型对象进行复制。</p>\n</blockquote>\n<p>由此可以看出，原型对象更适合在创建复杂的对象时，对于那些需求一直在变化而导致对象结构不停的改变时，将那些比较稳定的属性与方法共用而提取的继承的实现。</p>\n<h3 id=\"一个人的寂寞—单例模式\"><a href=\"#一个人的寂寞—单例模式\" class=\"headerlink\" title=\"一个人的寂寞—单例模式\"></a>一个人的寂寞—单例模式</h3><blockquote>\n<p>单例模式：有被称为单体模式，是只允许实例化一次的对象类，有时我们也用一个对象来规划一个命名空间，井井有条地管理对象上的属性个方法。</p>\n</blockquote>\n<p>JavaScript中最常见的一种模式，这种模式经常为我们提供一个命名空间，如我们使用过的jQuery库，单例模式就为它提供利润一个命名空间jQuery。</p>\n<blockquote>\n<p>命名空间？？？？</p>\n</blockquote>\n<p>就是nameSpace，解决一类问题：为了让代码更易懂，人们常常用单词或者拼音定义变量或者方法，但由于有限的单词量，所以不同的人定义的变量使用的单词名称很有可能重复，此时就需要用命名空间来约束每个人定义的变量来解决这类问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function g(id) &#123;</span><br><span class=\"line\">    return document.getElementById(id)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function css(id, key, value) &#123;</span><br><span class=\"line\">    g(id).style[key] = value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function on(id ,type, fn) &#123;</span><br><span class=\"line\">    g(id)[&apos;on&apos; + type] = fn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// ................</span><br><span class=\"line\"></span><br><span class=\"line\">// 命名空间</span><br><span class=\"line\">var My = &#123;</span><br><span class=\"line\">    g: function() &#123;</span><br><span class=\"line\">        return document.getElementById(id)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    css: function() &#123;</span><br><span class=\"line\">        this.g(id).style[key] = value;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    on: function() &#123;</span><br><span class=\"line\">        this.g(id)[&apos;on&apos; + type] = fn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>单例模式的其他作用：就是通过单例模式来控制自己的每个功能模块。</p>\n<p>创建一个小型代码库</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var A= &#123;</span><br><span class=\"line\">    Util: &#123;</span><br><span class=\"line\">        util_1: function() &#123;&#125;,</span><br><span class=\"line\">         util_2: function() &#123;&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    Tool: &#123;</span><br><span class=\"line\">        tool_1: function() &#123;&#125;,</span><br><span class=\"line\">        tool_2: function() &#123;&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    Ajax: function () &#123;</span><br><span class=\"line\">        ajax_1: function() &#123;&#125;,</span><br><span class=\"line\">        ajax_2: function() &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">A.Util.util_1();</span><br><span class=\"line\">// ........</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>无法修改的静态变量</p>\n</blockquote>\n<p>用单例模式管理静态变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Conf = (function() &#123;</span><br><span class=\"line\">    var conf = &#123;</span><br><span class=\"line\">        MAX_NUM: 100,</span><br><span class=\"line\">        MIN_NUM: 1,</span><br><span class=\"line\">        COUNT: 1000</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        get: function(name) &#123;</span><br><span class=\"line\">            return conf[name] ? conf[name] : null</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\">var COUNT = Conf.get(&apos;COUNT&apos;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>惰性单例</p>\n</blockquote>\n<p>有时候对于单例对象需要延迟创建，所以在单例中还存在一种延迟创建的形式，有人也称之为‘惰性创建’。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 惰性载入单例</span><br><span class=\"line\">var LazySingle = (function() &#123;</span><br><span class=\"line\">    // 单例实例引用</span><br><span class=\"line\">    var instance = null;</span><br><span class=\"line\">    // 单例</span><br><span class=\"line\">    function Single() &#123;</span><br><span class=\"line\">        // 这里定义私有属性和方法</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            publicMethod: function() &#123;&#125;,</span><br><span class=\"line\">            punlicProperty: &apos;1.0&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 获取单例对象接口</span><br><span class=\"line\">    if(!instance) &#123;</span><br><span class=\"line\">        instance = Single()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 返回单例</span><br><span class=\"line\">    return instance;</span><br><span class=\"line\">&#125; )()</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(LazySingle().punlicProperty);  // 1.0</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>创建型设计模式是一类处理对象创建的设计模式，通过某种方法控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度。</p>\n</blockquote>","more":"<h3 id=\"神奇的魔术师—简单工厂模式\"><a href=\"#神奇的魔术师—简单工厂模式\" class=\"headerlink\" title=\"神奇的魔术师—简单工厂模式\"></a>神奇的魔术师—简单工厂模式</h3><blockquote>\n<p>简单工厂模式，有叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例，主要用来创建同一类对象。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//例子  用登录注册提示</span><br><span class=\"line\">var LoginAlert = function(text) &#123;</span><br><span class=\"line\">    this.content = text;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">LoginAlert.prototype.show = function() &#123;</span><br><span class=\"line\">    alert(this.content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var userNameAlert = new LoginAlert(&apos;用户名不能多于16个字母数字&apos;)</span><br><span class=\"line\">userNameAlert.show()</span><br><span class=\"line\">var passWordAlert = new LoginAlert(&apos;输入的密码不正确&apos;)</span><br><span class=\"line\">passWordAlert.show()</span><br><span class=\"line\"></span><br><span class=\"line\">var LoginConfirm = function(text) &#123;</span><br><span class=\"line\">    this.content = text;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">LoginConfirm.prototype.show = function() &#123;</span><br><span class=\"line\">    alert(this.content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var loginFailConfirm = new LoginConfirm(&apos;用户名不能多于16个字母数字&apos;)</span><br><span class=\"line\">loginFailConfirm.show();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var LoginPrompt = function(text) &#123;</span><br><span class=\"line\">    this.content = text;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">LoginPrompt.prototype.show = function() &#123;</span><br><span class=\"line\">    alert(this.content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// ...................</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果类太多，那么提供一个。</p>\n</blockquote>\n<p>别人想借用我的方法，写注册模块，缺点类名太多，其他人每次创建还要找到对应的类，太麻烦，而且是以login开头，最好封装在一个函数里，其他人只需要记住这个函数名，通过这个函数就可以创建我需要的对象为我所用，这个函数通常被称为工厂函数，这种模式叫简单工厂模式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var PopFactory= function(name) &#123;</span><br><span class=\"line\">    switch(name) &#123;</span><br><span class=\"line\">        case &apos;alert&apos; :</span><br><span class=\"line\">            return new LoginAlert()</span><br><span class=\"line\">        case &apos;confirm&apos; :</span><br><span class=\"line\">            return new LoginConfirm()</span><br><span class=\"line\">        case &apos;prompt&apos; :</span><br><span class=\"line\">            return new LoginPrompt()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 这三个类有很多地方是相同的，是可以抽象提取出来共用的，也可用简单工厂方式实现它们。</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>一个对象有时也可代替许多类</p>\n</blockquote>\n<p>简单工厂模式的理念就是创建对象，上面这种方式是对不同的类实例化，除此之外简单工厂模式还可以用来创建相似对象，上面创建的几个类很多地方都比较相似，提取相似，针对不相似处理，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createPop(type, text) &#123;</span><br><span class=\"line\">    var o = new Object();</span><br><span class=\"line\">    o.content = text;</span><br><span class=\"line\">    o.show= function() &#123;</span><br><span class=\"line\">        // 显示方法</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    if(type == &apos;alert&apos;) &#123;</span><br><span class=\"line\">        // 差异部分</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(type == &apos;prompt&apos;) &#123;</span><br><span class=\"line\">        // 差异部分</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(type == &apos;confirm&apos;) &#123;</span><br><span class=\"line\">        // 差异部分</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 调用，创建提示框</span><br><span class=\"line\">var userNameAlert = createPop(&apos;alert&apos;, &apos;提示文字&apos;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>总结：两种创建方式区别，第一种通过实例化对象创建，如果这些类继承同一父类，父类原型上的方法可以共用，第二种通过创建一个新对象然后包装增强其属性和功能来实现，每个对象都是一个新的个体，方法不能共用，选择哪种看实际需求。</p>\n</blockquote>\n<h3 id=\"给我一张名片—工厂方法模式\"><a href=\"#给我一张名片—工厂方法模式\" class=\"headerlink\" title=\"给我一张名片—工厂方法模式\"></a>给我一张名片—工厂方法模式</h3><blockquote>\n<p>通过对产品类的抽象使其创建业务主要负责用于创建多类产品的实例。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">需求，新来一批广告资源需要投资，一批java,一批php等等，不同课程字体颜色和大小不同。</span><br><span class=\"line\"></span><br><span class=\"line\">// 简单工厂</span><br><span class=\"line\">var Java = function(content) &#123;</span><br><span class=\"line\">    // .......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var Php = function(content) &#123;</span><br><span class=\"line\">    // .......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var Javascript = function(content) &#123;</span><br><span class=\"line\">    // .......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 学科工厂</span><br><span class=\"line\">function JobFactory(type, content) &#123;</span><br><span class=\"line\">    switch(type) &#123;</span><br><span class=\"line\">        case &apos;java&apos; : </span><br><span class=\"line\">            return new Java(content)</span><br><span class=\"line\">        case &apos;php&apos; : </span><br><span class=\"line\">            return new Php(content)</span><br><span class=\"line\">        case &apos;Javascript&apos; : </span><br><span class=\"line\">            return new Javascript(content)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 测试案例</span><br><span class=\"line\">JobFactory(&apos;Javascript&apos;, &apos;content&apos;);</span><br></pre></td></tr></table></figure>\n<p>问题？又来一批课程，需求各不同，之前的需求一直在变，不仅要添加类，还要修改工厂函数，可能未来的需求还会在变。引申相互工厂方法模式，这样以后每需要一个类，只需要添加这个类。</p>\n<blockquote>\n<p>工厂方法模式本意是说将实际创建对象工作推迟到子类当中，这样核心类就成了抽象类，不过对应javascript不必这么深究，javascript没有像传统创建抽象类那样的方式轻易创建抽象了类，所以在javascript中实现工厂方法模式我们只需要参考它的核心思想即可，所以我们可以将工厂方法看做是一个实例化对象的工厂类，安全起见，我们采用安全模式类，而我们将创建对象的基类放在工厂方法类的原型中即可。</p>\n</blockquote>\n<h4 id=\"安全的工厂方法\"><a href=\"#安全的工厂方法\" class=\"headerlink\" title=\"安全的工厂方法\"></a>安全的工厂方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 安全模式创建的工厂类</span><br><span class=\"line\">var Factory = function(type, content) &#123;</span><br><span class=\"line\">    if(this instanceof Factory) &#123;</span><br><span class=\"line\">        var s = new this[type] (content);</span><br><span class=\"line\">        return s;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return new Factory(type, content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 工厂原型中设置创建所用类型数据对象的基类</span><br><span class=\"line\">Factory.prototype = &#123;</span><br><span class=\"line\">    Java: function(content) &#123;</span><br><span class=\"line\">        // ....</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    javascript: function(content) &#123;</span><br><span class=\"line\">        // ....</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    UI: function(content) &#123;</span><br><span class=\"line\">        this.content = content;</span><br><span class=\"line\">        (function(content)) &#123;</span><br><span class=\"line\">            var div = documnet.createElement(&apos;div&apos;);</span><br><span class=\"line\">            div.innerHTML = content;</span><br><span class=\"line\">            div.style.border = &apos;1pc solid #ccc&apos;;</span><br><span class=\"line\">            document.getElementById(&apos;container&apos;).appendChild(div);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;(content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var data = [&#123;type: &apos;java&apos;, content: &apos;jajaja&apos;&#125;,&#123;type: &apos;php&apos;, content: &apos;phphphp&apos;&#125;]</span><br><span class=\"line\">data.map(function(item) &#123;</span><br><span class=\"line\">    Factory(item.type, item.content);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>优点，如果添加类，只需在Factory.prototype中添加，适用于创建多类对象，同时避免使用者与对象之间的耦合，用户不必关心创建该对象的具体类，只需调用工厂方法即可。</p>\n</blockquote>\n<h3 id=\"出现的都是幻觉—抽象工厂模式\"><a href=\"#出现的都是幻觉—抽象工厂模式\" class=\"headerlink\" title=\"出现的都是幻觉—抽象工厂模式\"></a>出现的都是幻觉—抽象工厂模式</h3><blockquote>\n<p>通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建每一类产品的实例。</p>\n</blockquote>\n<p>抽象工厂模式一般不用来创建具体对象，一般用它作为父类来创建一个子类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 抽象工厂方法</span><br><span class=\"line\">var VericleFactory = function(subType, superType) &#123;</span><br><span class=\"line\">    // 判断抽象工厂中是否有该抽象类</span><br><span class=\"line\">    if(typeof VericleFactory[superType] === &apos;function&apos;) &#123;</span><br><span class=\"line\">        function F() &#123;&#125;</span><br><span class=\"line\">        // 继承父类属性方法</span><br><span class=\"line\">        F.prototype = new VericleFactory[superType]();</span><br><span class=\"line\">        // 将子类constructor指向子类</span><br><span class=\"line\">        subType.constructor = superType;</span><br><span class=\"line\">        // 子类原型继承父类</span><br><span class=\"line\">        subType.prototype = new F();</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        // 不存在该抽象类抛出错误 </span><br><span class=\"line\">        return new Error(&apos;未创建该抽象类&apos;)</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 某一个车的抽象类</span><br><span class=\"line\">VericleFactory.Truck = function() &#123;</span><br><span class=\"line\">    this.type = &apos;truck&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">VericleFactory.Truck.prototype = &#123;</span><br><span class=\"line\">    getPrice: function() &#123;</span><br><span class=\"line\">        return new Error(&apos;抽象方法不可调用&apos;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getTrainload: function() &#123;</span><br><span class=\"line\">        return new Error(&apos;抽象方法不可调用&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 奔驰汽车子类</span><br><span class=\"line\">var BenzTruck = function(price, trainLoad) &#123;</span><br><span class=\"line\">    this.price = price;</span><br><span class=\"line\">    this.trainLoad = trainLoad;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 抽象方法实现对Truck抽象类的继承</span><br><span class=\"line\">VericleFactory(BenzTruck, &quot;Truck&quot;);</span><br><span class=\"line\">BenzTruck.prototype.getPrice = function() &#123;</span><br><span class=\"line\">    return this.price;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">BenzTruck.prototype.getTrainload = function() &#123;</span><br><span class=\"line\">    return this.getTrainload;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 测试</span><br><span class=\"line\">var truck = new BenzTruck(100, 10000);</span><br><span class=\"line\">console.log(truck.getPrice)   // 100</span><br><span class=\"line\">console.log(truck.type)       // truck</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>总结：抽象工厂模式是设计模式中最抽象的一种，也是创建模式中唯一一种抽象化创建模式，该模式创建出的结果不是一个真实的对象实例，而是一个类簇，它制定了类的结构，这也就区别于简单工厂模式创建单一对象，工厂方法模式创建多类对象，当然由于JavaScript中不支持抽象化创建与虚拟方法，所以导致这种模式不能像其他面向对象语言中应用的那么广泛。</p>\n</blockquote>\n<h3 id=\"分即是合—建造者模式\"><a href=\"#分即是合—建造者模式\" class=\"headerlink\" title=\"分即是合—建造者模式\"></a>分即是合—建造者模式</h3><blockquote>\n<p>将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示。</p>\n</blockquote>\n<p>创建对象的另一种新式：建造者模式</p>\n<p>建造者模式更注重的是创建的细节。</p>\n<h3 id=\"语言之魂—原型模式\"><a href=\"#语言之魂—原型模式\" class=\"headerlink\" title=\"语言之魂—原型模式\"></a>语言之魂—原型模式</h3><blockquote>\n<p>用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function prototypeExtend() &#123;</span><br><span class=\"line\">  var F = function() &#123;&#125;,</span><br><span class=\"line\">  args = arguments,</span><br><span class=\"line\">    i = 0,</span><br><span class=\"line\">    len = args.length;</span><br><span class=\"line\">    // console.log(arguments)</span><br><span class=\"line\">  for (; i &lt; len; i++) &#123;</span><br><span class=\"line\">    for (var j in args[i]) &#123;</span><br><span class=\"line\">      F.prototype[j] = args[i][j];</span><br><span class=\"line\">      console.log(F.prototype)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var penguin = prototypeExtend(</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    speed: 20,</span><br><span class=\"line\">    swim: function() &#123;</span><br><span class=\"line\">      console.log(&quot;.......1&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    sd: 300,</span><br><span class=\"line\">    run: function(speed) &#123;</span><br><span class=\"line\">      console.log(&quot;......2&quot;+ speed);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    jump: function() &#123;</span><br><span class=\"line\">      console.log(&quot;.........3&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\">penguin.swim()</span><br><span class=\"line\">penguin.run(10)</span><br><span class=\"line\">penguin.jump()</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>总结：原型模式可以让多个对象分享同一个原型对象的属性和方法，这也是一种继承方式，不过这种继承的实现是不需要创建的，而是将原型对象分享给那些继承的对象，当然有时需要让每个继承对象独立拥有一份原型对象，此时我们就需要对原型对象进行复制。</p>\n</blockquote>\n<p>由此可以看出，原型对象更适合在创建复杂的对象时，对于那些需求一直在变化而导致对象结构不停的改变时，将那些比较稳定的属性与方法共用而提取的继承的实现。</p>\n<h3 id=\"一个人的寂寞—单例模式\"><a href=\"#一个人的寂寞—单例模式\" class=\"headerlink\" title=\"一个人的寂寞—单例模式\"></a>一个人的寂寞—单例模式</h3><blockquote>\n<p>单例模式：有被称为单体模式，是只允许实例化一次的对象类，有时我们也用一个对象来规划一个命名空间，井井有条地管理对象上的属性个方法。</p>\n</blockquote>\n<p>JavaScript中最常见的一种模式，这种模式经常为我们提供一个命名空间，如我们使用过的jQuery库，单例模式就为它提供利润一个命名空间jQuery。</p>\n<blockquote>\n<p>命名空间？？？？</p>\n</blockquote>\n<p>就是nameSpace，解决一类问题：为了让代码更易懂，人们常常用单词或者拼音定义变量或者方法，但由于有限的单词量，所以不同的人定义的变量使用的单词名称很有可能重复，此时就需要用命名空间来约束每个人定义的变量来解决这类问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function g(id) &#123;</span><br><span class=\"line\">    return document.getElementById(id)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function css(id, key, value) &#123;</span><br><span class=\"line\">    g(id).style[key] = value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function on(id ,type, fn) &#123;</span><br><span class=\"line\">    g(id)[&apos;on&apos; + type] = fn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// ................</span><br><span class=\"line\"></span><br><span class=\"line\">// 命名空间</span><br><span class=\"line\">var My = &#123;</span><br><span class=\"line\">    g: function() &#123;</span><br><span class=\"line\">        return document.getElementById(id)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    css: function() &#123;</span><br><span class=\"line\">        this.g(id).style[key] = value;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    on: function() &#123;</span><br><span class=\"line\">        this.g(id)[&apos;on&apos; + type] = fn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>单例模式的其他作用：就是通过单例模式来控制自己的每个功能模块。</p>\n<p>创建一个小型代码库</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var A= &#123;</span><br><span class=\"line\">    Util: &#123;</span><br><span class=\"line\">        util_1: function() &#123;&#125;,</span><br><span class=\"line\">         util_2: function() &#123;&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    Tool: &#123;</span><br><span class=\"line\">        tool_1: function() &#123;&#125;,</span><br><span class=\"line\">        tool_2: function() &#123;&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    Ajax: function () &#123;</span><br><span class=\"line\">        ajax_1: function() &#123;&#125;,</span><br><span class=\"line\">        ajax_2: function() &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">A.Util.util_1();</span><br><span class=\"line\">// ........</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>无法修改的静态变量</p>\n</blockquote>\n<p>用单例模式管理静态变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Conf = (function() &#123;</span><br><span class=\"line\">    var conf = &#123;</span><br><span class=\"line\">        MAX_NUM: 100,</span><br><span class=\"line\">        MIN_NUM: 1,</span><br><span class=\"line\">        COUNT: 1000</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        get: function(name) &#123;</span><br><span class=\"line\">            return conf[name] ? conf[name] : null</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\">var COUNT = Conf.get(&apos;COUNT&apos;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>惰性单例</p>\n</blockquote>\n<p>有时候对于单例对象需要延迟创建，所以在单例中还存在一种延迟创建的形式，有人也称之为‘惰性创建’。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 惰性载入单例</span><br><span class=\"line\">var LazySingle = (function() &#123;</span><br><span class=\"line\">    // 单例实例引用</span><br><span class=\"line\">    var instance = null;</span><br><span class=\"line\">    // 单例</span><br><span class=\"line\">    function Single() &#123;</span><br><span class=\"line\">        // 这里定义私有属性和方法</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            publicMethod: function() &#123;&#125;,</span><br><span class=\"line\">            punlicProperty: &apos;1.0&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 获取单例对象接口</span><br><span class=\"line\">    if(!instance) &#123;</span><br><span class=\"line\">        instance = Single()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 返回单例</span><br><span class=\"line\">    return instance;</span><br><span class=\"line\">&#125; )()</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(LazySingle().punlicProperty);  // 1.0</span><br></pre></td></tr></table></figure>"},{"title":"结构型设计模式","date":"2017-11-27T10:56:20.000Z","_content":"> 结构型设计模式关注于如何将类或者对象组合成更大，更复杂的结构，以简化设计。\n\n<!-- more -->\n\n### 套餐服务---外观模式\n\n> 外观模式（Facade）：为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口，使得对子系统接口的访问更容易，在Javascript中有时也会用于对底层结构兼容性做统一封装来简化用户使用。\n\n```\n// 外观模式实现\n//提供一个更简单的高级接口，简化了我们对复杂的底层接口不统一的使用要求\nfunction addEvent(dom, type, fn) {\n    if(dom.addEventListener) {\n        dom.addEventListener(type, fn, false)\n    } else if(dom.attachEvent){\n        dom.attachEvent('on'+type, fn)\n    } else {\n        dom['on'+type] = fn;\n    }\n}\n\n// 使用\nvar DOM = document.getElementById('dom');\naddEvent(Dom, 'click', function() {\n    // 绑定的第一个事件\n    console.log('绑定的第一个事件')\n})\naddEvent(Dom, 'click', function() {\n    // 绑定的第一个事件\n    console.log('绑定的第二个事件')\n})\n\n// 获取事件对象\nvar getEvent = function (event) {\n    // 标准浏览器返回event  IE window.event\n    return event || window.event;\n}\n// 获取元素\nvar getTarget = function(event) {\n    var event = getEvent(event);\n    // 标准浏览器下event.target  IE下event.srcElement\n    return event.target || event.srcElement;\n}\n// 阻止默认行为\nvar preventDefault = function (event) {\n    var event = getEvent(event);\n    // 标准浏览器\n    if(event.preventDefault) {\n        event.preventDefault\n    } else {\n        // IE\n        event.returnValue = false;\n    }\n}\n//使用\ndocument.onclick = function (e) {\n    preventDefault(e);\n    if(getTarget(e) === Dom) {\n        // do somethihng\n    }\n}\n```\n> 总结：外观模式是对接口方法的外层包装，以供上层代码调用以供上层代码使用，因此有时外观模式封装的接口方法不需要接口的具体实现，只需要按照接口使用规则使用即可，这也是对系统与使用者之间的一种松散耦合，使得系统与使用者之间不会因结构的变化而相互影响。\n\n### 水管弯弯---适配器模式\n\n> 适配器模式(Adapter): 将一个类（对象）的接口（方法或属性）转化成另外一个接口，以满足用户需求，使类（对象）之间接口的不兼容问题通过适配器得以解决。\n\n> 生活中的适配器两根垂直相交的水管连接处的的直角弯管，使得两个不同方向的水管可以疏通流水，三角插头手机充电器对于两项插头是不可用的，此时需要一个三项转两项插头电源适配器等等，这些都是适配器。代码写适配器，其实就是为两个代码库所写的代码兼容运行而书写的额外代码，有了这样的适配器，你就不需要特意地重写以前的功能代码了。\n\n> jQuery适配器\n\n某框架A和jQuery代码书写风格很像，加载完jQuery框架后写一个适配器，将我们已有的功能适配到jQuery，假如代码中有两个事件\n，一个加载，一个点击，不过这两个事件与jQuery中的写法很像，所以做的改动不会太大，我们的适配器的主要任务是适配两种代码库中不兼容的代码，那么首当其冲的就是全局对象A与jQuery了，\n\n```\nwindow.A = A = jQuery;\n```\n> 适配异类框架\n\n如果两个框架直接相差太大，对于这种异类框架适配情况就复杂多了，\n\n```\n// 定义框架\nvar A = A|| {}\nA.g = function(id) {\n    return document.getElementById(id)\n}\n// 为元素绑定事件\nA.on= function(id, type, fn) {\n    // 如果传递参数是字符串则以id处理，负责以元素对象处理，\n    var dom = typeof id === 'string' ? this.g(id) : id;\n    // 标准dom2级添加事件方式\n    if(dom.addEventListener) {\n        dom.addEventListener(type, fn, false)\n    } else if(dom.attachEvent){\n        dom.attachEvent('on'+type, fn)\n    } else {\n        dom['on'+type] = fn;\n    }\n}\n// 使用\nA.on(window, 'load', function() {\n    A.on('dom', 'click', function() {\n        // do something\n    })\n})\n// 引入jQuery来换A库\nA.g = function(id) {\n    // 通过jQuery获取jQuery对象，然后返回第一个成员\n    return $(id).get(0)\n}\nA.on = function(id, type, fn) {\n    // 如果传递参数是字符串则以id处理，否则以元素对象处理，\n    var dom = typeof id === 'string' ? $('#' + id) : $(id);\n    dom.on(type, fn);\n}\n// 通过适配器发现如果两种框架的比较相似，适配比较容易，否则写起来复杂很多，因此尽量引入相似框架。\n```\n\n> 参数适配器\n\n适配器还有很多用途，比如方法需要传递多个参数\n```\nfunction dosomething(name, title, age, color, size, prize) {\n    // 记住参数顺序是很困难的，因此我们经常以一个参数对象方式传入\n}\nvar obj = {\n    name: name,\n    title: title\n    ...\n}\nfunction dosomething(obj) {}\n// 然而调用的时候不知道传递的参数是否完整，如有一些必须参数没有传入，一些参数是有默认值得等等，此时我们通常的做法是用适配器来适配传入的这个参数对象\n\nfunction doSomething(obj) {\n    var _adapter = {\n        name: 'me',\n        title: '设计模式'，\n        age: 24,\n        ...\n    }\n    for(var i in _adapter) {\n        _adapter[i] = obj[i] || _adapter[i];\n        // 或者 extend(_adapter, obj)   //  此时可能会多添加属性\n        // do something\n    }\n} \n```\n> 数据适配\n\n```\nvar arr = ['javascript',20,'时间'， ‘日期’]\n// 我们发现数组中的每个成员代表的意义不同，这种数据结构语义不好，我们通常会将其适配成对象形式，\nvar obj = {\n    name: '',\n    age: '',\n    time: '',\n    data: ''\n}\nfunction arrToObjAdapter() {\n    return {\n        name: arr[0],\n        age: arr[1]\n        ...\n    }\n}\n// 使用\nvar adapterData = arrToObjAdapter(arr);\nconsole.log(adapterData)  // {name: 'javascript', age: 20, ...}\n\n```\n> 服务器端数据适配\n\n它解决了前后端的数据依赖，前端程序不在为后端传递的数据所束缚，如果后端因为架构改变导致传递的数据结构发生变化，我们只需要写个适配器就可以放心了，如果后端的数据经常变化，无法控制数据的格式，那么我们在dosomething时最好不要直接调用，最好先将传递过来的数据适配成对我们可用的数据在使用。\n\n```\n// 为简化模型这里使用jQuery的ajax方法，理想数据是一个一维数组\nfunction ajaxAdapter(data) {\n    // 处理数据并返回新数据\n    return [data['key1'], data['key2'], ...]\n}\n$.ajax({\n    url: '...',\n    // ...\n    success: function(data) {\n        if(data) {\n            doSomethin(ajaxAdapter(data))\n        }\n    }\n})\n// 如果以后后端数据有任何变化我们只需相应的更改ajaxAdapter适配器转换格式\n```\n> 总结：传统设计模式中，适配器模式往往是适配两个类接口不兼容的问题，然而在JavaScript中，适配器的应用范围更广，比如适配两个代码库，适配前后端数据等等。JavaScript中的适配器的应用，更多应用在对象之间，为了使对象可用，通常我们会将对象拆分并重新包装，这样我们就要了解适配对象的内部结构，这也是与外观模式的区别所在，当然适配器模式同样解决了对象之间的耦合度。包装的适配器代码增加了一些资源开销，当然这是微乎其微的。\n\n### 牛郎织女---代理模式\n\n> 代理模式（Proxy）:由于一个对象不能直接应用另一个对象，所以需要通过代理对象在这两个对象之间起到代理作用。\n\n由于用户相册模块上传的照片量越来越大，导致服务器端需要将图片上传模块重新部署到另外一个域，这样对于前端来说，用户上传图片的请求路径发生变化，指向其他服务器，这就导致了跨域问题。\n\n> 跨域\n\n> 站长统计\n\n> JSONP\n\n> 代理模板\n\n### 房子装饰---装饰者模式\n\n> 装饰者模式（Decorator）:在不改变原对象的基础上，通过对其进行包装扩展（添加属性或者方法）使原有对象可以满足用户的更复杂需求。\n\n静止是相对的，运动是绝对的，所以没有一成不变的需求。\n\n？？ 情景：给页面所以input添加一个点击隐藏文案提示，注意不要覆盖原有的事件。\n\n```\nvar input1 = doucument.getElementById('input1')\ninput1.onclick = function() {\n    // do something\n}\nvar input2 = doucument.getElementById('input2')\ninput2.onclick = function() {\n    // do something\n}\n...很多的input\n```\n\n以上这种解决方法，由于输入框太多，寻找与修改麻烦,所以试试装饰者模式吧！\n\n> 装饰已有的功能对象\n\n```\nvar decorator = function(input, fn) {\n    // 获取事件源\n    var input = doucument.getElementById(input);\n    // 若事件源已经绑定事件\n    if(typeof input.onclick === 'function') {\n        // 缓存事件源原有事件函数\n        var oldClickFn = input.onclick;\n        input.onclick = function() {\n            // 事件源原有回调函数\n            oldClickFn();\n            // 执行事件源添加新增回调函数\n            fn();\n        }\n    } else {\n        input.onclick = fn;\n    }\n    // do something\n}\n// 使用\ndecorator（‘input1’, function() {\n    // do something\n}）\ndecorator（‘input2’, function() {\n    // do something\n}）\n\n```\n> 装饰者模式和适配器模式都是对一个对象的修饰来适配其他对象，二者不同，适配器模式是对原有对象适配，添加的方法与原有方法功能上大致相似，装饰者模式提供的方法与原来的方法是有一定区别的，还有最重要的一点是适配器模式新增的方法要调用原来的方法，要了解原有方法具体的细节，而装饰者模式不需要了解对象原有的功能，原方法原封不动的使用。\n\n> 总结：装饰模式是一种可以在不了解原有功能的基础上对功能拓展，装饰者模式对对象的拓展是一种良性拓展，不用了解其具体实现，只是在外部进行了一次封装拓展，是对原有功能完整性的一种保护。\n\n### 城市间的道路---桥接模式\n\n> 桥接模式（Bridge）：在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦。\n\n有时候页面中的一些小小细节改变常常因逻辑相似导致大片臃肿的代码，让页面苦涩不堪。\n\n问题：给页面导航栏添加鼠标滑过特效，区别：每个鼠标滑过的效果不一样。。。\n\n```\nvar nav = document.getElementByTagName('span');\n// 不同的绑定不同效果\nnav[0].onmouserover = function() {\n    this.style.color = 'red';\n    this.style.background = 'green';\n}\nnav[0].onmouserout = function() {\n    this.style.color = '#fff';\n    this.style.background = '#ccc';\n}\n\nnav[1].onmouseover = function() {\n    this.getElementsByTagName('strong')[0]style.color = '#fff';\n    this.getElementsByTagName('strong')[0]style.background = '#ccc';\n}\nnav[1].onmouseout = function() {\n    this.getElementsByTagName('strong')[0]style.color = 'red';\n    this.getElementsByTagName('strong')[0]style.background = 'blue';\n}\n\n```\n缺点：功能能实现，但是代码冗余。\n解决方法：提取共同点，，对相同的逻辑做抽象提取处理，解除与事件中this的耦合。\n\n```\nfunction changeColor(dom, color, bg) {\n    dom.style.color = color;\n    dom.style.background = bg;\n}\n\n```\n\n下一步：事件与业务逻辑之间的桥梁---桥接模式\n\n对于事件桥接方法，可以用一个匿名函数来代替，否则直接将changeColor作为事件的回调函数，解除this耦合。\n\n```\nnav[0].onmouserover = function() {\n    changeColor(this, 'red', '#fff');\n}\n```\n\n这种方法是以新增一个桥接函数为代价实现的。\n\n> 多元化对象\n\n桥接模式对于多维的变化也同样适用，\n\n```\nfunction Speed(x, y) {\n    this.x = x;\n    this.y = y;\n}\nSpeed.prototype.run = function() {\n    // do something\n}\n\nfunction Color(cl) {\n    this.cl = cl;\n}\nColor.prtotype.draw = function() {\n    // do something\n}\n...\n\nfunction Ball(x, y ,c) {\n    this.speed = new Speed(x, y);\n    this.color = new Color(c);\n}\nBall.prototype = function() {\n    this.speed.run();\n    this.color.draw();\n}\n```\n总结：桥接模式主要特点：将实现层（如元素绑定的事件）与抽象层（如修饰页面UI逻辑）解耦分离，使两部分可以独立变化，由此可以看出桥接模式主要是对结构之间的结构，而抽象工厂模式与创建者模式主要业务在于创建，通过桥接模式实现的解耦，使实现层与抽象层分开处理，避免需求的改变造成对象内部的修改，体现了面向对象对扩展的开放及对修改的关闭原则。当然由于桥接的添加，有时也造成开发成本的增加，有时性能上也会受到影响。\n\n### 超值午餐---组合模式\n\n> 组合模式（Composite）:又称部分-整体模式，将对象组合成树形结构以表示‘整体部分’的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。\n\n### 城市公交车---享元模式\n\n> 享元模式（Flyweight）运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多于的开销。\n\n总结：享元模式的应用目的是为了提高程序的执行效率与系统的性能，因此在大型系统开发中应用是比较广泛的，百分之一的效率提成有时可以发生质的改变，它可以避免程序中的数据重复，\n\n\n\n\n\n\n\n\n","source":"_posts/javascript/结构型设计模式.md","raw":"---\ntitle: 结构型设计模式\ncategories:\n  - javascript设计模式\ntags:\n  - 结构型设计模式\ndate: 2017-11-27 18:56:20\n---\n> 结构型设计模式关注于如何将类或者对象组合成更大，更复杂的结构，以简化设计。\n\n<!-- more -->\n\n### 套餐服务---外观模式\n\n> 外观模式（Facade）：为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口，使得对子系统接口的访问更容易，在Javascript中有时也会用于对底层结构兼容性做统一封装来简化用户使用。\n\n```\n// 外观模式实现\n//提供一个更简单的高级接口，简化了我们对复杂的底层接口不统一的使用要求\nfunction addEvent(dom, type, fn) {\n    if(dom.addEventListener) {\n        dom.addEventListener(type, fn, false)\n    } else if(dom.attachEvent){\n        dom.attachEvent('on'+type, fn)\n    } else {\n        dom['on'+type] = fn;\n    }\n}\n\n// 使用\nvar DOM = document.getElementById('dom');\naddEvent(Dom, 'click', function() {\n    // 绑定的第一个事件\n    console.log('绑定的第一个事件')\n})\naddEvent(Dom, 'click', function() {\n    // 绑定的第一个事件\n    console.log('绑定的第二个事件')\n})\n\n// 获取事件对象\nvar getEvent = function (event) {\n    // 标准浏览器返回event  IE window.event\n    return event || window.event;\n}\n// 获取元素\nvar getTarget = function(event) {\n    var event = getEvent(event);\n    // 标准浏览器下event.target  IE下event.srcElement\n    return event.target || event.srcElement;\n}\n// 阻止默认行为\nvar preventDefault = function (event) {\n    var event = getEvent(event);\n    // 标准浏览器\n    if(event.preventDefault) {\n        event.preventDefault\n    } else {\n        // IE\n        event.returnValue = false;\n    }\n}\n//使用\ndocument.onclick = function (e) {\n    preventDefault(e);\n    if(getTarget(e) === Dom) {\n        // do somethihng\n    }\n}\n```\n> 总结：外观模式是对接口方法的外层包装，以供上层代码调用以供上层代码使用，因此有时外观模式封装的接口方法不需要接口的具体实现，只需要按照接口使用规则使用即可，这也是对系统与使用者之间的一种松散耦合，使得系统与使用者之间不会因结构的变化而相互影响。\n\n### 水管弯弯---适配器模式\n\n> 适配器模式(Adapter): 将一个类（对象）的接口（方法或属性）转化成另外一个接口，以满足用户需求，使类（对象）之间接口的不兼容问题通过适配器得以解决。\n\n> 生活中的适配器两根垂直相交的水管连接处的的直角弯管，使得两个不同方向的水管可以疏通流水，三角插头手机充电器对于两项插头是不可用的，此时需要一个三项转两项插头电源适配器等等，这些都是适配器。代码写适配器，其实就是为两个代码库所写的代码兼容运行而书写的额外代码，有了这样的适配器，你就不需要特意地重写以前的功能代码了。\n\n> jQuery适配器\n\n某框架A和jQuery代码书写风格很像，加载完jQuery框架后写一个适配器，将我们已有的功能适配到jQuery，假如代码中有两个事件\n，一个加载，一个点击，不过这两个事件与jQuery中的写法很像，所以做的改动不会太大，我们的适配器的主要任务是适配两种代码库中不兼容的代码，那么首当其冲的就是全局对象A与jQuery了，\n\n```\nwindow.A = A = jQuery;\n```\n> 适配异类框架\n\n如果两个框架直接相差太大，对于这种异类框架适配情况就复杂多了，\n\n```\n// 定义框架\nvar A = A|| {}\nA.g = function(id) {\n    return document.getElementById(id)\n}\n// 为元素绑定事件\nA.on= function(id, type, fn) {\n    // 如果传递参数是字符串则以id处理，负责以元素对象处理，\n    var dom = typeof id === 'string' ? this.g(id) : id;\n    // 标准dom2级添加事件方式\n    if(dom.addEventListener) {\n        dom.addEventListener(type, fn, false)\n    } else if(dom.attachEvent){\n        dom.attachEvent('on'+type, fn)\n    } else {\n        dom['on'+type] = fn;\n    }\n}\n// 使用\nA.on(window, 'load', function() {\n    A.on('dom', 'click', function() {\n        // do something\n    })\n})\n// 引入jQuery来换A库\nA.g = function(id) {\n    // 通过jQuery获取jQuery对象，然后返回第一个成员\n    return $(id).get(0)\n}\nA.on = function(id, type, fn) {\n    // 如果传递参数是字符串则以id处理，否则以元素对象处理，\n    var dom = typeof id === 'string' ? $('#' + id) : $(id);\n    dom.on(type, fn);\n}\n// 通过适配器发现如果两种框架的比较相似，适配比较容易，否则写起来复杂很多，因此尽量引入相似框架。\n```\n\n> 参数适配器\n\n适配器还有很多用途，比如方法需要传递多个参数\n```\nfunction dosomething(name, title, age, color, size, prize) {\n    // 记住参数顺序是很困难的，因此我们经常以一个参数对象方式传入\n}\nvar obj = {\n    name: name,\n    title: title\n    ...\n}\nfunction dosomething(obj) {}\n// 然而调用的时候不知道传递的参数是否完整，如有一些必须参数没有传入，一些参数是有默认值得等等，此时我们通常的做法是用适配器来适配传入的这个参数对象\n\nfunction doSomething(obj) {\n    var _adapter = {\n        name: 'me',\n        title: '设计模式'，\n        age: 24,\n        ...\n    }\n    for(var i in _adapter) {\n        _adapter[i] = obj[i] || _adapter[i];\n        // 或者 extend(_adapter, obj)   //  此时可能会多添加属性\n        // do something\n    }\n} \n```\n> 数据适配\n\n```\nvar arr = ['javascript',20,'时间'， ‘日期’]\n// 我们发现数组中的每个成员代表的意义不同，这种数据结构语义不好，我们通常会将其适配成对象形式，\nvar obj = {\n    name: '',\n    age: '',\n    time: '',\n    data: ''\n}\nfunction arrToObjAdapter() {\n    return {\n        name: arr[0],\n        age: arr[1]\n        ...\n    }\n}\n// 使用\nvar adapterData = arrToObjAdapter(arr);\nconsole.log(adapterData)  // {name: 'javascript', age: 20, ...}\n\n```\n> 服务器端数据适配\n\n它解决了前后端的数据依赖，前端程序不在为后端传递的数据所束缚，如果后端因为架构改变导致传递的数据结构发生变化，我们只需要写个适配器就可以放心了，如果后端的数据经常变化，无法控制数据的格式，那么我们在dosomething时最好不要直接调用，最好先将传递过来的数据适配成对我们可用的数据在使用。\n\n```\n// 为简化模型这里使用jQuery的ajax方法，理想数据是一个一维数组\nfunction ajaxAdapter(data) {\n    // 处理数据并返回新数据\n    return [data['key1'], data['key2'], ...]\n}\n$.ajax({\n    url: '...',\n    // ...\n    success: function(data) {\n        if(data) {\n            doSomethin(ajaxAdapter(data))\n        }\n    }\n})\n// 如果以后后端数据有任何变化我们只需相应的更改ajaxAdapter适配器转换格式\n```\n> 总结：传统设计模式中，适配器模式往往是适配两个类接口不兼容的问题，然而在JavaScript中，适配器的应用范围更广，比如适配两个代码库，适配前后端数据等等。JavaScript中的适配器的应用，更多应用在对象之间，为了使对象可用，通常我们会将对象拆分并重新包装，这样我们就要了解适配对象的内部结构，这也是与外观模式的区别所在，当然适配器模式同样解决了对象之间的耦合度。包装的适配器代码增加了一些资源开销，当然这是微乎其微的。\n\n### 牛郎织女---代理模式\n\n> 代理模式（Proxy）:由于一个对象不能直接应用另一个对象，所以需要通过代理对象在这两个对象之间起到代理作用。\n\n由于用户相册模块上传的照片量越来越大，导致服务器端需要将图片上传模块重新部署到另外一个域，这样对于前端来说，用户上传图片的请求路径发生变化，指向其他服务器，这就导致了跨域问题。\n\n> 跨域\n\n> 站长统计\n\n> JSONP\n\n> 代理模板\n\n### 房子装饰---装饰者模式\n\n> 装饰者模式（Decorator）:在不改变原对象的基础上，通过对其进行包装扩展（添加属性或者方法）使原有对象可以满足用户的更复杂需求。\n\n静止是相对的，运动是绝对的，所以没有一成不变的需求。\n\n？？ 情景：给页面所以input添加一个点击隐藏文案提示，注意不要覆盖原有的事件。\n\n```\nvar input1 = doucument.getElementById('input1')\ninput1.onclick = function() {\n    // do something\n}\nvar input2 = doucument.getElementById('input2')\ninput2.onclick = function() {\n    // do something\n}\n...很多的input\n```\n\n以上这种解决方法，由于输入框太多，寻找与修改麻烦,所以试试装饰者模式吧！\n\n> 装饰已有的功能对象\n\n```\nvar decorator = function(input, fn) {\n    // 获取事件源\n    var input = doucument.getElementById(input);\n    // 若事件源已经绑定事件\n    if(typeof input.onclick === 'function') {\n        // 缓存事件源原有事件函数\n        var oldClickFn = input.onclick;\n        input.onclick = function() {\n            // 事件源原有回调函数\n            oldClickFn();\n            // 执行事件源添加新增回调函数\n            fn();\n        }\n    } else {\n        input.onclick = fn;\n    }\n    // do something\n}\n// 使用\ndecorator（‘input1’, function() {\n    // do something\n}）\ndecorator（‘input2’, function() {\n    // do something\n}）\n\n```\n> 装饰者模式和适配器模式都是对一个对象的修饰来适配其他对象，二者不同，适配器模式是对原有对象适配，添加的方法与原有方法功能上大致相似，装饰者模式提供的方法与原来的方法是有一定区别的，还有最重要的一点是适配器模式新增的方法要调用原来的方法，要了解原有方法具体的细节，而装饰者模式不需要了解对象原有的功能，原方法原封不动的使用。\n\n> 总结：装饰模式是一种可以在不了解原有功能的基础上对功能拓展，装饰者模式对对象的拓展是一种良性拓展，不用了解其具体实现，只是在外部进行了一次封装拓展，是对原有功能完整性的一种保护。\n\n### 城市间的道路---桥接模式\n\n> 桥接模式（Bridge）：在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦。\n\n有时候页面中的一些小小细节改变常常因逻辑相似导致大片臃肿的代码，让页面苦涩不堪。\n\n问题：给页面导航栏添加鼠标滑过特效，区别：每个鼠标滑过的效果不一样。。。\n\n```\nvar nav = document.getElementByTagName('span');\n// 不同的绑定不同效果\nnav[0].onmouserover = function() {\n    this.style.color = 'red';\n    this.style.background = 'green';\n}\nnav[0].onmouserout = function() {\n    this.style.color = '#fff';\n    this.style.background = '#ccc';\n}\n\nnav[1].onmouseover = function() {\n    this.getElementsByTagName('strong')[0]style.color = '#fff';\n    this.getElementsByTagName('strong')[0]style.background = '#ccc';\n}\nnav[1].onmouseout = function() {\n    this.getElementsByTagName('strong')[0]style.color = 'red';\n    this.getElementsByTagName('strong')[0]style.background = 'blue';\n}\n\n```\n缺点：功能能实现，但是代码冗余。\n解决方法：提取共同点，，对相同的逻辑做抽象提取处理，解除与事件中this的耦合。\n\n```\nfunction changeColor(dom, color, bg) {\n    dom.style.color = color;\n    dom.style.background = bg;\n}\n\n```\n\n下一步：事件与业务逻辑之间的桥梁---桥接模式\n\n对于事件桥接方法，可以用一个匿名函数来代替，否则直接将changeColor作为事件的回调函数，解除this耦合。\n\n```\nnav[0].onmouserover = function() {\n    changeColor(this, 'red', '#fff');\n}\n```\n\n这种方法是以新增一个桥接函数为代价实现的。\n\n> 多元化对象\n\n桥接模式对于多维的变化也同样适用，\n\n```\nfunction Speed(x, y) {\n    this.x = x;\n    this.y = y;\n}\nSpeed.prototype.run = function() {\n    // do something\n}\n\nfunction Color(cl) {\n    this.cl = cl;\n}\nColor.prtotype.draw = function() {\n    // do something\n}\n...\n\nfunction Ball(x, y ,c) {\n    this.speed = new Speed(x, y);\n    this.color = new Color(c);\n}\nBall.prototype = function() {\n    this.speed.run();\n    this.color.draw();\n}\n```\n总结：桥接模式主要特点：将实现层（如元素绑定的事件）与抽象层（如修饰页面UI逻辑）解耦分离，使两部分可以独立变化，由此可以看出桥接模式主要是对结构之间的结构，而抽象工厂模式与创建者模式主要业务在于创建，通过桥接模式实现的解耦，使实现层与抽象层分开处理，避免需求的改变造成对象内部的修改，体现了面向对象对扩展的开放及对修改的关闭原则。当然由于桥接的添加，有时也造成开发成本的增加，有时性能上也会受到影响。\n\n### 超值午餐---组合模式\n\n> 组合模式（Composite）:又称部分-整体模式，将对象组合成树形结构以表示‘整体部分’的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。\n\n### 城市公交车---享元模式\n\n> 享元模式（Flyweight）运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多于的开销。\n\n总结：享元模式的应用目的是为了提高程序的执行效率与系统的性能，因此在大型系统开发中应用是比较广泛的，百分之一的效率提成有时可以发生质的改变，它可以避免程序中的数据重复，\n\n\n\n\n\n\n\n\n","slug":"javascript/结构型设计模式","published":1,"updated":"2017-11-30T09:37:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaqhv1gh0009btx1icse7htr","content":"<blockquote>\n<p>结构型设计模式关注于如何将类或者对象组合成更大，更复杂的结构，以简化设计。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"套餐服务—外观模式\"><a href=\"#套餐服务—外观模式\" class=\"headerlink\" title=\"套餐服务—外观模式\"></a>套餐服务—外观模式</h3><blockquote>\n<p>外观模式（Facade）：为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口，使得对子系统接口的访问更容易，在Javascript中有时也会用于对底层结构兼容性做统一封装来简化用户使用。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 外观模式实现</span><br><span class=\"line\">//提供一个更简单的高级接口，简化了我们对复杂的底层接口不统一的使用要求</span><br><span class=\"line\">function addEvent(dom, type, fn) &#123;</span><br><span class=\"line\">    if(dom.addEventListener) &#123;</span><br><span class=\"line\">        dom.addEventListener(type, fn, false)</span><br><span class=\"line\">    &#125; else if(dom.attachEvent)&#123;</span><br><span class=\"line\">        dom.attachEvent(&apos;on&apos;+type, fn)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        dom[&apos;on&apos;+type] = fn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用</span><br><span class=\"line\">var DOM = document.getElementById(&apos;dom&apos;);</span><br><span class=\"line\">addEvent(Dom, &apos;click&apos;, function() &#123;</span><br><span class=\"line\">    // 绑定的第一个事件</span><br><span class=\"line\">    console.log(&apos;绑定的第一个事件&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">addEvent(Dom, &apos;click&apos;, function() &#123;</span><br><span class=\"line\">    // 绑定的第一个事件</span><br><span class=\"line\">    console.log(&apos;绑定的第二个事件&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 获取事件对象</span><br><span class=\"line\">var getEvent = function (event) &#123;</span><br><span class=\"line\">    // 标准浏览器返回event  IE window.event</span><br><span class=\"line\">    return event || window.event;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 获取元素</span><br><span class=\"line\">var getTarget = function(event) &#123;</span><br><span class=\"line\">    var event = getEvent(event);</span><br><span class=\"line\">    // 标准浏览器下event.target  IE下event.srcElement</span><br><span class=\"line\">    return event.target || event.srcElement;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 阻止默认行为</span><br><span class=\"line\">var preventDefault = function (event) &#123;</span><br><span class=\"line\">    var event = getEvent(event);</span><br><span class=\"line\">    // 标准浏览器</span><br><span class=\"line\">    if(event.preventDefault) &#123;</span><br><span class=\"line\">        event.preventDefault</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        // IE</span><br><span class=\"line\">        event.returnValue = false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//使用</span><br><span class=\"line\">document.onclick = function (e) &#123;</span><br><span class=\"line\">    preventDefault(e);</span><br><span class=\"line\">    if(getTarget(e) === Dom) &#123;</span><br><span class=\"line\">        // do somethihng</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>总结：外观模式是对接口方法的外层包装，以供上层代码调用以供上层代码使用，因此有时外观模式封装的接口方法不需要接口的具体实现，只需要按照接口使用规则使用即可，这也是对系统与使用者之间的一种松散耦合，使得系统与使用者之间不会因结构的变化而相互影响。</p>\n</blockquote>\n<h3 id=\"水管弯弯—适配器模式\"><a href=\"#水管弯弯—适配器模式\" class=\"headerlink\" title=\"水管弯弯—适配器模式\"></a>水管弯弯—适配器模式</h3><blockquote>\n<p>适配器模式(Adapter): 将一个类（对象）的接口（方法或属性）转化成另外一个接口，以满足用户需求，使类（对象）之间接口的不兼容问题通过适配器得以解决。</p>\n<p>生活中的适配器两根垂直相交的水管连接处的的直角弯管，使得两个不同方向的水管可以疏通流水，三角插头手机充电器对于两项插头是不可用的，此时需要一个三项转两项插头电源适配器等等，这些都是适配器。代码写适配器，其实就是为两个代码库所写的代码兼容运行而书写的额外代码，有了这样的适配器，你就不需要特意地重写以前的功能代码了。</p>\n<p>jQuery适配器</p>\n</blockquote>\n<p>某框架A和jQuery代码书写风格很像，加载完jQuery框架后写一个适配器，将我们已有的功能适配到jQuery，假如代码中有两个事件<br>，一个加载，一个点击，不过这两个事件与jQuery中的写法很像，所以做的改动不会太大，我们的适配器的主要任务是适配两种代码库中不兼容的代码，那么首当其冲的就是全局对象A与jQuery了，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.A = A = jQuery;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>适配异类框架</p>\n</blockquote>\n<p>如果两个框架直接相差太大，对于这种异类框架适配情况就复杂多了，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义框架</span><br><span class=\"line\">var A = A|| &#123;&#125;</span><br><span class=\"line\">A.g = function(id) &#123;</span><br><span class=\"line\">    return document.getElementById(id)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 为元素绑定事件</span><br><span class=\"line\">A.on= function(id, type, fn) &#123;</span><br><span class=\"line\">    // 如果传递参数是字符串则以id处理，负责以元素对象处理，</span><br><span class=\"line\">    var dom = typeof id === &apos;string&apos; ? this.g(id) : id;</span><br><span class=\"line\">    // 标准dom2级添加事件方式</span><br><span class=\"line\">    if(dom.addEventListener) &#123;</span><br><span class=\"line\">        dom.addEventListener(type, fn, false)</span><br><span class=\"line\">    &#125; else if(dom.attachEvent)&#123;</span><br><span class=\"line\">        dom.attachEvent(&apos;on&apos;+type, fn)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        dom[&apos;on&apos;+type] = fn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 使用</span><br><span class=\"line\">A.on(window, &apos;load&apos;, function() &#123;</span><br><span class=\"line\">    A.on(&apos;dom&apos;, &apos;click&apos;, function() &#123;</span><br><span class=\"line\">        // do something</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 引入jQuery来换A库</span><br><span class=\"line\">A.g = function(id) &#123;</span><br><span class=\"line\">    // 通过jQuery获取jQuery对象，然后返回第一个成员</span><br><span class=\"line\">    return $(id).get(0)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A.on = function(id, type, fn) &#123;</span><br><span class=\"line\">    // 如果传递参数是字符串则以id处理，否则以元素对象处理，</span><br><span class=\"line\">    var dom = typeof id === &apos;string&apos; ? $(&apos;#&apos; + id) : $(id);</span><br><span class=\"line\">    dom.on(type, fn);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 通过适配器发现如果两种框架的比较相似，适配比较容易，否则写起来复杂很多，因此尽量引入相似框架。</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>参数适配器</p>\n</blockquote>\n<p>适配器还有很多用途，比如方法需要传递多个参数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function dosomething(name, title, age, color, size, prize) &#123;</span><br><span class=\"line\">    // 记住参数顺序是很困难的，因此我们经常以一个参数对象方式传入</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    name: name,</span><br><span class=\"line\">    title: title</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function dosomething(obj) &#123;&#125;</span><br><span class=\"line\">// 然而调用的时候不知道传递的参数是否完整，如有一些必须参数没有传入，一些参数是有默认值得等等，此时我们通常的做法是用适配器来适配传入的这个参数对象</span><br><span class=\"line\"></span><br><span class=\"line\">function doSomething(obj) &#123;</span><br><span class=\"line\">    var _adapter = &#123;</span><br><span class=\"line\">        name: &apos;me&apos;,</span><br><span class=\"line\">        title: &apos;设计模式&apos;，</span><br><span class=\"line\">        age: 24,</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for(var i in _adapter) &#123;</span><br><span class=\"line\">        _adapter[i] = obj[i] || _adapter[i];</span><br><span class=\"line\">        // 或者 extend(_adapter, obj)   //  此时可能会多添加属性</span><br><span class=\"line\">        // do something</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>数据适配</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [&apos;javascript&apos;,20,&apos;时间&apos;， ‘日期’]</span><br><span class=\"line\">// 我们发现数组中的每个成员代表的意义不同，这种数据结构语义不好，我们通常会将其适配成对象形式，</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    name: &apos;&apos;,</span><br><span class=\"line\">    age: &apos;&apos;,</span><br><span class=\"line\">    time: &apos;&apos;,</span><br><span class=\"line\">    data: &apos;&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function arrToObjAdapter() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        name: arr[0],</span><br><span class=\"line\">        age: arr[1]</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 使用</span><br><span class=\"line\">var adapterData = arrToObjAdapter(arr);</span><br><span class=\"line\">console.log(adapterData)  // &#123;name: &apos;javascript&apos;, age: 20, ...&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>服务器端数据适配</p>\n</blockquote>\n<p>它解决了前后端的数据依赖，前端程序不在为后端传递的数据所束缚，如果后端因为架构改变导致传递的数据结构发生变化，我们只需要写个适配器就可以放心了，如果后端的数据经常变化，无法控制数据的格式，那么我们在dosomething时最好不要直接调用，最好先将传递过来的数据适配成对我们可用的数据在使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 为简化模型这里使用jQuery的ajax方法，理想数据是一个一维数组</span><br><span class=\"line\">function ajaxAdapter(data) &#123;</span><br><span class=\"line\">    // 处理数据并返回新数据</span><br><span class=\"line\">    return [data[&apos;key1&apos;], data[&apos;key2&apos;], ...]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    url: &apos;...&apos;,</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">    success: function(data) &#123;</span><br><span class=\"line\">        if(data) &#123;</span><br><span class=\"line\">            doSomethin(ajaxAdapter(data))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 如果以后后端数据有任何变化我们只需相应的更改ajaxAdapter适配器转换格式</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>总结：传统设计模式中，适配器模式往往是适配两个类接口不兼容的问题，然而在JavaScript中，适配器的应用范围更广，比如适配两个代码库，适配前后端数据等等。JavaScript中的适配器的应用，更多应用在对象之间，为了使对象可用，通常我们会将对象拆分并重新包装，这样我们就要了解适配对象的内部结构，这也是与外观模式的区别所在，当然适配器模式同样解决了对象之间的耦合度。包装的适配器代码增加了一些资源开销，当然这是微乎其微的。</p>\n</blockquote>\n<h3 id=\"牛郎织女—代理模式\"><a href=\"#牛郎织女—代理模式\" class=\"headerlink\" title=\"牛郎织女—代理模式\"></a>牛郎织女—代理模式</h3><blockquote>\n<p>代理模式（Proxy）:由于一个对象不能直接应用另一个对象，所以需要通过代理对象在这两个对象之间起到代理作用。</p>\n</blockquote>\n<p>由于用户相册模块上传的照片量越来越大，导致服务器端需要将图片上传模块重新部署到另外一个域，这样对于前端来说，用户上传图片的请求路径发生变化，指向其他服务器，这就导致了跨域问题。</p>\n<blockquote>\n<p>跨域</p>\n<p>站长统计</p>\n<p>JSONP</p>\n<p>代理模板</p>\n</blockquote>\n<h3 id=\"房子装饰—装饰者模式\"><a href=\"#房子装饰—装饰者模式\" class=\"headerlink\" title=\"房子装饰—装饰者模式\"></a>房子装饰—装饰者模式</h3><blockquote>\n<p>装饰者模式（Decorator）:在不改变原对象的基础上，通过对其进行包装扩展（添加属性或者方法）使原有对象可以满足用户的更复杂需求。</p>\n</blockquote>\n<p>静止是相对的，运动是绝对的，所以没有一成不变的需求。</p>\n<p>？？ 情景：给页面所以input添加一个点击隐藏文案提示，注意不要覆盖原有的事件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var input1 = doucument.getElementById(&apos;input1&apos;)</span><br><span class=\"line\">input1.onclick = function() &#123;</span><br><span class=\"line\">    // do something</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var input2 = doucument.getElementById(&apos;input2&apos;)</span><br><span class=\"line\">input2.onclick = function() &#123;</span><br><span class=\"line\">    // do something</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...很多的input</span><br></pre></td></tr></table></figure>\n<p>以上这种解决方法，由于输入框太多，寻找与修改麻烦,所以试试装饰者模式吧！</p>\n<blockquote>\n<p>装饰已有的功能对象</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var decorator = function(input, fn) &#123;</span><br><span class=\"line\">    // 获取事件源</span><br><span class=\"line\">    var input = doucument.getElementById(input);</span><br><span class=\"line\">    // 若事件源已经绑定事件</span><br><span class=\"line\">    if(typeof input.onclick === &apos;function&apos;) &#123;</span><br><span class=\"line\">        // 缓存事件源原有事件函数</span><br><span class=\"line\">        var oldClickFn = input.onclick;</span><br><span class=\"line\">        input.onclick = function() &#123;</span><br><span class=\"line\">            // 事件源原有回调函数</span><br><span class=\"line\">            oldClickFn();</span><br><span class=\"line\">            // 执行事件源添加新增回调函数</span><br><span class=\"line\">            fn();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        input.onclick = fn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // do something</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 使用</span><br><span class=\"line\">decorator（‘input1’, function() &#123;</span><br><span class=\"line\">    // do something</span><br><span class=\"line\">&#125;）</span><br><span class=\"line\">decorator（‘input2’, function() &#123;</span><br><span class=\"line\">    // do something</span><br><span class=\"line\">&#125;）</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>装饰者模式和适配器模式都是对一个对象的修饰来适配其他对象，二者不同，适配器模式是对原有对象适配，添加的方法与原有方法功能上大致相似，装饰者模式提供的方法与原来的方法是有一定区别的，还有最重要的一点是适配器模式新增的方法要调用原来的方法，要了解原有方法具体的细节，而装饰者模式不需要了解对象原有的功能，原方法原封不动的使用。</p>\n<p>总结：装饰模式是一种可以在不了解原有功能的基础上对功能拓展，装饰者模式对对象的拓展是一种良性拓展，不用了解其具体实现，只是在外部进行了一次封装拓展，是对原有功能完整性的一种保护。</p>\n</blockquote>\n<h3 id=\"城市间的道路—桥接模式\"><a href=\"#城市间的道路—桥接模式\" class=\"headerlink\" title=\"城市间的道路—桥接模式\"></a>城市间的道路—桥接模式</h3><blockquote>\n<p>桥接模式（Bridge）：在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦。</p>\n</blockquote>\n<p>有时候页面中的一些小小细节改变常常因逻辑相似导致大片臃肿的代码，让页面苦涩不堪。</p>\n<p>问题：给页面导航栏添加鼠标滑过特效，区别：每个鼠标滑过的效果不一样。。。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var nav = document.getElementByTagName(&apos;span&apos;);</span><br><span class=\"line\">// 不同的绑定不同效果</span><br><span class=\"line\">nav[0].onmouserover = function() &#123;</span><br><span class=\"line\">    this.style.color = &apos;red&apos;;</span><br><span class=\"line\">    this.style.background = &apos;green&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">nav[0].onmouserout = function() &#123;</span><br><span class=\"line\">    this.style.color = &apos;#fff&apos;;</span><br><span class=\"line\">    this.style.background = &apos;#ccc&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">nav[1].onmouseover = function() &#123;</span><br><span class=\"line\">    this.getElementsByTagName(&apos;strong&apos;)[0]style.color = &apos;#fff&apos;;</span><br><span class=\"line\">    this.getElementsByTagName(&apos;strong&apos;)[0]style.background = &apos;#ccc&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">nav[1].onmouseout = function() &#123;</span><br><span class=\"line\">    this.getElementsByTagName(&apos;strong&apos;)[0]style.color = &apos;red&apos;;</span><br><span class=\"line\">    this.getElementsByTagName(&apos;strong&apos;)[0]style.background = &apos;blue&apos;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缺点：功能能实现，但是代码冗余。<br>解决方法：提取共同点，，对相同的逻辑做抽象提取处理，解除与事件中this的耦合。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function changeColor(dom, color, bg) &#123;</span><br><span class=\"line\">    dom.style.color = color;</span><br><span class=\"line\">    dom.style.background = bg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下一步：事件与业务逻辑之间的桥梁—桥接模式</p>\n<p>对于事件桥接方法，可以用一个匿名函数来代替，否则直接将changeColor作为事件的回调函数，解除this耦合。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nav[0].onmouserover = function() &#123;</span><br><span class=\"line\">    changeColor(this, &apos;red&apos;, &apos;#fff&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方法是以新增一个桥接函数为代价实现的。</p>\n<blockquote>\n<p>多元化对象</p>\n</blockquote>\n<p>桥接模式对于多维的变化也同样适用，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Speed(x, y) &#123;</span><br><span class=\"line\">    this.x = x;</span><br><span class=\"line\">    this.y = y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Speed.prototype.run = function() &#123;</span><br><span class=\"line\">    // do something</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Color(cl) &#123;</span><br><span class=\"line\">    this.cl = cl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Color.prtotype.draw = function() &#123;</span><br><span class=\"line\">    // do something</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">function Ball(x, y ,c) &#123;</span><br><span class=\"line\">    this.speed = new Speed(x, y);</span><br><span class=\"line\">    this.color = new Color(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Ball.prototype = function() &#123;</span><br><span class=\"line\">    this.speed.run();</span><br><span class=\"line\">    this.color.draw();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结：桥接模式主要特点：将实现层（如元素绑定的事件）与抽象层（如修饰页面UI逻辑）解耦分离，使两部分可以独立变化，由此可以看出桥接模式主要是对结构之间的结构，而抽象工厂模式与创建者模式主要业务在于创建，通过桥接模式实现的解耦，使实现层与抽象层分开处理，避免需求的改变造成对象内部的修改，体现了面向对象对扩展的开放及对修改的关闭原则。当然由于桥接的添加，有时也造成开发成本的增加，有时性能上也会受到影响。</p>\n<h3 id=\"超值午餐—组合模式\"><a href=\"#超值午餐—组合模式\" class=\"headerlink\" title=\"超值午餐—组合模式\"></a>超值午餐—组合模式</h3><blockquote>\n<p>组合模式（Composite）:又称部分-整体模式，将对象组合成树形结构以表示‘整体部分’的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>\n</blockquote>\n<h3 id=\"城市公交车—享元模式\"><a href=\"#城市公交车—享元模式\" class=\"headerlink\" title=\"城市公交车—享元模式\"></a>城市公交车—享元模式</h3><blockquote>\n<p>享元模式（Flyweight）运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多于的开销。</p>\n</blockquote>\n<p>总结：享元模式的应用目的是为了提高程序的执行效率与系统的性能，因此在大型系统开发中应用是比较广泛的，百分之一的效率提成有时可以发生质的改变，它可以避免程序中的数据重复，</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>结构型设计模式关注于如何将类或者对象组合成更大，更复杂的结构，以简化设计。</p>\n</blockquote>","more":"<h3 id=\"套餐服务—外观模式\"><a href=\"#套餐服务—外观模式\" class=\"headerlink\" title=\"套餐服务—外观模式\"></a>套餐服务—外观模式</h3><blockquote>\n<p>外观模式（Facade）：为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口，使得对子系统接口的访问更容易，在Javascript中有时也会用于对底层结构兼容性做统一封装来简化用户使用。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 外观模式实现</span><br><span class=\"line\">//提供一个更简单的高级接口，简化了我们对复杂的底层接口不统一的使用要求</span><br><span class=\"line\">function addEvent(dom, type, fn) &#123;</span><br><span class=\"line\">    if(dom.addEventListener) &#123;</span><br><span class=\"line\">        dom.addEventListener(type, fn, false)</span><br><span class=\"line\">    &#125; else if(dom.attachEvent)&#123;</span><br><span class=\"line\">        dom.attachEvent(&apos;on&apos;+type, fn)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        dom[&apos;on&apos;+type] = fn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用</span><br><span class=\"line\">var DOM = document.getElementById(&apos;dom&apos;);</span><br><span class=\"line\">addEvent(Dom, &apos;click&apos;, function() &#123;</span><br><span class=\"line\">    // 绑定的第一个事件</span><br><span class=\"line\">    console.log(&apos;绑定的第一个事件&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">addEvent(Dom, &apos;click&apos;, function() &#123;</span><br><span class=\"line\">    // 绑定的第一个事件</span><br><span class=\"line\">    console.log(&apos;绑定的第二个事件&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 获取事件对象</span><br><span class=\"line\">var getEvent = function (event) &#123;</span><br><span class=\"line\">    // 标准浏览器返回event  IE window.event</span><br><span class=\"line\">    return event || window.event;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 获取元素</span><br><span class=\"line\">var getTarget = function(event) &#123;</span><br><span class=\"line\">    var event = getEvent(event);</span><br><span class=\"line\">    // 标准浏览器下event.target  IE下event.srcElement</span><br><span class=\"line\">    return event.target || event.srcElement;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 阻止默认行为</span><br><span class=\"line\">var preventDefault = function (event) &#123;</span><br><span class=\"line\">    var event = getEvent(event);</span><br><span class=\"line\">    // 标准浏览器</span><br><span class=\"line\">    if(event.preventDefault) &#123;</span><br><span class=\"line\">        event.preventDefault</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        // IE</span><br><span class=\"line\">        event.returnValue = false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//使用</span><br><span class=\"line\">document.onclick = function (e) &#123;</span><br><span class=\"line\">    preventDefault(e);</span><br><span class=\"line\">    if(getTarget(e) === Dom) &#123;</span><br><span class=\"line\">        // do somethihng</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>总结：外观模式是对接口方法的外层包装，以供上层代码调用以供上层代码使用，因此有时外观模式封装的接口方法不需要接口的具体实现，只需要按照接口使用规则使用即可，这也是对系统与使用者之间的一种松散耦合，使得系统与使用者之间不会因结构的变化而相互影响。</p>\n</blockquote>\n<h3 id=\"水管弯弯—适配器模式\"><a href=\"#水管弯弯—适配器模式\" class=\"headerlink\" title=\"水管弯弯—适配器模式\"></a>水管弯弯—适配器模式</h3><blockquote>\n<p>适配器模式(Adapter): 将一个类（对象）的接口（方法或属性）转化成另外一个接口，以满足用户需求，使类（对象）之间接口的不兼容问题通过适配器得以解决。</p>\n<p>生活中的适配器两根垂直相交的水管连接处的的直角弯管，使得两个不同方向的水管可以疏通流水，三角插头手机充电器对于两项插头是不可用的，此时需要一个三项转两项插头电源适配器等等，这些都是适配器。代码写适配器，其实就是为两个代码库所写的代码兼容运行而书写的额外代码，有了这样的适配器，你就不需要特意地重写以前的功能代码了。</p>\n<p>jQuery适配器</p>\n</blockquote>\n<p>某框架A和jQuery代码书写风格很像，加载完jQuery框架后写一个适配器，将我们已有的功能适配到jQuery，假如代码中有两个事件<br>，一个加载，一个点击，不过这两个事件与jQuery中的写法很像，所以做的改动不会太大，我们的适配器的主要任务是适配两种代码库中不兼容的代码，那么首当其冲的就是全局对象A与jQuery了，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.A = A = jQuery;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>适配异类框架</p>\n</blockquote>\n<p>如果两个框架直接相差太大，对于这种异类框架适配情况就复杂多了，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义框架</span><br><span class=\"line\">var A = A|| &#123;&#125;</span><br><span class=\"line\">A.g = function(id) &#123;</span><br><span class=\"line\">    return document.getElementById(id)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 为元素绑定事件</span><br><span class=\"line\">A.on= function(id, type, fn) &#123;</span><br><span class=\"line\">    // 如果传递参数是字符串则以id处理，负责以元素对象处理，</span><br><span class=\"line\">    var dom = typeof id === &apos;string&apos; ? this.g(id) : id;</span><br><span class=\"line\">    // 标准dom2级添加事件方式</span><br><span class=\"line\">    if(dom.addEventListener) &#123;</span><br><span class=\"line\">        dom.addEventListener(type, fn, false)</span><br><span class=\"line\">    &#125; else if(dom.attachEvent)&#123;</span><br><span class=\"line\">        dom.attachEvent(&apos;on&apos;+type, fn)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        dom[&apos;on&apos;+type] = fn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 使用</span><br><span class=\"line\">A.on(window, &apos;load&apos;, function() &#123;</span><br><span class=\"line\">    A.on(&apos;dom&apos;, &apos;click&apos;, function() &#123;</span><br><span class=\"line\">        // do something</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 引入jQuery来换A库</span><br><span class=\"line\">A.g = function(id) &#123;</span><br><span class=\"line\">    // 通过jQuery获取jQuery对象，然后返回第一个成员</span><br><span class=\"line\">    return $(id).get(0)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A.on = function(id, type, fn) &#123;</span><br><span class=\"line\">    // 如果传递参数是字符串则以id处理，否则以元素对象处理，</span><br><span class=\"line\">    var dom = typeof id === &apos;string&apos; ? $(&apos;#&apos; + id) : $(id);</span><br><span class=\"line\">    dom.on(type, fn);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 通过适配器发现如果两种框架的比较相似，适配比较容易，否则写起来复杂很多，因此尽量引入相似框架。</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>参数适配器</p>\n</blockquote>\n<p>适配器还有很多用途，比如方法需要传递多个参数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function dosomething(name, title, age, color, size, prize) &#123;</span><br><span class=\"line\">    // 记住参数顺序是很困难的，因此我们经常以一个参数对象方式传入</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    name: name,</span><br><span class=\"line\">    title: title</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function dosomething(obj) &#123;&#125;</span><br><span class=\"line\">// 然而调用的时候不知道传递的参数是否完整，如有一些必须参数没有传入，一些参数是有默认值得等等，此时我们通常的做法是用适配器来适配传入的这个参数对象</span><br><span class=\"line\"></span><br><span class=\"line\">function doSomething(obj) &#123;</span><br><span class=\"line\">    var _adapter = &#123;</span><br><span class=\"line\">        name: &apos;me&apos;,</span><br><span class=\"line\">        title: &apos;设计模式&apos;，</span><br><span class=\"line\">        age: 24,</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for(var i in _adapter) &#123;</span><br><span class=\"line\">        _adapter[i] = obj[i] || _adapter[i];</span><br><span class=\"line\">        // 或者 extend(_adapter, obj)   //  此时可能会多添加属性</span><br><span class=\"line\">        // do something</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>数据适配</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [&apos;javascript&apos;,20,&apos;时间&apos;， ‘日期’]</span><br><span class=\"line\">// 我们发现数组中的每个成员代表的意义不同，这种数据结构语义不好，我们通常会将其适配成对象形式，</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    name: &apos;&apos;,</span><br><span class=\"line\">    age: &apos;&apos;,</span><br><span class=\"line\">    time: &apos;&apos;,</span><br><span class=\"line\">    data: &apos;&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function arrToObjAdapter() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        name: arr[0],</span><br><span class=\"line\">        age: arr[1]</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 使用</span><br><span class=\"line\">var adapterData = arrToObjAdapter(arr);</span><br><span class=\"line\">console.log(adapterData)  // &#123;name: &apos;javascript&apos;, age: 20, ...&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>服务器端数据适配</p>\n</blockquote>\n<p>它解决了前后端的数据依赖，前端程序不在为后端传递的数据所束缚，如果后端因为架构改变导致传递的数据结构发生变化，我们只需要写个适配器就可以放心了，如果后端的数据经常变化，无法控制数据的格式，那么我们在dosomething时最好不要直接调用，最好先将传递过来的数据适配成对我们可用的数据在使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 为简化模型这里使用jQuery的ajax方法，理想数据是一个一维数组</span><br><span class=\"line\">function ajaxAdapter(data) &#123;</span><br><span class=\"line\">    // 处理数据并返回新数据</span><br><span class=\"line\">    return [data[&apos;key1&apos;], data[&apos;key2&apos;], ...]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    url: &apos;...&apos;,</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">    success: function(data) &#123;</span><br><span class=\"line\">        if(data) &#123;</span><br><span class=\"line\">            doSomethin(ajaxAdapter(data))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 如果以后后端数据有任何变化我们只需相应的更改ajaxAdapter适配器转换格式</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>总结：传统设计模式中，适配器模式往往是适配两个类接口不兼容的问题，然而在JavaScript中，适配器的应用范围更广，比如适配两个代码库，适配前后端数据等等。JavaScript中的适配器的应用，更多应用在对象之间，为了使对象可用，通常我们会将对象拆分并重新包装，这样我们就要了解适配对象的内部结构，这也是与外观模式的区别所在，当然适配器模式同样解决了对象之间的耦合度。包装的适配器代码增加了一些资源开销，当然这是微乎其微的。</p>\n</blockquote>\n<h3 id=\"牛郎织女—代理模式\"><a href=\"#牛郎织女—代理模式\" class=\"headerlink\" title=\"牛郎织女—代理模式\"></a>牛郎织女—代理模式</h3><blockquote>\n<p>代理模式（Proxy）:由于一个对象不能直接应用另一个对象，所以需要通过代理对象在这两个对象之间起到代理作用。</p>\n</blockquote>\n<p>由于用户相册模块上传的照片量越来越大，导致服务器端需要将图片上传模块重新部署到另外一个域，这样对于前端来说，用户上传图片的请求路径发生变化，指向其他服务器，这就导致了跨域问题。</p>\n<blockquote>\n<p>跨域</p>\n<p>站长统计</p>\n<p>JSONP</p>\n<p>代理模板</p>\n</blockquote>\n<h3 id=\"房子装饰—装饰者模式\"><a href=\"#房子装饰—装饰者模式\" class=\"headerlink\" title=\"房子装饰—装饰者模式\"></a>房子装饰—装饰者模式</h3><blockquote>\n<p>装饰者模式（Decorator）:在不改变原对象的基础上，通过对其进行包装扩展（添加属性或者方法）使原有对象可以满足用户的更复杂需求。</p>\n</blockquote>\n<p>静止是相对的，运动是绝对的，所以没有一成不变的需求。</p>\n<p>？？ 情景：给页面所以input添加一个点击隐藏文案提示，注意不要覆盖原有的事件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var input1 = doucument.getElementById(&apos;input1&apos;)</span><br><span class=\"line\">input1.onclick = function() &#123;</span><br><span class=\"line\">    // do something</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var input2 = doucument.getElementById(&apos;input2&apos;)</span><br><span class=\"line\">input2.onclick = function() &#123;</span><br><span class=\"line\">    // do something</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...很多的input</span><br></pre></td></tr></table></figure>\n<p>以上这种解决方法，由于输入框太多，寻找与修改麻烦,所以试试装饰者模式吧！</p>\n<blockquote>\n<p>装饰已有的功能对象</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var decorator = function(input, fn) &#123;</span><br><span class=\"line\">    // 获取事件源</span><br><span class=\"line\">    var input = doucument.getElementById(input);</span><br><span class=\"line\">    // 若事件源已经绑定事件</span><br><span class=\"line\">    if(typeof input.onclick === &apos;function&apos;) &#123;</span><br><span class=\"line\">        // 缓存事件源原有事件函数</span><br><span class=\"line\">        var oldClickFn = input.onclick;</span><br><span class=\"line\">        input.onclick = function() &#123;</span><br><span class=\"line\">            // 事件源原有回调函数</span><br><span class=\"line\">            oldClickFn();</span><br><span class=\"line\">            // 执行事件源添加新增回调函数</span><br><span class=\"line\">            fn();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        input.onclick = fn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // do something</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 使用</span><br><span class=\"line\">decorator（‘input1’, function() &#123;</span><br><span class=\"line\">    // do something</span><br><span class=\"line\">&#125;）</span><br><span class=\"line\">decorator（‘input2’, function() &#123;</span><br><span class=\"line\">    // do something</span><br><span class=\"line\">&#125;）</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>装饰者模式和适配器模式都是对一个对象的修饰来适配其他对象，二者不同，适配器模式是对原有对象适配，添加的方法与原有方法功能上大致相似，装饰者模式提供的方法与原来的方法是有一定区别的，还有最重要的一点是适配器模式新增的方法要调用原来的方法，要了解原有方法具体的细节，而装饰者模式不需要了解对象原有的功能，原方法原封不动的使用。</p>\n<p>总结：装饰模式是一种可以在不了解原有功能的基础上对功能拓展，装饰者模式对对象的拓展是一种良性拓展，不用了解其具体实现，只是在外部进行了一次封装拓展，是对原有功能完整性的一种保护。</p>\n</blockquote>\n<h3 id=\"城市间的道路—桥接模式\"><a href=\"#城市间的道路—桥接模式\" class=\"headerlink\" title=\"城市间的道路—桥接模式\"></a>城市间的道路—桥接模式</h3><blockquote>\n<p>桥接模式（Bridge）：在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦。</p>\n</blockquote>\n<p>有时候页面中的一些小小细节改变常常因逻辑相似导致大片臃肿的代码，让页面苦涩不堪。</p>\n<p>问题：给页面导航栏添加鼠标滑过特效，区别：每个鼠标滑过的效果不一样。。。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var nav = document.getElementByTagName(&apos;span&apos;);</span><br><span class=\"line\">// 不同的绑定不同效果</span><br><span class=\"line\">nav[0].onmouserover = function() &#123;</span><br><span class=\"line\">    this.style.color = &apos;red&apos;;</span><br><span class=\"line\">    this.style.background = &apos;green&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">nav[0].onmouserout = function() &#123;</span><br><span class=\"line\">    this.style.color = &apos;#fff&apos;;</span><br><span class=\"line\">    this.style.background = &apos;#ccc&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">nav[1].onmouseover = function() &#123;</span><br><span class=\"line\">    this.getElementsByTagName(&apos;strong&apos;)[0]style.color = &apos;#fff&apos;;</span><br><span class=\"line\">    this.getElementsByTagName(&apos;strong&apos;)[0]style.background = &apos;#ccc&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">nav[1].onmouseout = function() &#123;</span><br><span class=\"line\">    this.getElementsByTagName(&apos;strong&apos;)[0]style.color = &apos;red&apos;;</span><br><span class=\"line\">    this.getElementsByTagName(&apos;strong&apos;)[0]style.background = &apos;blue&apos;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缺点：功能能实现，但是代码冗余。<br>解决方法：提取共同点，，对相同的逻辑做抽象提取处理，解除与事件中this的耦合。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function changeColor(dom, color, bg) &#123;</span><br><span class=\"line\">    dom.style.color = color;</span><br><span class=\"line\">    dom.style.background = bg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下一步：事件与业务逻辑之间的桥梁—桥接模式</p>\n<p>对于事件桥接方法，可以用一个匿名函数来代替，否则直接将changeColor作为事件的回调函数，解除this耦合。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nav[0].onmouserover = function() &#123;</span><br><span class=\"line\">    changeColor(this, &apos;red&apos;, &apos;#fff&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方法是以新增一个桥接函数为代价实现的。</p>\n<blockquote>\n<p>多元化对象</p>\n</blockquote>\n<p>桥接模式对于多维的变化也同样适用，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Speed(x, y) &#123;</span><br><span class=\"line\">    this.x = x;</span><br><span class=\"line\">    this.y = y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Speed.prototype.run = function() &#123;</span><br><span class=\"line\">    // do something</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Color(cl) &#123;</span><br><span class=\"line\">    this.cl = cl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Color.prtotype.draw = function() &#123;</span><br><span class=\"line\">    // do something</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">function Ball(x, y ,c) &#123;</span><br><span class=\"line\">    this.speed = new Speed(x, y);</span><br><span class=\"line\">    this.color = new Color(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Ball.prototype = function() &#123;</span><br><span class=\"line\">    this.speed.run();</span><br><span class=\"line\">    this.color.draw();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结：桥接模式主要特点：将实现层（如元素绑定的事件）与抽象层（如修饰页面UI逻辑）解耦分离，使两部分可以独立变化，由此可以看出桥接模式主要是对结构之间的结构，而抽象工厂模式与创建者模式主要业务在于创建，通过桥接模式实现的解耦，使实现层与抽象层分开处理，避免需求的改变造成对象内部的修改，体现了面向对象对扩展的开放及对修改的关闭原则。当然由于桥接的添加，有时也造成开发成本的增加，有时性能上也会受到影响。</p>\n<h3 id=\"超值午餐—组合模式\"><a href=\"#超值午餐—组合模式\" class=\"headerlink\" title=\"超值午餐—组合模式\"></a>超值午餐—组合模式</h3><blockquote>\n<p>组合模式（Composite）:又称部分-整体模式，将对象组合成树形结构以表示‘整体部分’的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>\n</blockquote>\n<h3 id=\"城市公交车—享元模式\"><a href=\"#城市公交车—享元模式\" class=\"headerlink\" title=\"城市公交车—享元模式\"></a>城市公交车—享元模式</h3><blockquote>\n<p>享元模式（Flyweight）运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多于的开销。</p>\n</blockquote>\n<p>总结：享元模式的应用目的是为了提高程序的执行效率与系统的性能，因此在大型系统开发中应用是比较广泛的，百分之一的效率提成有时可以发生质的改变，它可以避免程序中的数据重复，</p>"},{"title":"Git","author":"heqing","date":"2017-10-24T12:06:50.000Z","_content":"> 零基础浅显易懂的Git教程,一步步从创建本地到远程仓库, git指令清晰明了\n\n####  安装\n\n* [官网下载](https://git-scm.com/downloads)\n<!--more-->\n#### 创建版本库\n\n```\n  mkdir learngit\n  cd learngit\n\n```\n\n#### 将目录变成Git可以管理的仓库\n\n```\ngit init\nls -ah                //查看.git文件, 看仓库是否建成功\n\n```\n\n#### 新建分支\n\n```\ngit checkout -b dev   //创建dev分支兵切换到dev 等价于\n\ngit branch dev        //创建dev分支\ngit checkout dev      //切换到dev分支\n\ngit branch            //查看当前分支\ngit branch -d dev     //删除dev分支\ngit merge master      //合并分支到当前分支, 在当前分支\n```\n#### 提交文件到暂存区\n\n```\ngit add readme.txt    //提交指定文件\ngit add .             //提交所有文件\ngit status            //查看发生了哪些变化\n\n```\n\n#### 暂存区内容提交到当前分支\n\n```\ngit commit -m   '提交的提示语'\ngit status           //  查看发生了哪些变化\n\n```\n\n#### 创建远程仓库\n\n```\nssh-keygen -t rsa -C \"youremail@example.com\"  //获取秘钥\n\n用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人\n\n登陆GitHub，打开“Account settings”，“SSH Keys”页面：\n\n点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容\n\n```\n\n#### 本地与远程库关联\n\n```\ngit remote add origin git@github.com:myname/learngit.git\n\n```\n\n#### 将本地仓库推送到远程\n\n```\ngit push -u origin master    \n//远程仓库默叫origin, 第一个推送加-u, Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的//master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令\n```\n\n#### 从远程仓库克隆\n\n```\ngit clone '远程仓库地址'\n\n```\n\n#### 推荐可视化工具(TortoiseGit、SourceTree、GitGUI等等)\n\n\n\n","source":"_posts/工具/Git.md","raw":"---\ntitle: Git\nauthor: heqing\ncategories:\n  - 工具\ntags:\n  - Git\ndate: 2017-10-24 20:06:50\n---\n> 零基础浅显易懂的Git教程,一步步从创建本地到远程仓库, git指令清晰明了\n\n####  安装\n\n* [官网下载](https://git-scm.com/downloads)\n<!--more-->\n#### 创建版本库\n\n```\n  mkdir learngit\n  cd learngit\n\n```\n\n#### 将目录变成Git可以管理的仓库\n\n```\ngit init\nls -ah                //查看.git文件, 看仓库是否建成功\n\n```\n\n#### 新建分支\n\n```\ngit checkout -b dev   //创建dev分支兵切换到dev 等价于\n\ngit branch dev        //创建dev分支\ngit checkout dev      //切换到dev分支\n\ngit branch            //查看当前分支\ngit branch -d dev     //删除dev分支\ngit merge master      //合并分支到当前分支, 在当前分支\n```\n#### 提交文件到暂存区\n\n```\ngit add readme.txt    //提交指定文件\ngit add .             //提交所有文件\ngit status            //查看发生了哪些变化\n\n```\n\n#### 暂存区内容提交到当前分支\n\n```\ngit commit -m   '提交的提示语'\ngit status           //  查看发生了哪些变化\n\n```\n\n#### 创建远程仓库\n\n```\nssh-keygen -t rsa -C \"youremail@example.com\"  //获取秘钥\n\n用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人\n\n登陆GitHub，打开“Account settings”，“SSH Keys”页面：\n\n点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容\n\n```\n\n#### 本地与远程库关联\n\n```\ngit remote add origin git@github.com:myname/learngit.git\n\n```\n\n#### 将本地仓库推送到远程\n\n```\ngit push -u origin master    \n//远程仓库默叫origin, 第一个推送加-u, Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的//master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令\n```\n\n#### 从远程仓库克隆\n\n```\ngit clone '远程仓库地址'\n\n```\n\n#### 推荐可视化工具(TortoiseGit、SourceTree、GitGUI等等)\n\n\n\n","slug":"工具/Git","published":1,"updated":"2017-10-30T11:40:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaqhv1gh000abtx1pjuk2htf","content":"<blockquote>\n<p>零基础浅显易懂的Git教程,一步步从创建本地到远程仓库, git指令清晰明了</p>\n</blockquote>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><ul>\n<li><a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"noopener\">官网下载</a><a id=\"more\"></a>\n<h4 id=\"创建版本库\"><a href=\"#创建版本库\" class=\"headerlink\" title=\"创建版本库\"></a>创建版本库</h4></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir learngit</span><br><span class=\"line\">cd learngit</span><br></pre></td></tr></table></figure>\n<h4 id=\"将目录变成Git可以管理的仓库\"><a href=\"#将目录变成Git可以管理的仓库\" class=\"headerlink\" title=\"将目录变成Git可以管理的仓库\"></a>将目录变成Git可以管理的仓库</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">ls -ah                //查看.git文件, 看仓库是否建成功</span><br></pre></td></tr></table></figure>\n<h4 id=\"新建分支\"><a href=\"#新建分支\" class=\"headerlink\" title=\"新建分支\"></a>新建分支</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b dev   //创建dev分支兵切换到dev 等价于</span><br><span class=\"line\"></span><br><span class=\"line\">git branch dev        //创建dev分支</span><br><span class=\"line\">git checkout dev      //切换到dev分支</span><br><span class=\"line\"></span><br><span class=\"line\">git branch            //查看当前分支</span><br><span class=\"line\">git branch -d dev     //删除dev分支</span><br><span class=\"line\">git merge master      //合并分支到当前分支, 在当前分支</span><br></pre></td></tr></table></figure>\n<h4 id=\"提交文件到暂存区\"><a href=\"#提交文件到暂存区\" class=\"headerlink\" title=\"提交文件到暂存区\"></a>提交文件到暂存区</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add readme.txt    //提交指定文件</span><br><span class=\"line\">git add .             //提交所有文件</span><br><span class=\"line\">git status            //查看发生了哪些变化</span><br></pre></td></tr></table></figure>\n<h4 id=\"暂存区内容提交到当前分支\"><a href=\"#暂存区内容提交到当前分支\" class=\"headerlink\" title=\"暂存区内容提交到当前分支\"></a>暂存区内容提交到当前分支</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m   &apos;提交的提示语&apos;</span><br><span class=\"line\">git status           //  查看发生了哪些变化</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建远程仓库\"><a href=\"#创建远程仓库\" class=\"headerlink\" title=\"创建远程仓库\"></a>创建远程仓库</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;  //获取秘钥</span><br><span class=\"line\"></span><br><span class=\"line\">用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人</span><br><span class=\"line\"></span><br><span class=\"line\">登陆GitHub，打开“Account settings”，“SSH Keys”页面：</span><br><span class=\"line\"></span><br><span class=\"line\">点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容</span><br></pre></td></tr></table></figure>\n<h4 id=\"本地与远程库关联\"><a href=\"#本地与远程库关联\" class=\"headerlink\" title=\"本地与远程库关联\"></a>本地与远程库关联</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin git@github.com:myname/learngit.git</span><br></pre></td></tr></table></figure>\n<h4 id=\"将本地仓库推送到远程\"><a href=\"#将本地仓库推送到远程\" class=\"headerlink\" title=\"将本地仓库推送到远程\"></a>将本地仓库推送到远程</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master    </span><br><span class=\"line\">//远程仓库默叫origin, 第一个推送加-u, Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的//master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令</span><br></pre></td></tr></table></figure>\n<h4 id=\"从远程仓库克隆\"><a href=\"#从远程仓库克隆\" class=\"headerlink\" title=\"从远程仓库克隆\"></a>从远程仓库克隆</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone &apos;远程仓库地址&apos;</span><br></pre></td></tr></table></figure>\n<h4 id=\"推荐可视化工具-TortoiseGit、SourceTree、GitGUI等等\"><a href=\"#推荐可视化工具-TortoiseGit、SourceTree、GitGUI等等\" class=\"headerlink\" title=\"推荐可视化工具(TortoiseGit、SourceTree、GitGUI等等)\"></a>推荐可视化工具(TortoiseGit、SourceTree、GitGUI等等)</h4>","site":{"data":{}},"excerpt":"<blockquote>\n<p>零基础浅显易懂的Git教程,一步步从创建本地到远程仓库, git指令清晰明了</p>\n</blockquote>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><ul>\n<li><a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"noopener\">官网下载</a>","more":"<h4 id=\"创建版本库\"><a href=\"#创建版本库\" class=\"headerlink\" title=\"创建版本库\"></a>创建版本库</h4></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir learngit</span><br><span class=\"line\">cd learngit</span><br></pre></td></tr></table></figure>\n<h4 id=\"将目录变成Git可以管理的仓库\"><a href=\"#将目录变成Git可以管理的仓库\" class=\"headerlink\" title=\"将目录变成Git可以管理的仓库\"></a>将目录变成Git可以管理的仓库</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">ls -ah                //查看.git文件, 看仓库是否建成功</span><br></pre></td></tr></table></figure>\n<h4 id=\"新建分支\"><a href=\"#新建分支\" class=\"headerlink\" title=\"新建分支\"></a>新建分支</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b dev   //创建dev分支兵切换到dev 等价于</span><br><span class=\"line\"></span><br><span class=\"line\">git branch dev        //创建dev分支</span><br><span class=\"line\">git checkout dev      //切换到dev分支</span><br><span class=\"line\"></span><br><span class=\"line\">git branch            //查看当前分支</span><br><span class=\"line\">git branch -d dev     //删除dev分支</span><br><span class=\"line\">git merge master      //合并分支到当前分支, 在当前分支</span><br></pre></td></tr></table></figure>\n<h4 id=\"提交文件到暂存区\"><a href=\"#提交文件到暂存区\" class=\"headerlink\" title=\"提交文件到暂存区\"></a>提交文件到暂存区</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add readme.txt    //提交指定文件</span><br><span class=\"line\">git add .             //提交所有文件</span><br><span class=\"line\">git status            //查看发生了哪些变化</span><br></pre></td></tr></table></figure>\n<h4 id=\"暂存区内容提交到当前分支\"><a href=\"#暂存区内容提交到当前分支\" class=\"headerlink\" title=\"暂存区内容提交到当前分支\"></a>暂存区内容提交到当前分支</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m   &apos;提交的提示语&apos;</span><br><span class=\"line\">git status           //  查看发生了哪些变化</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建远程仓库\"><a href=\"#创建远程仓库\" class=\"headerlink\" title=\"创建远程仓库\"></a>创建远程仓库</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;  //获取秘钥</span><br><span class=\"line\"></span><br><span class=\"line\">用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人</span><br><span class=\"line\"></span><br><span class=\"line\">登陆GitHub，打开“Account settings”，“SSH Keys”页面：</span><br><span class=\"line\"></span><br><span class=\"line\">点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容</span><br></pre></td></tr></table></figure>\n<h4 id=\"本地与远程库关联\"><a href=\"#本地与远程库关联\" class=\"headerlink\" title=\"本地与远程库关联\"></a>本地与远程库关联</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin git@github.com:myname/learngit.git</span><br></pre></td></tr></table></figure>\n<h4 id=\"将本地仓库推送到远程\"><a href=\"#将本地仓库推送到远程\" class=\"headerlink\" title=\"将本地仓库推送到远程\"></a>将本地仓库推送到远程</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master    </span><br><span class=\"line\">//远程仓库默叫origin, 第一个推送加-u, Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的//master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令</span><br></pre></td></tr></table></figure>\n<h4 id=\"从远程仓库克隆\"><a href=\"#从远程仓库克隆\" class=\"headerlink\" title=\"从远程仓库克隆\"></a>从远程仓库克隆</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone &apos;远程仓库地址&apos;</span><br></pre></td></tr></table></figure>\n<h4 id=\"推荐可视化工具-TortoiseGit、SourceTree、GitGUI等等\"><a href=\"#推荐可视化工具-TortoiseGit、SourceTree、GitGUI等等\" class=\"headerlink\" title=\"推荐可视化工具(TortoiseGit、SourceTree、GitGUI等等)\"></a>推荐可视化工具(TortoiseGit、SourceTree、GitGUI等等)</h4>"},{"title":"vsCode插件","author":"heqing","date":"2017-12-03T05:38:50.000Z","_content":"\n> Microsoft在2015年4月30日Build 开发者大会上正式宣布了 Visual Studio Code 项目：一个运行于 Mac OS X、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器,一款轻量，采取了和VS相同的UI界面，搭配合适的插件可以优化前端开发的体验\n\n<!-- more -->\n\n### 安装\n\n[vscode官网](https://code.visualstudio.com/Download)\n\nVScode 中文设置\n\n1. 快捷键F1\n2. 输入Configure Language 回车\n3. “locale”:  \"zh-CN\"，locale设置为zh-CNK\n4. 保存, 重启vscode\n\n### 布局\n\n* 左侧是用于展示所要编辑的所有文件和文件夹的文件管理器，依次是`资源管理器`，`搜索`，`GIT`，`调试`，`插件`，\n\n* 右侧是打开文件的编辑区域，最多可同时打开三个编辑区域到侧边。\n\n* 底栏：依次是`Git Branch`，`error&warning`，`编码格式`等。\n\n### 插件\n\n* vscode-icon\n\nF1->icon-->icon Theme-->选择(安装自己喜欢的主题)\n\n> 这款必须要推荐，明显提升效率的小插件，在项目文件多类型多的情况下，找到制定文件会大大缩短时间；\n\n* fileheader\n\n修改作者 文件--->首选项--->设置--->fileheader--->修改\n\n> 顶部注释模板，可定义作者、时间等信息，并会自动更新最后修改时间, 快捷键 Ctrl+Alt+i\n\n* HTML Snippets \n\nCtrl+Shift+P-->输入snippets-->选择语言-->打开.json文件-->配置-->使用\n\n> 超级实用且初级的 H5代码片段以及提示\n\n* JavaScript Snippet Pack\n\n> 针对js的插件，包含了js的常用语法关键字，很实用, 代码片段(Tab或者Enter补全)\n\n* JavaScript Snippets\n\n> 此扩展包含Visual Studio代码编辑器（支持JavaScript和TypeScript）的ES6语法中的JavaScript代码片段。\n\n* HTML CSS Support\n\n> 在编写样式表的时候，自动补全功能大大缩减了编写时间，推荐！让 html 标签上写class 智能提示当前项目所支持的样式新版已经支持scss文件检索   (提示已有的class名)\n\n* Auto Close Tag\n\n> 编写html代码的时候，写完开始标签，这款插件会自动补全结束标签，其实上面所说的html自动补全插件一个Tab就搞定了，不过有时也需要这款插件；\n\n* Auto Rename Tag\n\n> 非常实用！要修改标签名称的时候自动修改结束标签，节省一半时间，提升效率，非常棒！\n\n* Document this\n\n> js 的注释模板 （注意：新版的vscode已经原生支持,在function上输入/** tab） Ctrl+Alt+D 快捷键, 光标放在关键字上\n\n* Change Case\n\n下划线命名  <-->   驼峰命名    大小写转换   \n\n> 虽然 VSCode 内置了开箱即用的文本转换选项，但其只能进行文本大小写的转换。而此插件则添加了用于修改文本的更多命名格式，包括驼峰命名、下划线分隔命名，snake_case 命名以及 CONST_CAS 命名等\n\n* jQuery Code Snippets\n\n> jquery提示插件\n\n* Path Intellisense\n\n> 自动路劲补全，默认不带这个功能的，赶紧装\n\n* Emoji  \n\nF1-->emo-->选择插入\n\n> 很好玩的一款插件，可以在代码中插入emoji了，也许是程序猿的娱乐方式吧；\n\n* Open-In-Browser\n\n> 由于 VSCode 没有提供直接在浏览器中打开文件的内置界面，所以此插件在快捷菜单中添加了在默认浏览器查看文件选项，以及在客户端（Firefox，Chrome，IE）中打开命令面板选项\n\n* Code Runner\n\n> 非常强大的一款插件，能够运行多种语言的代码片段或代码文件：C，C ++，Java，JavaScript，PHP，Python，Perl，Ruby，Go等等，安装完成后，右上角出现一个三角形，点击这个按钮就可以运行你的文件了（必备）。\n\n* Dash\n\n> 查文档必备，搭配 dash（不过似乎只有 mac 版）,快捷键 ctrl + h 它根据你当前选中的语言查找 dash 里面的文档\n\n* Debugger for Chrome\n\n> 让 vscode 映射 chrome 的 debug功能，使静态页面都可以用 vscode 来打断点调试\n\n* CSS Peek(窥视)\n\n> 使用此插件，你可以追踪至样式表中 CSS 类和 ids 定义的地方。当你在 HTML 文件中右键单击选择器时，选择“ Go to Definition 和 Peek definition ”选项，它便会给你发送样式设置的 CSS 代码。\n\n* HTML Boilerplate(样板)\n\n> 通过使用 HTML 模版插件，你就摆脱了为 HTML 新文件重新编写头部和正文标签的苦恼。你只需在空文件中输入 html，并按 Tab 键，即可生成干净的文档结构。\n\n* Prettier(格式化)\n\n快捷键 Shift+Alt+F /////  Ctrl+Shift+P(F1)-->键入format-->格式化代码\n\n> Prettier 是目前 Web 开发中最受欢迎的代码格式化程序。安装了这个插件，它就能够自动应用 Prettier，并将整个 JS 和 CSS 文档快速格式化为统一的代码样式。如果你还想使用 ESLint，那么还有个 Prettier – Eslint 插件，你可不要错过咯！\n\n* Color Info\n\n> 这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了\n\n* SVG Viewer\n\n> 此插件在 Visual Studio 代码中添加了许多实用的 SVG 程序，你无需离开编辑器，便可以打开 SVG 文件并查看它们。同时，它还包含了用于转换为 PNG 格式和生成数据 URI 模式的选项。\n\n* Minify\n\nF1-->minify\n\n> 这是一款用于压缩合并 JavaScript 和 CSS 文件的应用程序。它提供了大量自定义的设置，以及自动压缩保存并导出为.min文件的选项。它能够分别通过 uglify-js、clean-css 和 html-minifier，与 JavaScript、CSS 和 HTML 协同工作。\n\n* Quokka(调试工具插件)\n\n> Quokka 是一个调试工具插件，能够根据你正在编写的代码提供实时反馈。它易于配置，并能够预览变量的函数和计算值结果。另外，在使用 JSX 或 TypeScript 项目中，它能够开箱即用\n\n* ESLint\n\n> EsLint可以帮助我们检查Javascript编程时的语法错误。比如：在Javascript应用中，你很难找到你漏泄的变量或者方法。EsLint能够帮助我们分析JS代码，找到bug并确保一定程度的JS语法书写的正确性。\n\n* Font-awesome\n\n> 用于 html 的Font-awesome代码片段\n\n* filesize\n\n> 在底部状态栏显示当前文件大小，点击后还可以看到详细创建、修改时间\n\n* Git History\n\n> 使用 command+shift+p（Ctrl+shift+p） 输入git log就可以看到了\n\n* htmltagwrap\n\n> 可以在选中HTML标签中外面套一层标签\n\n使用：选择一大段代码，然后按“Alt + W”\n\n* Image Preview\n\n> 鼠标移到路径里显示图像预览\n\n* Live Sass Compiler\n\n> 实时编译 sass ,不过需要配置，附上我的配置\n\n* markdownlint\n\n> markdown 语法检查\n\n* npm Intellisense\n\n> 在导入语句中自动填充npm模块,跟Node.js Modules Intellisense差不多\n\n* Project Manager\n\n> 工程项目过多时，shift+cmd+p(shift+ctrl+p) 然后输入project，第一次选择edit Project编辑自己的工程项目，之后就可以直接选择open打开你的项目\n\n* vscode-faker\n\n> 生成假数据，地址，电话，图片等等\n\n* Regex Previewer\n\n> 测试正则的插件v\n\n* React-Native/React/Redux snippets for es6/es7\n\n> react代码片段，下载人数超多\n\n* react-beautify\n\n> 格式化 javascript, JSX, typescript, TSX 文件","source":"_posts/工具/vsCode.md","raw":"---\ntitle: vsCode插件\nauthor: heqing\ncategories:\n  - 工具\ntags:\n  - vsCode插件\ndate: 2017-12-03 13:38:50\n---\n\n> Microsoft在2015年4月30日Build 开发者大会上正式宣布了 Visual Studio Code 项目：一个运行于 Mac OS X、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器,一款轻量，采取了和VS相同的UI界面，搭配合适的插件可以优化前端开发的体验\n\n<!-- more -->\n\n### 安装\n\n[vscode官网](https://code.visualstudio.com/Download)\n\nVScode 中文设置\n\n1. 快捷键F1\n2. 输入Configure Language 回车\n3. “locale”:  \"zh-CN\"，locale设置为zh-CNK\n4. 保存, 重启vscode\n\n### 布局\n\n* 左侧是用于展示所要编辑的所有文件和文件夹的文件管理器，依次是`资源管理器`，`搜索`，`GIT`，`调试`，`插件`，\n\n* 右侧是打开文件的编辑区域，最多可同时打开三个编辑区域到侧边。\n\n* 底栏：依次是`Git Branch`，`error&warning`，`编码格式`等。\n\n### 插件\n\n* vscode-icon\n\nF1->icon-->icon Theme-->选择(安装自己喜欢的主题)\n\n> 这款必须要推荐，明显提升效率的小插件，在项目文件多类型多的情况下，找到制定文件会大大缩短时间；\n\n* fileheader\n\n修改作者 文件--->首选项--->设置--->fileheader--->修改\n\n> 顶部注释模板，可定义作者、时间等信息，并会自动更新最后修改时间, 快捷键 Ctrl+Alt+i\n\n* HTML Snippets \n\nCtrl+Shift+P-->输入snippets-->选择语言-->打开.json文件-->配置-->使用\n\n> 超级实用且初级的 H5代码片段以及提示\n\n* JavaScript Snippet Pack\n\n> 针对js的插件，包含了js的常用语法关键字，很实用, 代码片段(Tab或者Enter补全)\n\n* JavaScript Snippets\n\n> 此扩展包含Visual Studio代码编辑器（支持JavaScript和TypeScript）的ES6语法中的JavaScript代码片段。\n\n* HTML CSS Support\n\n> 在编写样式表的时候，自动补全功能大大缩减了编写时间，推荐！让 html 标签上写class 智能提示当前项目所支持的样式新版已经支持scss文件检索   (提示已有的class名)\n\n* Auto Close Tag\n\n> 编写html代码的时候，写完开始标签，这款插件会自动补全结束标签，其实上面所说的html自动补全插件一个Tab就搞定了，不过有时也需要这款插件；\n\n* Auto Rename Tag\n\n> 非常实用！要修改标签名称的时候自动修改结束标签，节省一半时间，提升效率，非常棒！\n\n* Document this\n\n> js 的注释模板 （注意：新版的vscode已经原生支持,在function上输入/** tab） Ctrl+Alt+D 快捷键, 光标放在关键字上\n\n* Change Case\n\n下划线命名  <-->   驼峰命名    大小写转换   \n\n> 虽然 VSCode 内置了开箱即用的文本转换选项，但其只能进行文本大小写的转换。而此插件则添加了用于修改文本的更多命名格式，包括驼峰命名、下划线分隔命名，snake_case 命名以及 CONST_CAS 命名等\n\n* jQuery Code Snippets\n\n> jquery提示插件\n\n* Path Intellisense\n\n> 自动路劲补全，默认不带这个功能的，赶紧装\n\n* Emoji  \n\nF1-->emo-->选择插入\n\n> 很好玩的一款插件，可以在代码中插入emoji了，也许是程序猿的娱乐方式吧；\n\n* Open-In-Browser\n\n> 由于 VSCode 没有提供直接在浏览器中打开文件的内置界面，所以此插件在快捷菜单中添加了在默认浏览器查看文件选项，以及在客户端（Firefox，Chrome，IE）中打开命令面板选项\n\n* Code Runner\n\n> 非常强大的一款插件，能够运行多种语言的代码片段或代码文件：C，C ++，Java，JavaScript，PHP，Python，Perl，Ruby，Go等等，安装完成后，右上角出现一个三角形，点击这个按钮就可以运行你的文件了（必备）。\n\n* Dash\n\n> 查文档必备，搭配 dash（不过似乎只有 mac 版）,快捷键 ctrl + h 它根据你当前选中的语言查找 dash 里面的文档\n\n* Debugger for Chrome\n\n> 让 vscode 映射 chrome 的 debug功能，使静态页面都可以用 vscode 来打断点调试\n\n* CSS Peek(窥视)\n\n> 使用此插件，你可以追踪至样式表中 CSS 类和 ids 定义的地方。当你在 HTML 文件中右键单击选择器时，选择“ Go to Definition 和 Peek definition ”选项，它便会给你发送样式设置的 CSS 代码。\n\n* HTML Boilerplate(样板)\n\n> 通过使用 HTML 模版插件，你就摆脱了为 HTML 新文件重新编写头部和正文标签的苦恼。你只需在空文件中输入 html，并按 Tab 键，即可生成干净的文档结构。\n\n* Prettier(格式化)\n\n快捷键 Shift+Alt+F /////  Ctrl+Shift+P(F1)-->键入format-->格式化代码\n\n> Prettier 是目前 Web 开发中最受欢迎的代码格式化程序。安装了这个插件，它就能够自动应用 Prettier，并将整个 JS 和 CSS 文档快速格式化为统一的代码样式。如果你还想使用 ESLint，那么还有个 Prettier – Eslint 插件，你可不要错过咯！\n\n* Color Info\n\n> 这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了\n\n* SVG Viewer\n\n> 此插件在 Visual Studio 代码中添加了许多实用的 SVG 程序，你无需离开编辑器，便可以打开 SVG 文件并查看它们。同时，它还包含了用于转换为 PNG 格式和生成数据 URI 模式的选项。\n\n* Minify\n\nF1-->minify\n\n> 这是一款用于压缩合并 JavaScript 和 CSS 文件的应用程序。它提供了大量自定义的设置，以及自动压缩保存并导出为.min文件的选项。它能够分别通过 uglify-js、clean-css 和 html-minifier，与 JavaScript、CSS 和 HTML 协同工作。\n\n* Quokka(调试工具插件)\n\n> Quokka 是一个调试工具插件，能够根据你正在编写的代码提供实时反馈。它易于配置，并能够预览变量的函数和计算值结果。另外，在使用 JSX 或 TypeScript 项目中，它能够开箱即用\n\n* ESLint\n\n> EsLint可以帮助我们检查Javascript编程时的语法错误。比如：在Javascript应用中，你很难找到你漏泄的变量或者方法。EsLint能够帮助我们分析JS代码，找到bug并确保一定程度的JS语法书写的正确性。\n\n* Font-awesome\n\n> 用于 html 的Font-awesome代码片段\n\n* filesize\n\n> 在底部状态栏显示当前文件大小，点击后还可以看到详细创建、修改时间\n\n* Git History\n\n> 使用 command+shift+p（Ctrl+shift+p） 输入git log就可以看到了\n\n* htmltagwrap\n\n> 可以在选中HTML标签中外面套一层标签\n\n使用：选择一大段代码，然后按“Alt + W”\n\n* Image Preview\n\n> 鼠标移到路径里显示图像预览\n\n* Live Sass Compiler\n\n> 实时编译 sass ,不过需要配置，附上我的配置\n\n* markdownlint\n\n> markdown 语法检查\n\n* npm Intellisense\n\n> 在导入语句中自动填充npm模块,跟Node.js Modules Intellisense差不多\n\n* Project Manager\n\n> 工程项目过多时，shift+cmd+p(shift+ctrl+p) 然后输入project，第一次选择edit Project编辑自己的工程项目，之后就可以直接选择open打开你的项目\n\n* vscode-faker\n\n> 生成假数据，地址，电话，图片等等\n\n* Regex Previewer\n\n> 测试正则的插件v\n\n* React-Native/React/Redux snippets for es6/es7\n\n> react代码片段，下载人数超多\n\n* react-beautify\n\n> 格式化 javascript, JSX, typescript, TSX 文件","slug":"工具/vsCode","published":1,"updated":"2017-12-03T07:22:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaqhv1gj000bbtx1fyqvh35d","content":"<blockquote>\n<p>Microsoft在2015年4月30日Build 开发者大会上正式宣布了 Visual Studio Code 项目：一个运行于 Mac OS X、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器,一款轻量，采取了和VS相同的UI界面，搭配合适的插件可以优化前端开发的体验</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p><a href=\"https://code.visualstudio.com/Download\" target=\"_blank\" rel=\"noopener\">vscode官网</a></p>\n<p>VScode 中文设置</p>\n<ol>\n<li>快捷键F1</li>\n<li>输入Configure Language 回车</li>\n<li>“locale”:  “zh-CN”，locale设置为zh-CNK</li>\n<li>保存, 重启vscode</li>\n</ol>\n<h3 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h3><ul>\n<li><p>左侧是用于展示所要编辑的所有文件和文件夹的文件管理器，依次是<code>资源管理器</code>，<code>搜索</code>，<code>GIT</code>，<code>调试</code>，<code>插件</code>，</p>\n</li>\n<li><p>右侧是打开文件的编辑区域，最多可同时打开三个编辑区域到侧边。</p>\n</li>\n<li><p>底栏：依次是<code>Git Branch</code>，<code>error&amp;warning</code>，<code>编码格式</code>等。</p>\n</li>\n</ul>\n<h3 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h3><ul>\n<li>vscode-icon</li>\n</ul>\n<p>F1-&gt;icon–&gt;icon Theme–&gt;选择(安装自己喜欢的主题)</p>\n<blockquote>\n<p>这款必须要推荐，明显提升效率的小插件，在项目文件多类型多的情况下，找到制定文件会大大缩短时间；</p>\n</blockquote>\n<ul>\n<li>fileheader</li>\n</ul>\n<p>修改作者 文件—&gt;首选项—&gt;设置—&gt;fileheader—&gt;修改</p>\n<blockquote>\n<p>顶部注释模板，可定义作者、时间等信息，并会自动更新最后修改时间, 快捷键 Ctrl+Alt+i</p>\n</blockquote>\n<ul>\n<li>HTML Snippets </li>\n</ul>\n<p>Ctrl+Shift+P–&gt;输入snippets–&gt;选择语言–&gt;打开.json文件–&gt;配置–&gt;使用</p>\n<blockquote>\n<p>超级实用且初级的 H5代码片段以及提示</p>\n</blockquote>\n<ul>\n<li>JavaScript Snippet Pack</li>\n</ul>\n<blockquote>\n<p>针对js的插件，包含了js的常用语法关键字，很实用, 代码片段(Tab或者Enter补全)</p>\n</blockquote>\n<ul>\n<li>JavaScript Snippets</li>\n</ul>\n<blockquote>\n<p>此扩展包含Visual Studio代码编辑器（支持JavaScript和TypeScript）的ES6语法中的JavaScript代码片段。</p>\n</blockquote>\n<ul>\n<li>HTML CSS Support</li>\n</ul>\n<blockquote>\n<p>在编写样式表的时候，自动补全功能大大缩减了编写时间，推荐！让 html 标签上写class 智能提示当前项目所支持的样式新版已经支持scss文件检索   (提示已有的class名)</p>\n</blockquote>\n<ul>\n<li>Auto Close Tag</li>\n</ul>\n<blockquote>\n<p>编写html代码的时候，写完开始标签，这款插件会自动补全结束标签，其实上面所说的html自动补全插件一个Tab就搞定了，不过有时也需要这款插件；</p>\n</blockquote>\n<ul>\n<li>Auto Rename Tag</li>\n</ul>\n<blockquote>\n<p>非常实用！要修改标签名称的时候自动修改结束标签，节省一半时间，提升效率，非常棒！</p>\n</blockquote>\n<ul>\n<li>Document this</li>\n</ul>\n<blockquote>\n<p>js 的注释模板 （注意：新版的vscode已经原生支持,在function上输入/** tab） Ctrl+Alt+D 快捷键, 光标放在关键字上</p>\n</blockquote>\n<ul>\n<li>Change Case</li>\n</ul>\n<p>下划线命名  &lt;–&gt;   驼峰命名    大小写转换   </p>\n<blockquote>\n<p>虽然 VSCode 内置了开箱即用的文本转换选项，但其只能进行文本大小写的转换。而此插件则添加了用于修改文本的更多命名格式，包括驼峰命名、下划线分隔命名，snake_case 命名以及 CONST_CAS 命名等</p>\n</blockquote>\n<ul>\n<li>jQuery Code Snippets</li>\n</ul>\n<blockquote>\n<p>jquery提示插件</p>\n</blockquote>\n<ul>\n<li>Path Intellisense</li>\n</ul>\n<blockquote>\n<p>自动路劲补全，默认不带这个功能的，赶紧装</p>\n</blockquote>\n<ul>\n<li>Emoji  </li>\n</ul>\n<p>F1–&gt;emo–&gt;选择插入</p>\n<blockquote>\n<p>很好玩的一款插件，可以在代码中插入emoji了，也许是程序猿的娱乐方式吧；</p>\n</blockquote>\n<ul>\n<li>Open-In-Browser</li>\n</ul>\n<blockquote>\n<p>由于 VSCode 没有提供直接在浏览器中打开文件的内置界面，所以此插件在快捷菜单中添加了在默认浏览器查看文件选项，以及在客户端（Firefox，Chrome，IE）中打开命令面板选项</p>\n</blockquote>\n<ul>\n<li>Code Runner</li>\n</ul>\n<blockquote>\n<p>非常强大的一款插件，能够运行多种语言的代码片段或代码文件：C，C ++，Java，JavaScript，PHP，Python，Perl，Ruby，Go等等，安装完成后，右上角出现一个三角形，点击这个按钮就可以运行你的文件了（必备）。</p>\n</blockquote>\n<ul>\n<li>Dash</li>\n</ul>\n<blockquote>\n<p>查文档必备，搭配 dash（不过似乎只有 mac 版）,快捷键 ctrl + h 它根据你当前选中的语言查找 dash 里面的文档</p>\n</blockquote>\n<ul>\n<li>Debugger for Chrome</li>\n</ul>\n<blockquote>\n<p>让 vscode 映射 chrome 的 debug功能，使静态页面都可以用 vscode 来打断点调试</p>\n</blockquote>\n<ul>\n<li>CSS Peek(窥视)</li>\n</ul>\n<blockquote>\n<p>使用此插件，你可以追踪至样式表中 CSS 类和 ids 定义的地方。当你在 HTML 文件中右键单击选择器时，选择“ Go to Definition 和 Peek definition ”选项，它便会给你发送样式设置的 CSS 代码。</p>\n</blockquote>\n<ul>\n<li>HTML Boilerplate(样板)</li>\n</ul>\n<blockquote>\n<p>通过使用 HTML 模版插件，你就摆脱了为 HTML 新文件重新编写头部和正文标签的苦恼。你只需在空文件中输入 html，并按 Tab 键，即可生成干净的文档结构。</p>\n</blockquote>\n<ul>\n<li>Prettier(格式化)</li>\n</ul>\n<p>快捷键 Shift+Alt+F /////  Ctrl+Shift+P(F1)–&gt;键入format–&gt;格式化代码</p>\n<blockquote>\n<p>Prettier 是目前 Web 开发中最受欢迎的代码格式化程序。安装了这个插件，它就能够自动应用 Prettier，并将整个 JS 和 CSS 文档快速格式化为统一的代码样式。如果你还想使用 ESLint，那么还有个 Prettier – Eslint 插件，你可不要错过咯！</p>\n</blockquote>\n<ul>\n<li>Color Info</li>\n</ul>\n<blockquote>\n<p>这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了</p>\n</blockquote>\n<ul>\n<li>SVG Viewer</li>\n</ul>\n<blockquote>\n<p>此插件在 Visual Studio 代码中添加了许多实用的 SVG 程序，你无需离开编辑器，便可以打开 SVG 文件并查看它们。同时，它还包含了用于转换为 PNG 格式和生成数据 URI 模式的选项。</p>\n</blockquote>\n<ul>\n<li>Minify</li>\n</ul>\n<p>F1–&gt;minify</p>\n<blockquote>\n<p>这是一款用于压缩合并 JavaScript 和 CSS 文件的应用程序。它提供了大量自定义的设置，以及自动压缩保存并导出为.min文件的选项。它能够分别通过 uglify-js、clean-css 和 html-minifier，与 JavaScript、CSS 和 HTML 协同工作。</p>\n</blockquote>\n<ul>\n<li>Quokka(调试工具插件)</li>\n</ul>\n<blockquote>\n<p>Quokka 是一个调试工具插件，能够根据你正在编写的代码提供实时反馈。它易于配置，并能够预览变量的函数和计算值结果。另外，在使用 JSX 或 TypeScript 项目中，它能够开箱即用</p>\n</blockquote>\n<ul>\n<li>ESLint</li>\n</ul>\n<blockquote>\n<p>EsLint可以帮助我们检查Javascript编程时的语法错误。比如：在Javascript应用中，你很难找到你漏泄的变量或者方法。EsLint能够帮助我们分析JS代码，找到bug并确保一定程度的JS语法书写的正确性。</p>\n</blockquote>\n<ul>\n<li>Font-awesome</li>\n</ul>\n<blockquote>\n<p>用于 html 的Font-awesome代码片段</p>\n</blockquote>\n<ul>\n<li>filesize</li>\n</ul>\n<blockquote>\n<p>在底部状态栏显示当前文件大小，点击后还可以看到详细创建、修改时间</p>\n</blockquote>\n<ul>\n<li>Git History</li>\n</ul>\n<blockquote>\n<p>使用 command+shift+p（Ctrl+shift+p） 输入git log就可以看到了</p>\n</blockquote>\n<ul>\n<li>htmltagwrap</li>\n</ul>\n<blockquote>\n<p>可以在选中HTML标签中外面套一层标签</p>\n</blockquote>\n<p>使用：选择一大段代码，然后按“Alt + W”</p>\n<ul>\n<li>Image Preview</li>\n</ul>\n<blockquote>\n<p>鼠标移到路径里显示图像预览</p>\n</blockquote>\n<ul>\n<li>Live Sass Compiler</li>\n</ul>\n<blockquote>\n<p>实时编译 sass ,不过需要配置，附上我的配置</p>\n</blockquote>\n<ul>\n<li>markdownlint</li>\n</ul>\n<blockquote>\n<p>markdown 语法检查</p>\n</blockquote>\n<ul>\n<li>npm Intellisense</li>\n</ul>\n<blockquote>\n<p>在导入语句中自动填充npm模块,跟Node.js Modules Intellisense差不多</p>\n</blockquote>\n<ul>\n<li>Project Manager</li>\n</ul>\n<blockquote>\n<p>工程项目过多时，shift+cmd+p(shift+ctrl+p) 然后输入project，第一次选择edit Project编辑自己的工程项目，之后就可以直接选择open打开你的项目</p>\n</blockquote>\n<ul>\n<li>vscode-faker</li>\n</ul>\n<blockquote>\n<p>生成假数据，地址，电话，图片等等</p>\n</blockquote>\n<ul>\n<li>Regex Previewer</li>\n</ul>\n<blockquote>\n<p>测试正则的插件v</p>\n</blockquote>\n<ul>\n<li>React-Native/React/Redux snippets for es6/es7</li>\n</ul>\n<blockquote>\n<p>react代码片段，下载人数超多</p>\n</blockquote>\n<ul>\n<li>react-beautify</li>\n</ul>\n<blockquote>\n<p>格式化 javascript, JSX, typescript, TSX 文件</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Microsoft在2015年4月30日Build 开发者大会上正式宣布了 Visual Studio Code 项目：一个运行于 Mac OS X、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器,一款轻量，采取了和VS相同的UI界面，搭配合适的插件可以优化前端开发的体验</p>\n</blockquote>","more":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p><a href=\"https://code.visualstudio.com/Download\" target=\"_blank\" rel=\"noopener\">vscode官网</a></p>\n<p>VScode 中文设置</p>\n<ol>\n<li>快捷键F1</li>\n<li>输入Configure Language 回车</li>\n<li>“locale”:  “zh-CN”，locale设置为zh-CNK</li>\n<li>保存, 重启vscode</li>\n</ol>\n<h3 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h3><ul>\n<li><p>左侧是用于展示所要编辑的所有文件和文件夹的文件管理器，依次是<code>资源管理器</code>，<code>搜索</code>，<code>GIT</code>，<code>调试</code>，<code>插件</code>，</p>\n</li>\n<li><p>右侧是打开文件的编辑区域，最多可同时打开三个编辑区域到侧边。</p>\n</li>\n<li><p>底栏：依次是<code>Git Branch</code>，<code>error&amp;warning</code>，<code>编码格式</code>等。</p>\n</li>\n</ul>\n<h3 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h3><ul>\n<li>vscode-icon</li>\n</ul>\n<p>F1-&gt;icon–&gt;icon Theme–&gt;选择(安装自己喜欢的主题)</p>\n<blockquote>\n<p>这款必须要推荐，明显提升效率的小插件，在项目文件多类型多的情况下，找到制定文件会大大缩短时间；</p>\n</blockquote>\n<ul>\n<li>fileheader</li>\n</ul>\n<p>修改作者 文件—&gt;首选项—&gt;设置—&gt;fileheader—&gt;修改</p>\n<blockquote>\n<p>顶部注释模板，可定义作者、时间等信息，并会自动更新最后修改时间, 快捷键 Ctrl+Alt+i</p>\n</blockquote>\n<ul>\n<li>HTML Snippets </li>\n</ul>\n<p>Ctrl+Shift+P–&gt;输入snippets–&gt;选择语言–&gt;打开.json文件–&gt;配置–&gt;使用</p>\n<blockquote>\n<p>超级实用且初级的 H5代码片段以及提示</p>\n</blockquote>\n<ul>\n<li>JavaScript Snippet Pack</li>\n</ul>\n<blockquote>\n<p>针对js的插件，包含了js的常用语法关键字，很实用, 代码片段(Tab或者Enter补全)</p>\n</blockquote>\n<ul>\n<li>JavaScript Snippets</li>\n</ul>\n<blockquote>\n<p>此扩展包含Visual Studio代码编辑器（支持JavaScript和TypeScript）的ES6语法中的JavaScript代码片段。</p>\n</blockquote>\n<ul>\n<li>HTML CSS Support</li>\n</ul>\n<blockquote>\n<p>在编写样式表的时候，自动补全功能大大缩减了编写时间，推荐！让 html 标签上写class 智能提示当前项目所支持的样式新版已经支持scss文件检索   (提示已有的class名)</p>\n</blockquote>\n<ul>\n<li>Auto Close Tag</li>\n</ul>\n<blockquote>\n<p>编写html代码的时候，写完开始标签，这款插件会自动补全结束标签，其实上面所说的html自动补全插件一个Tab就搞定了，不过有时也需要这款插件；</p>\n</blockquote>\n<ul>\n<li>Auto Rename Tag</li>\n</ul>\n<blockquote>\n<p>非常实用！要修改标签名称的时候自动修改结束标签，节省一半时间，提升效率，非常棒！</p>\n</blockquote>\n<ul>\n<li>Document this</li>\n</ul>\n<blockquote>\n<p>js 的注释模板 （注意：新版的vscode已经原生支持,在function上输入/** tab） Ctrl+Alt+D 快捷键, 光标放在关键字上</p>\n</blockquote>\n<ul>\n<li>Change Case</li>\n</ul>\n<p>下划线命名  &lt;–&gt;   驼峰命名    大小写转换   </p>\n<blockquote>\n<p>虽然 VSCode 内置了开箱即用的文本转换选项，但其只能进行文本大小写的转换。而此插件则添加了用于修改文本的更多命名格式，包括驼峰命名、下划线分隔命名，snake_case 命名以及 CONST_CAS 命名等</p>\n</blockquote>\n<ul>\n<li>jQuery Code Snippets</li>\n</ul>\n<blockquote>\n<p>jquery提示插件</p>\n</blockquote>\n<ul>\n<li>Path Intellisense</li>\n</ul>\n<blockquote>\n<p>自动路劲补全，默认不带这个功能的，赶紧装</p>\n</blockquote>\n<ul>\n<li>Emoji  </li>\n</ul>\n<p>F1–&gt;emo–&gt;选择插入</p>\n<blockquote>\n<p>很好玩的一款插件，可以在代码中插入emoji了，也许是程序猿的娱乐方式吧；</p>\n</blockquote>\n<ul>\n<li>Open-In-Browser</li>\n</ul>\n<blockquote>\n<p>由于 VSCode 没有提供直接在浏览器中打开文件的内置界面，所以此插件在快捷菜单中添加了在默认浏览器查看文件选项，以及在客户端（Firefox，Chrome，IE）中打开命令面板选项</p>\n</blockquote>\n<ul>\n<li>Code Runner</li>\n</ul>\n<blockquote>\n<p>非常强大的一款插件，能够运行多种语言的代码片段或代码文件：C，C ++，Java，JavaScript，PHP，Python，Perl，Ruby，Go等等，安装完成后，右上角出现一个三角形，点击这个按钮就可以运行你的文件了（必备）。</p>\n</blockquote>\n<ul>\n<li>Dash</li>\n</ul>\n<blockquote>\n<p>查文档必备，搭配 dash（不过似乎只有 mac 版）,快捷键 ctrl + h 它根据你当前选中的语言查找 dash 里面的文档</p>\n</blockquote>\n<ul>\n<li>Debugger for Chrome</li>\n</ul>\n<blockquote>\n<p>让 vscode 映射 chrome 的 debug功能，使静态页面都可以用 vscode 来打断点调试</p>\n</blockquote>\n<ul>\n<li>CSS Peek(窥视)</li>\n</ul>\n<blockquote>\n<p>使用此插件，你可以追踪至样式表中 CSS 类和 ids 定义的地方。当你在 HTML 文件中右键单击选择器时，选择“ Go to Definition 和 Peek definition ”选项，它便会给你发送样式设置的 CSS 代码。</p>\n</blockquote>\n<ul>\n<li>HTML Boilerplate(样板)</li>\n</ul>\n<blockquote>\n<p>通过使用 HTML 模版插件，你就摆脱了为 HTML 新文件重新编写头部和正文标签的苦恼。你只需在空文件中输入 html，并按 Tab 键，即可生成干净的文档结构。</p>\n</blockquote>\n<ul>\n<li>Prettier(格式化)</li>\n</ul>\n<p>快捷键 Shift+Alt+F /////  Ctrl+Shift+P(F1)–&gt;键入format–&gt;格式化代码</p>\n<blockquote>\n<p>Prettier 是目前 Web 开发中最受欢迎的代码格式化程序。安装了这个插件，它就能够自动应用 Prettier，并将整个 JS 和 CSS 文档快速格式化为统一的代码样式。如果你还想使用 ESLint，那么还有个 Prettier – Eslint 插件，你可不要错过咯！</p>\n</blockquote>\n<ul>\n<li>Color Info</li>\n</ul>\n<blockquote>\n<p>这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了</p>\n</blockquote>\n<ul>\n<li>SVG Viewer</li>\n</ul>\n<blockquote>\n<p>此插件在 Visual Studio 代码中添加了许多实用的 SVG 程序，你无需离开编辑器，便可以打开 SVG 文件并查看它们。同时，它还包含了用于转换为 PNG 格式和生成数据 URI 模式的选项。</p>\n</blockquote>\n<ul>\n<li>Minify</li>\n</ul>\n<p>F1–&gt;minify</p>\n<blockquote>\n<p>这是一款用于压缩合并 JavaScript 和 CSS 文件的应用程序。它提供了大量自定义的设置，以及自动压缩保存并导出为.min文件的选项。它能够分别通过 uglify-js、clean-css 和 html-minifier，与 JavaScript、CSS 和 HTML 协同工作。</p>\n</blockquote>\n<ul>\n<li>Quokka(调试工具插件)</li>\n</ul>\n<blockquote>\n<p>Quokka 是一个调试工具插件，能够根据你正在编写的代码提供实时反馈。它易于配置，并能够预览变量的函数和计算值结果。另外，在使用 JSX 或 TypeScript 项目中，它能够开箱即用</p>\n</blockquote>\n<ul>\n<li>ESLint</li>\n</ul>\n<blockquote>\n<p>EsLint可以帮助我们检查Javascript编程时的语法错误。比如：在Javascript应用中，你很难找到你漏泄的变量或者方法。EsLint能够帮助我们分析JS代码，找到bug并确保一定程度的JS语法书写的正确性。</p>\n</blockquote>\n<ul>\n<li>Font-awesome</li>\n</ul>\n<blockquote>\n<p>用于 html 的Font-awesome代码片段</p>\n</blockquote>\n<ul>\n<li>filesize</li>\n</ul>\n<blockquote>\n<p>在底部状态栏显示当前文件大小，点击后还可以看到详细创建、修改时间</p>\n</blockquote>\n<ul>\n<li>Git History</li>\n</ul>\n<blockquote>\n<p>使用 command+shift+p（Ctrl+shift+p） 输入git log就可以看到了</p>\n</blockquote>\n<ul>\n<li>htmltagwrap</li>\n</ul>\n<blockquote>\n<p>可以在选中HTML标签中外面套一层标签</p>\n</blockquote>\n<p>使用：选择一大段代码，然后按“Alt + W”</p>\n<ul>\n<li>Image Preview</li>\n</ul>\n<blockquote>\n<p>鼠标移到路径里显示图像预览</p>\n</blockquote>\n<ul>\n<li>Live Sass Compiler</li>\n</ul>\n<blockquote>\n<p>实时编译 sass ,不过需要配置，附上我的配置</p>\n</blockquote>\n<ul>\n<li>markdownlint</li>\n</ul>\n<blockquote>\n<p>markdown 语法检查</p>\n</blockquote>\n<ul>\n<li>npm Intellisense</li>\n</ul>\n<blockquote>\n<p>在导入语句中自动填充npm模块,跟Node.js Modules Intellisense差不多</p>\n</blockquote>\n<ul>\n<li>Project Manager</li>\n</ul>\n<blockquote>\n<p>工程项目过多时，shift+cmd+p(shift+ctrl+p) 然后输入project，第一次选择edit Project编辑自己的工程项目，之后就可以直接选择open打开你的项目</p>\n</blockquote>\n<ul>\n<li>vscode-faker</li>\n</ul>\n<blockquote>\n<p>生成假数据，地址，电话，图片等等</p>\n</blockquote>\n<ul>\n<li>Regex Previewer</li>\n</ul>\n<blockquote>\n<p>测试正则的插件v</p>\n</blockquote>\n<ul>\n<li>React-Native/React/Redux snippets for es6/es7</li>\n</ul>\n<blockquote>\n<p>react代码片段，下载人数超多</p>\n</blockquote>\n<ul>\n<li>react-beautify</li>\n</ul>\n<blockquote>\n<p>格式化 javascript, JSX, typescript, TSX 文件</p>\n</blockquote>"},{"title":"科学上网","date":"2017-10-23T00:49:27.000Z","_content":"\n>  科学上网，指通过一些方法越过 GFW 的封锁，让我们能够访问 Google，YouTube，wikipedia，Facebook 等网站，目前所有VPN都已经关闭或者只维护现有用户，如果大家有浏览外网的需求，建议使用ECS进行自建，本篇文章将教会你如何自建VPN\n\n<!-- more -->\n\n## 步骤\n1. 购买阿里云ECS实例\n2. 远程连接\n3. 在ECS上安装shadowsocks&启动\n4. 安装客户端&配置\n\n## 相关资料\n* [shadowsocks github地址](https://github.com/shadowsocks/shadowsocks/tree/master)\n\n## 购买阿里云ECS实例\n1.[阿里云ECS购买地址](https://ecs-buy.aliyun.com/#/prepay)\n\n## 连接ECS实例\n1. mac直接用terminal连接。window可以用[xshell,点击去下载](http://rj.baidu.com/soft/detail/15201.html?ald)\n2. `ssh root@ipAddress`，root是用户名，[ipAddress是购买的ECS IP，点击去查看](https://ecs.console.aliyun.com/#/home)\n\n## 在ECS上安装shadowsocks&启动\n1. 安装shadowsocks，[Github详细文档](https://github.com/shadowsocks/shadowsocks/wiki)\n```\nyum install python-setuptools && easy_install pip\npip install shadowsocks\n```\n\n2. 启动shadowsocks，配置文件[Github](https://github.com/shadowsocks/shadowsocks/wiki/Configuration-via-Config-File) \n```js\n// 直接启动\nssserver -p 443 -k password -m rc4-md5\n// 后台运行\nsudo ssserver -p 443 -k password -m rc4-md5 --user nobody -d start\n// 停止\nsudo ssserver -d stop\n```\n\n## 安装客户端&配置\n1. 安装客户端 [Github Ports and Clients](https://github.com/shadowsocks/shadowsocks/wiki/Ports-and-Clients)\n","source":"_posts/工具/科学上网.md","raw":"---\ntitle: 科学上网\ncategories:\n  - 工具\ntags:\n  - VPN\ndate: 2017-10-23 08:49:27\n---\n\n>  科学上网，指通过一些方法越过 GFW 的封锁，让我们能够访问 Google，YouTube，wikipedia，Facebook 等网站，目前所有VPN都已经关闭或者只维护现有用户，如果大家有浏览外网的需求，建议使用ECS进行自建，本篇文章将教会你如何自建VPN\n\n<!-- more -->\n\n## 步骤\n1. 购买阿里云ECS实例\n2. 远程连接\n3. 在ECS上安装shadowsocks&启动\n4. 安装客户端&配置\n\n## 相关资料\n* [shadowsocks github地址](https://github.com/shadowsocks/shadowsocks/tree/master)\n\n## 购买阿里云ECS实例\n1.[阿里云ECS购买地址](https://ecs-buy.aliyun.com/#/prepay)\n\n## 连接ECS实例\n1. mac直接用terminal连接。window可以用[xshell,点击去下载](http://rj.baidu.com/soft/detail/15201.html?ald)\n2. `ssh root@ipAddress`，root是用户名，[ipAddress是购买的ECS IP，点击去查看](https://ecs.console.aliyun.com/#/home)\n\n## 在ECS上安装shadowsocks&启动\n1. 安装shadowsocks，[Github详细文档](https://github.com/shadowsocks/shadowsocks/wiki)\n```\nyum install python-setuptools && easy_install pip\npip install shadowsocks\n```\n\n2. 启动shadowsocks，配置文件[Github](https://github.com/shadowsocks/shadowsocks/wiki/Configuration-via-Config-File) \n```js\n// 直接启动\nssserver -p 443 -k password -m rc4-md5\n// 后台运行\nsudo ssserver -p 443 -k password -m rc4-md5 --user nobody -d start\n// 停止\nsudo ssserver -d stop\n```\n\n## 安装客户端&配置\n1. 安装客户端 [Github Ports and Clients](https://github.com/shadowsocks/shadowsocks/wiki/Ports-and-Clients)\n","slug":"工具/科学上网","published":1,"updated":"2017-10-25T02:39:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaqhv1gk000cbtx1pqs57irx","content":"<blockquote>\n<p> 科学上网，指通过一些方法越过 GFW 的封锁，让我们能够访问 Google，YouTube，wikipedia，Facebook 等网站，目前所有VPN都已经关闭或者只维护现有用户，如果大家有浏览外网的需求，建议使用ECS进行自建，本篇文章将教会你如何自建VPN</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><ol>\n<li>购买阿里云ECS实例</li>\n<li>远程连接</li>\n<li>在ECS上安装shadowsocks&amp;启动</li>\n<li>安装客户端&amp;配置</li>\n</ol>\n<h2 id=\"相关资料\"><a href=\"#相关资料\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h2><ul>\n<li><a href=\"https://github.com/shadowsocks/shadowsocks/tree/master\" target=\"_blank\" rel=\"noopener\">shadowsocks github地址</a></li>\n</ul>\n<h2 id=\"购买阿里云ECS实例\"><a href=\"#购买阿里云ECS实例\" class=\"headerlink\" title=\"购买阿里云ECS实例\"></a>购买阿里云ECS实例</h2><p>1.<a href=\"https://ecs-buy.aliyun.com/#/prepay\" target=\"_blank\" rel=\"noopener\">阿里云ECS购买地址</a></p>\n<h2 id=\"连接ECS实例\"><a href=\"#连接ECS实例\" class=\"headerlink\" title=\"连接ECS实例\"></a>连接ECS实例</h2><ol>\n<li>mac直接用terminal连接。window可以用<a href=\"http://rj.baidu.com/soft/detail/15201.html?ald\" target=\"_blank\" rel=\"noopener\">xshell,点击去下载</a></li>\n<li><code>ssh root@ipAddress</code>，root是用户名，<a href=\"https://ecs.console.aliyun.com/#/home\" target=\"_blank\" rel=\"noopener\">ipAddress是购买的ECS IP，点击去查看</a></li>\n</ol>\n<h2 id=\"在ECS上安装shadowsocks-amp-启动\"><a href=\"#在ECS上安装shadowsocks-amp-启动\" class=\"headerlink\" title=\"在ECS上安装shadowsocks&amp;启动\"></a>在ECS上安装shadowsocks&amp;启动</h2><ol>\n<li><p>安装shadowsocks，<a href=\"https://github.com/shadowsocks/shadowsocks/wiki\" target=\"_blank\" rel=\"noopener\">Github详细文档</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install python-setuptools &amp;&amp; easy_install pip</span><br><span class=\"line\">pip install shadowsocks</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动shadowsocks，配置文件<a href=\"https://github.com/shadowsocks/shadowsocks/wiki/Configuration-via-Config-File\" target=\"_blank\" rel=\"noopener\">Github</a> </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 直接启动</span></span><br><span class=\"line\">ssserver -p <span class=\"number\">443</span> -k password -m rc4-md5</span><br><span class=\"line\"><span class=\"comment\">// 后台运行</span></span><br><span class=\"line\">sudo ssserver -p <span class=\"number\">443</span> -k password -m rc4-md5 --user nobody -d start</span><br><span class=\"line\"><span class=\"comment\">// 停止</span></span><br><span class=\"line\">sudo ssserver -d stop</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"安装客户端-amp-配置\"><a href=\"#安装客户端-amp-配置\" class=\"headerlink\" title=\"安装客户端&amp;配置\"></a>安装客户端&amp;配置</h2><ol>\n<li>安装客户端 <a href=\"https://github.com/shadowsocks/shadowsocks/wiki/Ports-and-Clients\" target=\"_blank\" rel=\"noopener\">Github Ports and Clients</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p> 科学上网，指通过一些方法越过 GFW 的封锁，让我们能够访问 Google，YouTube，wikipedia，Facebook 等网站，目前所有VPN都已经关闭或者只维护现有用户，如果大家有浏览外网的需求，建议使用ECS进行自建，本篇文章将教会你如何自建VPN</p>\n</blockquote>","more":"<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><ol>\n<li>购买阿里云ECS实例</li>\n<li>远程连接</li>\n<li>在ECS上安装shadowsocks&amp;启动</li>\n<li>安装客户端&amp;配置</li>\n</ol>\n<h2 id=\"相关资料\"><a href=\"#相关资料\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h2><ul>\n<li><a href=\"https://github.com/shadowsocks/shadowsocks/tree/master\" target=\"_blank\" rel=\"noopener\">shadowsocks github地址</a></li>\n</ul>\n<h2 id=\"购买阿里云ECS实例\"><a href=\"#购买阿里云ECS实例\" class=\"headerlink\" title=\"购买阿里云ECS实例\"></a>购买阿里云ECS实例</h2><p>1.<a href=\"https://ecs-buy.aliyun.com/#/prepay\" target=\"_blank\" rel=\"noopener\">阿里云ECS购买地址</a></p>\n<h2 id=\"连接ECS实例\"><a href=\"#连接ECS实例\" class=\"headerlink\" title=\"连接ECS实例\"></a>连接ECS实例</h2><ol>\n<li>mac直接用terminal连接。window可以用<a href=\"http://rj.baidu.com/soft/detail/15201.html?ald\" target=\"_blank\" rel=\"noopener\">xshell,点击去下载</a></li>\n<li><code>ssh root@ipAddress</code>，root是用户名，<a href=\"https://ecs.console.aliyun.com/#/home\" target=\"_blank\" rel=\"noopener\">ipAddress是购买的ECS IP，点击去查看</a></li>\n</ol>\n<h2 id=\"在ECS上安装shadowsocks-amp-启动\"><a href=\"#在ECS上安装shadowsocks-amp-启动\" class=\"headerlink\" title=\"在ECS上安装shadowsocks&amp;启动\"></a>在ECS上安装shadowsocks&amp;启动</h2><ol>\n<li><p>安装shadowsocks，<a href=\"https://github.com/shadowsocks/shadowsocks/wiki\" target=\"_blank\" rel=\"noopener\">Github详细文档</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install python-setuptools &amp;&amp; easy_install pip</span><br><span class=\"line\">pip install shadowsocks</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动shadowsocks，配置文件<a href=\"https://github.com/shadowsocks/shadowsocks/wiki/Configuration-via-Config-File\" target=\"_blank\" rel=\"noopener\">Github</a> </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 直接启动</span></span><br><span class=\"line\">ssserver -p <span class=\"number\">443</span> -k password -m rc4-md5</span><br><span class=\"line\"><span class=\"comment\">// 后台运行</span></span><br><span class=\"line\">sudo ssserver -p <span class=\"number\">443</span> -k password -m rc4-md5 --user nobody -d start</span><br><span class=\"line\"><span class=\"comment\">// 停止</span></span><br><span class=\"line\">sudo ssserver -d stop</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"安装客户端-amp-配置\"><a href=\"#安装客户端-amp-配置\" class=\"headerlink\" title=\"安装客户端&amp;配置\"></a>安装客户端&amp;配置</h2><ol>\n<li>安装客户端 <a href=\"https://github.com/shadowsocks/shadowsocks/wiki/Ports-and-Clients\" target=\"_blank\" rel=\"noopener\">Github Ports and Clients</a></li>\n</ol>"},{"title":"虚拟主机、ECS云服务器、VPS区别汇总","date":"2017-10-17T05:49:58.000Z","_content":"\n> 想做一个网站，但是在各种类型的服务器琳琅满目，现在总结一下市场上常见的几种服务器。\n\n<!-- more -->\n1.虚拟主机\n\n虚拟主机就是利用虚拟化的技术，将一台服务器划分出一定大小的空间，每个空间都给予单独的 FTP 权限和 Web 访问权限，多个用户共同平均使用这台服务器的硬件资源。不同配置的虚拟主机主要是在磁盘空间、数据库大小、流量上面的区别。虚拟主机也有可以分为独享的虚拟主机，和共享的虚拟主机。顾名思义，两者之间的区别在于服务器资源的独享和共享。网站主机、空间、都是一个意思。这一类的主机用户的权限很低，没有远程桌面，只有FTP权限供用户上传文档等操作。优势是比较价格便宜。\n\n2.VPS\n\n先说一下vps，Virtual Private Server 虚拟专用服务器,一般是将一个独立服务器通过虚拟化技术虚拟成多个虚拟专用服务器。与虚拟主机不同的是，你拥有的是一台虚拟的服务器，类似于Windows上的虚拟机一样，虽然是虚拟的，但是使用起来，和使用客户机没有什么区别。同理，VPS可以使用远程桌面登录对服务器进行维护操作。\n\n \n\n3.ECS云服务器\n\n现在的主流的服务器解决方案，一般理解云服务器和VPS一样，同样是虚拟化的技术虚拟出来的服务器。也有人说以前的VPS就是现在的ECS，其实不然，云服务器是一个计算，网络，存储的组合。简单点说就是通过多个CPU，内存，硬盘组成的计算池和存储池和网络的组合；在这样的平台上虚拟出的服务器，用户可以根据自己的运算需要选择配置不同的云服务器。具体区别总结如下：\n\n![呈现引擎的基本流程图](/img/VPS&ECS.png)\n\n\n","source":"_posts/服务器/虚拟主机&VPS&ECS.md","raw":"---\ntitle: 虚拟主机、ECS云服务器、VPS区别汇总\ndate: 2017-10-17 13:49:58\ncategories:\n- 服务器\ntags: \n- 服务器区别\n---\n\n> 想做一个网站，但是在各种类型的服务器琳琅满目，现在总结一下市场上常见的几种服务器。\n\n<!-- more -->\n1.虚拟主机\n\n虚拟主机就是利用虚拟化的技术，将一台服务器划分出一定大小的空间，每个空间都给予单独的 FTP 权限和 Web 访问权限，多个用户共同平均使用这台服务器的硬件资源。不同配置的虚拟主机主要是在磁盘空间、数据库大小、流量上面的区别。虚拟主机也有可以分为独享的虚拟主机，和共享的虚拟主机。顾名思义，两者之间的区别在于服务器资源的独享和共享。网站主机、空间、都是一个意思。这一类的主机用户的权限很低，没有远程桌面，只有FTP权限供用户上传文档等操作。优势是比较价格便宜。\n\n2.VPS\n\n先说一下vps，Virtual Private Server 虚拟专用服务器,一般是将一个独立服务器通过虚拟化技术虚拟成多个虚拟专用服务器。与虚拟主机不同的是，你拥有的是一台虚拟的服务器，类似于Windows上的虚拟机一样，虽然是虚拟的，但是使用起来，和使用客户机没有什么区别。同理，VPS可以使用远程桌面登录对服务器进行维护操作。\n\n \n\n3.ECS云服务器\n\n现在的主流的服务器解决方案，一般理解云服务器和VPS一样，同样是虚拟化的技术虚拟出来的服务器。也有人说以前的VPS就是现在的ECS，其实不然，云服务器是一个计算，网络，存储的组合。简单点说就是通过多个CPU，内存，硬盘组成的计算池和存储池和网络的组合；在这样的平台上虚拟出的服务器，用户可以根据自己的运算需要选择配置不同的云服务器。具体区别总结如下：\n\n![呈现引擎的基本流程图](/img/VPS&ECS.png)\n\n\n","slug":"服务器/虚拟主机&VPS&ECS","published":1,"updated":"2017-10-24T12:26:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaqhv1gm000dbtx1bpgowi29","content":"<blockquote>\n<p>想做一个网站，但是在各种类型的服务器琳琅满目，现在总结一下市场上常见的几种服务器。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>1.虚拟主机</p>\n<p>虚拟主机就是利用虚拟化的技术，将一台服务器划分出一定大小的空间，每个空间都给予单独的 FTP 权限和 Web 访问权限，多个用户共同平均使用这台服务器的硬件资源。不同配置的虚拟主机主要是在磁盘空间、数据库大小、流量上面的区别。虚拟主机也有可以分为独享的虚拟主机，和共享的虚拟主机。顾名思义，两者之间的区别在于服务器资源的独享和共享。网站主机、空间、都是一个意思。这一类的主机用户的权限很低，没有远程桌面，只有FTP权限供用户上传文档等操作。优势是比较价格便宜。</p>\n<p>2.VPS</p>\n<p>先说一下vps，Virtual Private Server 虚拟专用服务器,一般是将一个独立服务器通过虚拟化技术虚拟成多个虚拟专用服务器。与虚拟主机不同的是，你拥有的是一台虚拟的服务器，类似于Windows上的虚拟机一样，虽然是虚拟的，但是使用起来，和使用客户机没有什么区别。同理，VPS可以使用远程桌面登录对服务器进行维护操作。</p>\n<p>3.ECS云服务器</p>\n<p>现在的主流的服务器解决方案，一般理解云服务器和VPS一样，同样是虚拟化的技术虚拟出来的服务器。也有人说以前的VPS就是现在的ECS，其实不然，云服务器是一个计算，网络，存储的组合。简单点说就是通过多个CPU，内存，硬盘组成的计算池和存储池和网络的组合；在这样的平台上虚拟出的服务器，用户可以根据自己的运算需要选择配置不同的云服务器。具体区别总结如下：</p>\n<p><img src=\"/img/VPS&amp;ECS.png\" alt=\"呈现引擎的基本流程图\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>想做一个网站，但是在各种类型的服务器琳琅满目，现在总结一下市场上常见的几种服务器。</p>\n</blockquote>","more":"<p>1.虚拟主机</p>\n<p>虚拟主机就是利用虚拟化的技术，将一台服务器划分出一定大小的空间，每个空间都给予单独的 FTP 权限和 Web 访问权限，多个用户共同平均使用这台服务器的硬件资源。不同配置的虚拟主机主要是在磁盘空间、数据库大小、流量上面的区别。虚拟主机也有可以分为独享的虚拟主机，和共享的虚拟主机。顾名思义，两者之间的区别在于服务器资源的独享和共享。网站主机、空间、都是一个意思。这一类的主机用户的权限很低，没有远程桌面，只有FTP权限供用户上传文档等操作。优势是比较价格便宜。</p>\n<p>2.VPS</p>\n<p>先说一下vps，Virtual Private Server 虚拟专用服务器,一般是将一个独立服务器通过虚拟化技术虚拟成多个虚拟专用服务器。与虚拟主机不同的是，你拥有的是一台虚拟的服务器，类似于Windows上的虚拟机一样，虽然是虚拟的，但是使用起来，和使用客户机没有什么区别。同理，VPS可以使用远程桌面登录对服务器进行维护操作。</p>\n<p>3.ECS云服务器</p>\n<p>现在的主流的服务器解决方案，一般理解云服务器和VPS一样，同样是虚拟化的技术虚拟出来的服务器。也有人说以前的VPS就是现在的ECS，其实不然，云服务器是一个计算，网络，存储的组合。简单点说就是通过多个CPU，内存，硬盘组成的计算池和存储池和网络的组合；在这样的平台上虚拟出的服务器，用户可以根据自己的运算需要选择配置不同的云服务器。具体区别总结如下：</p>\n<p><img src=\"/img/VPS&amp;ECS.png\" alt=\"呈现引擎的基本流程图\"></p>"},{"title":"探索浏览器","date":"2017-10-19T06:37:45.000Z","_content":"\n* [简介](#0)\n* [浏览器内核](#1)\n* [浏览器的主要功能](#2)\n* [浏览器的高层结构](#3)\n* [主流程](#4)\n* [浏览器处理脚本和样式表的顺序](#5)\n* [浏览器如何干活的](#6)\n\n<!-- more -->\n\n### <span id='0'>简介</span>\n\n网页浏览器（英语：web browser），常被简称为浏览器，是一种用于检索并展示万维网信息资源的应用程序。这些信息资源可为网页、图片、影音或其他内容，它们由统一资源标志符标志。信息资源中的超链接可使用户方便地浏览相关信息。\n\n网页浏览器虽然主要用于使用万维网，但也可用于获取专用网络中网页服务器之信息或文件系统内之文件。\n\n主流网页浏览器(内核): Internet Explorer(Trident)、Firefox(Gecko)、Safari(WebKit)、Chrome(WebKit)、Opera(Blink)\n\n### <span id='1'>[浏览器内核(渲染引擎)](https://baike.baidu.com/item/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/10602413?fr=aladdin)</span>\n\n浏览器最重要或者说核心的部分是_***浏览器内核***_，也称为排版引擎（layout engine）、页面渲染引擎（rendering engine）或样版引擎\n\n负责对网页语法的解释并渲染网页。 所以，通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因\n\n### <span id='2'>浏览器的主要功能</span>\n\n向服务器发出请求，在浏览器窗口中展示您选择的网络资源(一般是指 HTML 文档，也可以是 PDF、图片或其他的类型), 资源的位置由用户使用 URI（统一资源标示符）指定\n\n浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。 \n多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范\n\n奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如 Firefox 的下载管理器\n\n### <span id='3'>浏览器的高层结构</span>\n\n* **用户界面** - 包括地址栏、前进/后退按钮、书签菜单、用于刷新和停止加载当前文档的刷新和停止按钮、用于返回主页的主页按钮等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。\n* **浏览器引擎** - 在用户界面和呈现引擎之间传送指令。\n* **呈现引擎** - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。\n* **网络** - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。\n* **用户界面后端** - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。\n* **JavaScript 解释器**。用于解析和执行 JavaScript 代码。\n* **数据存储**。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“[网络数据库](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%BA%93/1717974?fr=aladdin)”，这是一个完整（但是轻便）的浏览器内数据库。\n\n![浏览器的主要组件图](/img/broswer1.png \"浏览器的主要组件\")\n_值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程(即每个标签页面都在独立的“沙箱”内运行，在提高安全性的同时，一个标签页面的崩溃也不会导致其他标签页面被关闭)_\n\n### <span id='4'>主流程</span>\n呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。\n\n然后进行如下所示的基本流程\n\n![呈现引擎的基本流程图](/img/broswer2.png \"呈现引擎的基本流程\")\n\n解析HTML来构造DOM树----->构造渲染树----->布局渲染树----->绘制渲染树\n\n呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：呈现树。\n\n呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。\n\n呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。\n\n需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。\n\n#### 主流程示例\n虽然 WebKit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。\n\n![呈现引擎的基本流程图](/img/broswer3.png)\n\n* Gecko将视觉格式化元素组成的树称为”框架树”(frame)。每个元素都是一个框架。Webkit使用的术语是”渲染树”(render)，它由”渲染对象”组成。\n* 对于元素的放置，Webkit 使用的术语是”布局”(layout)，而 Gecko 称之为”重排”(reflow)。\n* Webkit称利用dom节点及样式信息去构建render树的过程为attachment，Gecko在html和dom树之间附加了一层，这层称为内容接收器，相当制造dom元素的工厂\n\n### <span id='5'>浏览器处理脚本和样式表的顺序</span>\n\n#### 预解析\n\nWebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。\n\n#### 脚本\n\n网络的模型是同步的。网页作者希望解析器遇到 &lt;script&gt; 标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在 HTML4 和 HTML5 规范中进行了指定。作者也可以将脚本标注为“defer”，这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 增加了一个选项，可将脚本标记为异步，以便由其他线程解析和执行。\n\n#### 样式表\n\n另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。\n\n### <span id='6'>浏览器如何干活的?</span>\n\n1. 用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；\n2. 浏览器开始载入html代码，发现 &lt;head&gt; 标签内有一个 &lt;link&gt; 标签引用外部CSS文件；\n3. 浏览器又发出CSS文件的请求，服务器返回这个CSS文件；\n4. 浏览器继续载入html中 &lt;body&gt; 部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；\n5. 浏览器在代码中发现一个 &lt;img&gt;标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；\n6. 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；\n7. 浏览器发现了一个包含一行Javascript代码的 &lt;script&gt; 标签，赶快运行它；\n8. Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个 div （style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码；\n9. 终于等到了/html 的到来，浏览器泪流满面……\n10. 等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下&lt;link&gt;标签的CSS路径；\n11. 浏览器召集了在座的各位&lt;span&gt;&lt;ul&gt;&lt;li&gt;们，“大伙儿收拾收拾 行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/浏览器/浏览器工作原理.md","raw":"---\ntitle: 探索浏览器\ndate: 2017-10-19 14:37:45\ncategories:\n- 浏览器\ntags:\n- 浏览器\n---\n\n* [简介](#0)\n* [浏览器内核](#1)\n* [浏览器的主要功能](#2)\n* [浏览器的高层结构](#3)\n* [主流程](#4)\n* [浏览器处理脚本和样式表的顺序](#5)\n* [浏览器如何干活的](#6)\n\n<!-- more -->\n\n### <span id='0'>简介</span>\n\n网页浏览器（英语：web browser），常被简称为浏览器，是一种用于检索并展示万维网信息资源的应用程序。这些信息资源可为网页、图片、影音或其他内容，它们由统一资源标志符标志。信息资源中的超链接可使用户方便地浏览相关信息。\n\n网页浏览器虽然主要用于使用万维网，但也可用于获取专用网络中网页服务器之信息或文件系统内之文件。\n\n主流网页浏览器(内核): Internet Explorer(Trident)、Firefox(Gecko)、Safari(WebKit)、Chrome(WebKit)、Opera(Blink)\n\n### <span id='1'>[浏览器内核(渲染引擎)](https://baike.baidu.com/item/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/10602413?fr=aladdin)</span>\n\n浏览器最重要或者说核心的部分是_***浏览器内核***_，也称为排版引擎（layout engine）、页面渲染引擎（rendering engine）或样版引擎\n\n负责对网页语法的解释并渲染网页。 所以，通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因\n\n### <span id='2'>浏览器的主要功能</span>\n\n向服务器发出请求，在浏览器窗口中展示您选择的网络资源(一般是指 HTML 文档，也可以是 PDF、图片或其他的类型), 资源的位置由用户使用 URI（统一资源标示符）指定\n\n浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。 \n多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范\n\n奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如 Firefox 的下载管理器\n\n### <span id='3'>浏览器的高层结构</span>\n\n* **用户界面** - 包括地址栏、前进/后退按钮、书签菜单、用于刷新和停止加载当前文档的刷新和停止按钮、用于返回主页的主页按钮等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。\n* **浏览器引擎** - 在用户界面和呈现引擎之间传送指令。\n* **呈现引擎** - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。\n* **网络** - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。\n* **用户界面后端** - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。\n* **JavaScript 解释器**。用于解析和执行 JavaScript 代码。\n* **数据存储**。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“[网络数据库](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%BA%93/1717974?fr=aladdin)”，这是一个完整（但是轻便）的浏览器内数据库。\n\n![浏览器的主要组件图](/img/broswer1.png \"浏览器的主要组件\")\n_值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程(即每个标签页面都在独立的“沙箱”内运行，在提高安全性的同时，一个标签页面的崩溃也不会导致其他标签页面被关闭)_\n\n### <span id='4'>主流程</span>\n呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。\n\n然后进行如下所示的基本流程\n\n![呈现引擎的基本流程图](/img/broswer2.png \"呈现引擎的基本流程\")\n\n解析HTML来构造DOM树----->构造渲染树----->布局渲染树----->绘制渲染树\n\n呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：呈现树。\n\n呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。\n\n呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。\n\n需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。\n\n#### 主流程示例\n虽然 WebKit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。\n\n![呈现引擎的基本流程图](/img/broswer3.png)\n\n* Gecko将视觉格式化元素组成的树称为”框架树”(frame)。每个元素都是一个框架。Webkit使用的术语是”渲染树”(render)，它由”渲染对象”组成。\n* 对于元素的放置，Webkit 使用的术语是”布局”(layout)，而 Gecko 称之为”重排”(reflow)。\n* Webkit称利用dom节点及样式信息去构建render树的过程为attachment，Gecko在html和dom树之间附加了一层，这层称为内容接收器，相当制造dom元素的工厂\n\n### <span id='5'>浏览器处理脚本和样式表的顺序</span>\n\n#### 预解析\n\nWebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。\n\n#### 脚本\n\n网络的模型是同步的。网页作者希望解析器遇到 &lt;script&gt; 标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在 HTML4 和 HTML5 规范中进行了指定。作者也可以将脚本标注为“defer”，这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 增加了一个选项，可将脚本标记为异步，以便由其他线程解析和执行。\n\n#### 样式表\n\n另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。\n\n### <span id='6'>浏览器如何干活的?</span>\n\n1. 用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；\n2. 浏览器开始载入html代码，发现 &lt;head&gt; 标签内有一个 &lt;link&gt; 标签引用外部CSS文件；\n3. 浏览器又发出CSS文件的请求，服务器返回这个CSS文件；\n4. 浏览器继续载入html中 &lt;body&gt; 部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；\n5. 浏览器在代码中发现一个 &lt;img&gt;标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；\n6. 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；\n7. 浏览器发现了一个包含一行Javascript代码的 &lt;script&gt; 标签，赶快运行它；\n8. Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个 div （style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码；\n9. 终于等到了/html 的到来，浏览器泪流满面……\n10. 等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下&lt;link&gt;标签的CSS路径；\n11. 浏览器召集了在座的各位&lt;span&gt;&lt;ul&gt;&lt;li&gt;们，“大伙儿收拾收拾 行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"浏览器/浏览器工作原理","published":1,"updated":"2017-10-20T01:21:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaqhv1gn000ebtx12o8q0keg","content":"<ul>\n<li><a href=\"#0\">简介</a></li>\n<li><a href=\"#1\">浏览器内核</a></li>\n<li><a href=\"#2\">浏览器的主要功能</a></li>\n<li><a href=\"#3\">浏览器的高层结构</a></li>\n<li><a href=\"#4\">主流程</a></li>\n<li><a href=\"#5\">浏览器处理脚本和样式表的顺序</a></li>\n<li><a href=\"#6\">浏览器如何干活的</a></li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><span id=\"0\">简介</span></h3><p>网页浏览器（英语：web browser），常被简称为浏览器，是一种用于检索并展示万维网信息资源的应用程序。这些信息资源可为网页、图片、影音或其他内容，它们由统一资源标志符标志。信息资源中的超链接可使用户方便地浏览相关信息。</p>\n<p>网页浏览器虽然主要用于使用万维网，但也可用于获取专用网络中网页服务器之信息或文件系统内之文件。</p>\n<p>主流网页浏览器(内核): Internet Explorer(Trident)、Firefox(Gecko)、Safari(WebKit)、Chrome(WebKit)、Opera(Blink)</p>\n<h3 id=\"浏览器内核-渲染引擎\"><a href=\"#浏览器内核-渲染引擎\" class=\"headerlink\" title=\"浏览器内核(渲染引擎)\"></a><span id=\"1\"><a href=\"https://baike.baidu.com/item/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/10602413?fr=aladdin\" target=\"_blank\" rel=\"noopener\">浏览器内核(渲染引擎)</a></span></h3><p>浏览器最重要或者说核心的部分是<em><strong><em>浏览器内核</em></strong></em>，也称为排版引擎（layout engine）、页面渲染引擎（rendering engine）或样版引擎</p>\n<p>负责对网页语法的解释并渲染网页。 所以，通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因</p>\n<h3 id=\"浏览器的主要功能\"><a href=\"#浏览器的主要功能\" class=\"headerlink\" title=\"浏览器的主要功能\"></a><span id=\"2\">浏览器的主要功能</span></h3><p>向服务器发出请求，在浏览器窗口中展示您选择的网络资源(一般是指 HTML 文档，也可以是 PDF、图片或其他的类型), 资源的位置由用户使用 URI（统一资源标示符）指定</p>\n<p>浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。<br>多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范</p>\n<p>奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如 Firefox 的下载管理器</p>\n<h3 id=\"浏览器的高层结构\"><a href=\"#浏览器的高层结构\" class=\"headerlink\" title=\"浏览器的高层结构\"></a><span id=\"3\">浏览器的高层结构</span></h3><ul>\n<li><strong>用户界面</strong> - 包括地址栏、前进/后退按钮、书签菜单、用于刷新和停止加载当前文档的刷新和停止按钮、用于返回主页的主页按钮等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</li>\n<li><strong>浏览器引擎</strong> - 在用户界面和呈现引擎之间传送指令。</li>\n<li><strong>呈现引擎</strong> - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li>\n<li><strong>网络</strong> - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</li>\n<li><strong>用户界面后端</strong> - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</li>\n<li><strong>JavaScript 解释器</strong>。用于解析和执行 JavaScript 代码。</li>\n<li><strong>数据存储</strong>。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“<a href=\"https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%BA%93/1717974?fr=aladdin\" target=\"_blank\" rel=\"noopener\">网络数据库</a>”，这是一个完整（但是轻便）的浏览器内数据库。</li>\n</ul>\n<p><img src=\"/img/broswer1.png\" alt=\"浏览器的主要组件图\" title=\"浏览器的主要组件\"><br><em>值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程(即每个标签页面都在独立的“沙箱”内运行，在提高安全性的同时，一个标签页面的崩溃也不会导致其他标签页面被关闭)</em></p>\n<h3 id=\"主流程\"><a href=\"#主流程\" class=\"headerlink\" title=\"主流程\"></a><span id=\"4\">主流程</span></h3><p>呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。</p>\n<p>然后进行如下所示的基本流程</p>\n<p><img src=\"/img/broswer2.png\" alt=\"呈现引擎的基本流程图\" title=\"呈现引擎的基本流程\"></p>\n<p>解析HTML来构造DOM树—–&gt;构造渲染树—–&gt;布局渲染树—–&gt;绘制渲染树</p>\n<p>呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：呈现树。</p>\n<p>呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</p>\n<p>呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。</p>\n<p>需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。</p>\n<h4 id=\"主流程示例\"><a href=\"#主流程示例\" class=\"headerlink\" title=\"主流程示例\"></a>主流程示例</h4><p>虽然 WebKit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。</p>\n<p><img src=\"/img/broswer3.png\" alt=\"呈现引擎的基本流程图\"></p>\n<ul>\n<li>Gecko将视觉格式化元素组成的树称为”框架树”(frame)。每个元素都是一个框架。Webkit使用的术语是”渲染树”(render)，它由”渲染对象”组成。</li>\n<li>对于元素的放置，Webkit 使用的术语是”布局”(layout)，而 Gecko 称之为”重排”(reflow)。</li>\n<li>Webkit称利用dom节点及样式信息去构建render树的过程为attachment，Gecko在html和dom树之间附加了一层，这层称为内容接收器，相当制造dom元素的工厂</li>\n</ul>\n<h3 id=\"浏览器处理脚本和样式表的顺序\"><a href=\"#浏览器处理脚本和样式表的顺序\" class=\"headerlink\" title=\"浏览器处理脚本和样式表的顺序\"></a><span id=\"5\">浏览器处理脚本和样式表的顺序</span></h3><h4 id=\"预解析\"><a href=\"#预解析\" class=\"headerlink\" title=\"预解析\"></a>预解析</h4><p>WebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。</p>\n<h4 id=\"脚本\"><a href=\"#脚本\" class=\"headerlink\" title=\"脚本\"></a>脚本</h4><p>网络的模型是同步的。网页作者希望解析器遇到 &lt;script&gt; 标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在 HTML4 和 HTML5 规范中进行了指定。作者也可以将脚本标注为“defer”，这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 增加了一个选项，可将脚本标记为异步，以便由其他线程解析和执行。</p>\n<h4 id=\"样式表\"><a href=\"#样式表\" class=\"headerlink\" title=\"样式表\"></a>样式表</h4><p>另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。</p>\n<h3 id=\"浏览器如何干活的\"><a href=\"#浏览器如何干活的\" class=\"headerlink\" title=\"浏览器如何干活的?\"></a><span id=\"6\">浏览器如何干活的?</span></h3><ol>\n<li>用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；</li>\n<li>浏览器开始载入html代码，发现 &lt;head&gt; 标签内有一个 &lt;link&gt; 标签引用外部CSS文件；</li>\n<li>浏览器又发出CSS文件的请求，服务器返回这个CSS文件；</li>\n<li>浏览器继续载入html中 &lt;body&gt; 部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；</li>\n<li>浏览器在代码中发现一个 &lt;img&gt;标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；</li>\n<li>服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；</li>\n<li>浏览器发现了一个包含一行Javascript代码的 &lt;script&gt; 标签，赶快运行它；</li>\n<li>Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个 div （style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码；</li>\n<li>终于等到了/html 的到来，浏览器泪流满面……</li>\n<li>等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下&lt;link&gt;标签的CSS路径；</li>\n<li>浏览器召集了在座的各位&lt;span&gt;&lt;ul&gt;&lt;li&gt;们，“大伙儿收拾收拾 行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<ul>\n<li><a href=\"#0\">简介</a></li>\n<li><a href=\"#1\">浏览器内核</a></li>\n<li><a href=\"#2\">浏览器的主要功能</a></li>\n<li><a href=\"#3\">浏览器的高层结构</a></li>\n<li><a href=\"#4\">主流程</a></li>\n<li><a href=\"#5\">浏览器处理脚本和样式表的顺序</a></li>\n<li><a href=\"#6\">浏览器如何干活的</a></li>\n</ul>","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><span id=\"0\">简介</span></h3><p>网页浏览器（英语：web browser），常被简称为浏览器，是一种用于检索并展示万维网信息资源的应用程序。这些信息资源可为网页、图片、影音或其他内容，它们由统一资源标志符标志。信息资源中的超链接可使用户方便地浏览相关信息。</p>\n<p>网页浏览器虽然主要用于使用万维网，但也可用于获取专用网络中网页服务器之信息或文件系统内之文件。</p>\n<p>主流网页浏览器(内核): Internet Explorer(Trident)、Firefox(Gecko)、Safari(WebKit)、Chrome(WebKit)、Opera(Blink)</p>\n<h3 id=\"浏览器内核-渲染引擎\"><a href=\"#浏览器内核-渲染引擎\" class=\"headerlink\" title=\"浏览器内核(渲染引擎)\"></a><span id=\"1\"><a href=\"https://baike.baidu.com/item/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/10602413?fr=aladdin\" target=\"_blank\" rel=\"noopener\">浏览器内核(渲染引擎)</a></span></h3><p>浏览器最重要或者说核心的部分是<em><strong><em>浏览器内核</em></strong></em>，也称为排版引擎（layout engine）、页面渲染引擎（rendering engine）或样版引擎</p>\n<p>负责对网页语法的解释并渲染网页。 所以，通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因</p>\n<h3 id=\"浏览器的主要功能\"><a href=\"#浏览器的主要功能\" class=\"headerlink\" title=\"浏览器的主要功能\"></a><span id=\"2\">浏览器的主要功能</span></h3><p>向服务器发出请求，在浏览器窗口中展示您选择的网络资源(一般是指 HTML 文档，也可以是 PDF、图片或其他的类型), 资源的位置由用户使用 URI（统一资源标示符）指定</p>\n<p>浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。<br>多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范</p>\n<p>奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如 Firefox 的下载管理器</p>\n<h3 id=\"浏览器的高层结构\"><a href=\"#浏览器的高层结构\" class=\"headerlink\" title=\"浏览器的高层结构\"></a><span id=\"3\">浏览器的高层结构</span></h3><ul>\n<li><strong>用户界面</strong> - 包括地址栏、前进/后退按钮、书签菜单、用于刷新和停止加载当前文档的刷新和停止按钮、用于返回主页的主页按钮等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</li>\n<li><strong>浏览器引擎</strong> - 在用户界面和呈现引擎之间传送指令。</li>\n<li><strong>呈现引擎</strong> - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li>\n<li><strong>网络</strong> - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</li>\n<li><strong>用户界面后端</strong> - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</li>\n<li><strong>JavaScript 解释器</strong>。用于解析和执行 JavaScript 代码。</li>\n<li><strong>数据存储</strong>。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“<a href=\"https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%BA%93/1717974?fr=aladdin\" target=\"_blank\" rel=\"noopener\">网络数据库</a>”，这是一个完整（但是轻便）的浏览器内数据库。</li>\n</ul>\n<p><img src=\"/img/broswer1.png\" alt=\"浏览器的主要组件图\" title=\"浏览器的主要组件\"><br><em>值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程(即每个标签页面都在独立的“沙箱”内运行，在提高安全性的同时，一个标签页面的崩溃也不会导致其他标签页面被关闭)</em></p>\n<h3 id=\"主流程\"><a href=\"#主流程\" class=\"headerlink\" title=\"主流程\"></a><span id=\"4\">主流程</span></h3><p>呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。</p>\n<p>然后进行如下所示的基本流程</p>\n<p><img src=\"/img/broswer2.png\" alt=\"呈现引擎的基本流程图\" title=\"呈现引擎的基本流程\"></p>\n<p>解析HTML来构造DOM树—–&gt;构造渲染树—–&gt;布局渲染树—–&gt;绘制渲染树</p>\n<p>呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：呈现树。</p>\n<p>呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</p>\n<p>呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。</p>\n<p>需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。</p>\n<h4 id=\"主流程示例\"><a href=\"#主流程示例\" class=\"headerlink\" title=\"主流程示例\"></a>主流程示例</h4><p>虽然 WebKit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。</p>\n<p><img src=\"/img/broswer3.png\" alt=\"呈现引擎的基本流程图\"></p>\n<ul>\n<li>Gecko将视觉格式化元素组成的树称为”框架树”(frame)。每个元素都是一个框架。Webkit使用的术语是”渲染树”(render)，它由”渲染对象”组成。</li>\n<li>对于元素的放置，Webkit 使用的术语是”布局”(layout)，而 Gecko 称之为”重排”(reflow)。</li>\n<li>Webkit称利用dom节点及样式信息去构建render树的过程为attachment，Gecko在html和dom树之间附加了一层，这层称为内容接收器，相当制造dom元素的工厂</li>\n</ul>\n<h3 id=\"浏览器处理脚本和样式表的顺序\"><a href=\"#浏览器处理脚本和样式表的顺序\" class=\"headerlink\" title=\"浏览器处理脚本和样式表的顺序\"></a><span id=\"5\">浏览器处理脚本和样式表的顺序</span></h3><h4 id=\"预解析\"><a href=\"#预解析\" class=\"headerlink\" title=\"预解析\"></a>预解析</h4><p>WebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。</p>\n<h4 id=\"脚本\"><a href=\"#脚本\" class=\"headerlink\" title=\"脚本\"></a>脚本</h4><p>网络的模型是同步的。网页作者希望解析器遇到 &lt;script&gt; 标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在 HTML4 和 HTML5 规范中进行了指定。作者也可以将脚本标注为“defer”，这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 增加了一个选项，可将脚本标记为异步，以便由其他线程解析和执行。</p>\n<h4 id=\"样式表\"><a href=\"#样式表\" class=\"headerlink\" title=\"样式表\"></a>样式表</h4><p>另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。</p>\n<h3 id=\"浏览器如何干活的\"><a href=\"#浏览器如何干活的\" class=\"headerlink\" title=\"浏览器如何干活的?\"></a><span id=\"6\">浏览器如何干活的?</span></h3><ol>\n<li>用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；</li>\n<li>浏览器开始载入html代码，发现 &lt;head&gt; 标签内有一个 &lt;link&gt; 标签引用外部CSS文件；</li>\n<li>浏览器又发出CSS文件的请求，服务器返回这个CSS文件；</li>\n<li>浏览器继续载入html中 &lt;body&gt; 部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；</li>\n<li>浏览器在代码中发现一个 &lt;img&gt;标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；</li>\n<li>服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；</li>\n<li>浏览器发现了一个包含一行Javascript代码的 &lt;script&gt; 标签，赶快运行它；</li>\n<li>Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个 div （style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码；</li>\n<li>终于等到了/html 的到来，浏览器泪流满面……</li>\n<li>等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下&lt;link&gt;标签的CSS路径；</li>\n<li>浏览器召集了在座的各位&lt;span&gt;&lt;ul&gt;&lt;li&gt;们，“大伙儿收拾收拾 行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。</li>\n</ol>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjaqhv1g30001btx1dbbnfunk","category_id":"cjaqhv1gd0005btx16v5pava4","_id":"cjaqhv1gs000ibtx1toyqkoba"},{"post_id":"cjaqhv1gc0004btx1mmo49hst","category_id":"cjaqhv1gs000gbtx1hjjryd05","_id":"cjaqhv1h00010btx1nq98kllb"},{"post_id":"cjaqhv1gf0007btx1xptx4a6q","category_id":"cjaqhv1gt000jbtx1qtm8ccrf","_id":"cjaqhv1h00012btx1mewaivbm"},{"post_id":"cjaqhv1gg0008btx1hnvvrqg2","category_id":"cjaqhv1gt000jbtx1qtm8ccrf","_id":"cjaqhv1h00014btx1cncycp08"},{"post_id":"cjaqhv1gh0009btx1icse7htr","category_id":"cjaqhv1gt000jbtx1qtm8ccrf","_id":"cjaqhv1h00016btx1ab4whuwb"},{"post_id":"cjaqhv1gh000abtx1pjuk2htf","category_id":"cjaqhv1gv000pbtx1dn2l463g","_id":"cjaqhv1h00018btx1ri55v7yx"},{"post_id":"cjaqhv1gj000bbtx1fyqvh35d","category_id":"cjaqhv1gv000pbtx1dn2l463g","_id":"cjaqhv1h0001abtx125pl7h6c"},{"post_id":"cjaqhv1gk000cbtx1pqs57irx","category_id":"cjaqhv1gv000pbtx1dn2l463g","_id":"cjaqhv1h0001cbtx1x2v24jea"},{"post_id":"cjaqhv1gm000dbtx1bpgowi29","category_id":"cjaqhv1gw000vbtx1w3hpzs42","_id":"cjaqhv1h0001ebtx1gyyjm12x"},{"post_id":"cjaqhv1gn000ebtx12o8q0keg","category_id":"cjaqhv1gw000xbtx1kmkx0t53","_id":"cjaqhv1h1001gbtx125fvhih3"}],"PostTag":[{"post_id":"cjaqhv1g30001btx1dbbnfunk","tag_id":"cjaqhv1ge0006btx1uxp4k94j","_id":"cjaqhv1gs000fbtx1bmkv30dy"},{"post_id":"cjaqhv1gc0004btx1mmo49hst","tag_id":"cjaqhv1gs000hbtx1vqm6cq6m","_id":"cjaqhv1h0000zbtx19vywey0e"},{"post_id":"cjaqhv1gf0007btx1xptx4a6q","tag_id":"cjaqhv1gt000kbtx12g998gjb","_id":"cjaqhv1h00011btx1ldeeosq6"},{"post_id":"cjaqhv1gg0008btx1hnvvrqg2","tag_id":"cjaqhv1gt000mbtx1ryiri57f","_id":"cjaqhv1h00013btx1itt26d9c"},{"post_id":"cjaqhv1gh0009btx1icse7htr","tag_id":"cjaqhv1gv000obtx15cto2fw7","_id":"cjaqhv1h00015btx126n4dvv3"},{"post_id":"cjaqhv1gh000abtx1pjuk2htf","tag_id":"cjaqhv1gv000qbtx1whq83osb","_id":"cjaqhv1h00017btx1ia52t59i"},{"post_id":"cjaqhv1gj000bbtx1fyqvh35d","tag_id":"cjaqhv1gv000sbtx1zxklzvgf","_id":"cjaqhv1h00019btx159pgv90w"},{"post_id":"cjaqhv1gk000cbtx1pqs57irx","tag_id":"cjaqhv1gw000ubtx1kaipdfc2","_id":"cjaqhv1h0001bbtx1t34osjxv"},{"post_id":"cjaqhv1gm000dbtx1bpgowi29","tag_id":"cjaqhv1gw000wbtx16uug19fd","_id":"cjaqhv1h0001dbtx1t4u08y7b"},{"post_id":"cjaqhv1gn000ebtx12o8q0keg","tag_id":"cjaqhv1gw000ybtx1vw9qc10v","_id":"cjaqhv1h0001fbtx1yj2fc3az"}],"Tag":[{"name":"语法","_id":"cjaqhv1ge0006btx1uxp4k94j"},{"name":"css3","_id":"cjaqhv1gs000hbtx1vqm6cq6m"},{"name":"js继承","_id":"cjaqhv1gt000kbtx12g998gjb"},{"name":"创建型设计模式","_id":"cjaqhv1gt000mbtx1ryiri57f"},{"name":"结构型设计模式","_id":"cjaqhv1gv000obtx15cto2fw7"},{"name":"Git","_id":"cjaqhv1gv000qbtx1whq83osb"},{"name":"vsCode插件","_id":"cjaqhv1gv000sbtx1zxklzvgf"},{"name":"VPN","_id":"cjaqhv1gw000ubtx1kaipdfc2"},{"name":"服务器区别","_id":"cjaqhv1gw000wbtx16uug19fd"},{"name":"浏览器","_id":"cjaqhv1gw000ybtx1vw9qc10v"}]}}