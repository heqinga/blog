{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/VPS&ECS.png","path":"img/VPS&ECS.png","modified":1,"renderable":0},{"_id":"source/img/broswer1.png","path":"img/broswer1.png","modified":1,"renderable":0},{"_id":"source/img/broswer2.png","path":"img/broswer2.png","modified":1,"renderable":0},{"_id":"source/img/wxmoney.png","path":"img/wxmoney.png","modified":1,"renderable":0},{"_id":"source/img/book-collection/1.jpg","path":"img/book-collection/1.jpg","modified":1,"renderable":0},{"_id":"source/img/book-collection/11.jpg","path":"img/book-collection/11.jpg","modified":1,"renderable":0},{"_id":"source/img/book-collection/10.jpg","path":"img/book-collection/10.jpg","modified":1,"renderable":0},{"_id":"source/img/book-collection/12.jpg","path":"img/book-collection/12.jpg","modified":1,"renderable":0},{"_id":"source/img/book-collection/13.jpg","path":"img/book-collection/13.jpg","modified":1,"renderable":0},{"_id":"source/img/book-collection/14.jpg","path":"img/book-collection/14.jpg","modified":1,"renderable":0},{"_id":"source/img/book-collection/17.jpg","path":"img/book-collection/17.jpg","modified":1,"renderable":0},{"_id":"source/img/book-collection/15.jpg","path":"img/book-collection/15.jpg","modified":1,"renderable":0},{"_id":"source/img/book-collection/18.jpg","path":"img/book-collection/18.jpg","modified":1,"renderable":0},{"_id":"source/img/book-collection/16.jpg","path":"img/book-collection/16.jpg","modified":1,"renderable":0},{"_id":"source/img/book-collection/2.jpg","path":"img/book-collection/2.jpg","modified":1,"renderable":0},{"_id":"source/img/book-collection/4.jpg","path":"img/book-collection/4.jpg","modified":1,"renderable":0},{"_id":"source/img/book-collection/6.jpg","path":"img/book-collection/6.jpg","modified":1,"renderable":0},{"_id":"source/img/book-collection/3.jpg","path":"img/book-collection/3.jpg","modified":1,"renderable":0},{"_id":"source/img/book-collection/7.jpg","path":"img/book-collection/7.jpg","modified":1,"renderable":0},{"_id":"source/img/book-collection/8.jpg","path":"img/book-collection/8.jpg","modified":1,"renderable":0},{"_id":"source/img/book-collection/9.jpg","path":"img/book-collection/9.jpg","modified":1,"renderable":0},{"_id":"source/img/broswer3.png","path":"img/broswer3.png","modified":1,"renderable":0},{"_id":"source/img/js/array1.png","path":"img/js/array1.png","modified":1,"renderable":0},{"_id":"themes/hexo-theme-xups/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/scrolltoparrow.png","path":"img/scrolltoparrow.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/share.png","path":"img/share.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/tangtang.jpg","path":"img/tangtang.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/jelon.jpg","path":"img/jelon.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/url.png","path":"img/url.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/wechat_jelon.png","path":"img/wechat_jelon.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/wechat_mp.jpg","path":"img/wechat_mp.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/js/comment.js","path":"js/comment.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/js/html5.js","path":"js/html5.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/wechat_pay.png","path":"img/wechat_pay.png","modified":1,"renderable":1},{"_id":"source/img/book-collection/5.jpg","path":"img/book-collection/5.jpg","modified":1,"renderable":0},{"_id":"themes/hexo-theme-xups/source/img/unsigned_avatar.jpg","path":"img/unsigned_avatar.jpg","modified":1,"renderable":1},{"_id":"source/img/js/reg.png","path":"img/js/reg.png","modified":1,"renderable":0},{"_id":"themes/hexo-theme-xups/source/img/lab/banner.jpg","path":"img/lab/banner.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/0.jpg","path":"img/thumbnail/0.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/1.jpg","path":"img/thumbnail/1.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/4.jpg","path":"img/thumbnail/4.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/5.jpg","path":"img/thumbnail/5.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/6.jpg","path":"img/thumbnail/6.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/7.jpg","path":"img/thumbnail/7.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/8.jpg","path":"img/thumbnail/8.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/9.jpg","path":"img/thumbnail/9.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/icomoon/icomoon.ttf","path":"css/fonts/icomoon/icomoon.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/2.jpg","path":"img/thumbnail/2.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/3.jpg","path":"img/thumbnail/3.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/italic.otf","path":"css/fonts/homizio-nova/italic.otf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/italic.ttf","path":"css/fonts/homizio-nova/italic.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/light_italic.ttf","path":"css/fonts/homizio-nova/light_italic.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/light.otf","path":"css/fonts/homizio-nova/light.otf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/light_italic.otf","path":"css/fonts/homizio-nova/light_italic.otf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/icomoon/icomoon.eot","path":"css/fonts/icomoon/icomoon.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/icomoon/icomoon.svg","path":"css/fonts/icomoon/icomoon.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/icomoon/icomoon.woff","path":"css/fonts/icomoon/icomoon.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/regular.otf","path":"css/fonts/homizio-nova/regular.otf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/light.ttf","path":"css/fonts/homizio-nova/light.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/regular.ttf","path":"css/fonts/homizio-nova/regular.ttf","modified":1,"renderable":1},{"_id":"source/img/interview/react-ag-vue.png","path":"img/interview/react-ag-vue.png","modified":1,"renderable":0}],"Cache":[{"_id":"themes/hexo-theme-xups/.gitignore","hash":"0d5c2fdbdc974f10150baa12e1fc171a34960ed8","modified":1506220396000},{"_id":"themes/hexo-theme-xups/README.md","hash":"185d4f821ab2798a6252a05afc7c151fd4d87754","modified":1524549444000},{"_id":"themes/hexo-theme-xups/.DS_Store","hash":"52d97400984aa59237b7e4ebb36156420bdd8e29","modified":1506220396000},{"_id":"themes/hexo-theme-xups/_config.yml","hash":"b168f716548c502fec1470537fe9267115756f49","modified":1547023935000},{"_id":"source/.DS_Store","hash":"b640bd6cc1d1c66022cd7650e2d98e38901844eb","modified":1513738184000},{"_id":"themes/hexo-theme-xups/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1506220396000},{"_id":"themes/hexo-theme-xups/.git/FETCH_HEAD","hash":"0bcafc4c2e241ddba4e568821de5c4c4bec8fec6","modified":1509363582000},{"_id":"themes/hexo-theme-xups/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1506220330000},{"_id":"themes/hexo-theme-xups/.git/config","hash":"b1eac456c8f1f7cfa9eaa7e773f078fd9af0fb16","modified":1506220396000},{"_id":"themes/hexo-theme-xups/.git/index","hash":"c63420d2c428c22653460363028a1372636913fe","modified":1508464662000},{"_id":"themes/hexo-theme-xups/.git/packed-refs","hash":"34026cea14ed1c1e4396051e0d3ea41eb7290042","modified":1506220396000},{"_id":"themes/hexo-theme-xups/__scaffolds/draft.md","hash":"c569840f0ea232daf0865c3bc8f7ef63b235be62","modified":1508219222000},{"_id":"themes/hexo-theme-xups/__scaffolds/page.md","hash":"892cedeb7b62a73e72a3b369daf2bc63dfee47dc","modified":1506220396000},{"_id":"themes/hexo-theme-xups/__scaffolds/post.md","hash":"dddac2b2269831e3b5e69b7d1439f5170115e808","modified":1508219234000},{"_id":"themes/hexo-theme-xups/layout/archive.ejs","hash":"12b1b2f8ea19eb71e60b6ef5c015aaee6edec568","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/category.ejs","hash":"2f270f509a0f5d73e5f847fdc4351ccc1e76cef3","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/index.ejs","hash":"73e85788bc6a985fbbdf9c37279ccf611d53e9ee","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/page.ejs","hash":"66c8c314d4083fff38568f2900d98223c407d5ef","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/post.ejs","hash":"6690fe7adb736e9f3d9d7f65a6b964cdc3c21f20","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/layout.ejs","hash":"73f60bed976cc4e55eb2f4c1d3bec1e3975e86ba","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/tag.ejs","hash":"0a500f20b93139859120443e2e14592cce81e21c","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/.DS_Store","hash":"fba98dc5c9096d5dba9d35076164c00012d98e11","modified":1506220396000},{"_id":"source/_posts/markdown.md","hash":"485f3a525094073e49b5232f684e249d6a200263","modified":1523499862000},{"_id":"source/about/index.md","hash":"32707ad1a27069c7f30fdbd645da15d25910fb69","modified":1508206120000},{"_id":"source/comment/index.md","hash":"8ebc21dec895c59375e511f921c8eef99cf192e7","modified":1508206130000},{"_id":"source/img/.DS_Store","hash":"6be77692026719e4c9578785ab98dfb083575d7b","modified":1525748422000},{"_id":"source/lab/index.md","hash":"02ed8ae0c6e15aa32406efa5d6683e3a3c780b53","modified":1551159675000},{"_id":"source/img/VPS&ECS.png","hash":"e431db60727e7e12b33d8503d8abe81a75482b62","modified":1508727976000},{"_id":"source/img/broswer1.png","hash":"df67868a7f4d73223459d6540ae2672fe29affd6","modified":1508461294000},{"_id":"source/img/broswer2.png","hash":"833735aedd34713060fd5ed98bdbe3f974634c29","modified":1508461372000},{"_id":"source/img/wxmoney.png","hash":"59f5f4d6c8128a6125f7f3d4e9c34c6cf2550334","modified":1508462898000},{"_id":"themes/hexo-theme-xups/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1506220330000},{"_id":"themes/hexo-theme-xups/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1506220330000},{"_id":"themes/hexo-theme-xups/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1506220330000},{"_id":"themes/hexo-theme-xups/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1506220330000},{"_id":"themes/hexo-theme-xups/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1506220330000},{"_id":"themes/hexo-theme-xups/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1506220330000},{"_id":"themes/hexo-theme-xups/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1506220330000},{"_id":"themes/hexo-theme-xups/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1506220330000},{"_id":"themes/hexo-theme-xups/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1506220330000},{"_id":"themes/hexo-theme-xups/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1506220330000},{"_id":"themes/hexo-theme-xups/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1506220330000},{"_id":"themes/hexo-theme-xups/.git/logs/HEAD","hash":"039b4bc62aeed6fcd4c08ec37b6c7d7d573ea5de","modified":1506220396000},{"_id":"themes/hexo-theme-xups/__source/about/index.md","hash":"32707ad1a27069c7f30fdbd645da15d25910fb69","modified":1506220396000},{"_id":"themes/hexo-theme-xups/__source/comment/index.md","hash":"8ebc21dec895c59375e511f921c8eef99cf192e7","modified":1506220396000},{"_id":"themes/hexo-theme-xups/__source/lab/index.md","hash":"756591670a1f2a6819add9f344e59d312eeb4d40","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_custom/comment.ejs","hash":"a3c098be0f2b39208ee8bfe4d5a5474293698cc0","modified":1508463666000},{"_id":"themes/hexo-theme-xups/layout/_custom/about.ejs","hash":"9baf208ec128388f0fcbd6e5fa352e6934503a19","modified":1508228278000},{"_id":"themes/hexo-theme-xups/layout/_partial/after-footer.ejs","hash":"51e748ed5cdb4abce01a80501e702fbfedd5f147","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_custom/lab.ejs","hash":"f6f601ddf3e97ffaec9ce85db41b1fdfdf7c3fcc","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_partial/archive.ejs","hash":"beec255420d7e3ce5a5e681660d3d521859eeb5e","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_partial/archive-post.ejs","hash":"9d582c0b5c88a876cf825a1f4ac0ab1b6775a555","modified":1547023939000},{"_id":"themes/hexo-theme-xups/layout/_partial/baidu-analytics.ejs","hash":"9e9e8da02174f708aaefa4385b5b1d6fe45c807e","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_partial/head.ejs","hash":"b74173aa97f1bb843bc3a2091a616f5dd4e723f2","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_partial/footer.ejs","hash":"a7130465572d9a5546f23e4e01d4c455ffef045a","modified":1547023942000},{"_id":"themes/hexo-theme-xups/layout/_partial/header.ejs","hash":"22706f33ca3543eec8feffdfce8d4e008d2d24e4","modified":1524549418000},{"_id":"themes/hexo-theme-xups/layout/_partial/article.ejs","hash":"b5e9b201132b8c8031db802ce344adebe77e58ac","modified":1524549390000},{"_id":"themes/hexo-theme-xups/layout/_widget/categorys.ejs","hash":"29687d96d26fb41f0e78ef8fecc3be6da3d0da29","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_widget/tags.ejs","hash":"bc7b5e50b19e5a7f0f5c81d653407b26d8881c25","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_widget/friend_links.ejs","hash":"4ff96fbfb9d70b4636108c5deaaf041c6681ceeb","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_partial/sidebar.ejs","hash":"1ff3c93c5c4f169ee9c26590034187a2c02de095","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_widget/weibo.ejs","hash":"5803954fea40637eabfa96bfb6d38328d3c33005","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_extend.styl","hash":"4942d3ad93832e5b1ad559a1b66e89e145e982b9","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/.DS_Store","hash":"7a2750dc6206c6f07303809521f5eb6654cfc3b3","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_markdown.styl","hash":"0fd8cff5a5bbf93507817758478cd22efd3cfc88","modified":1524467821000},{"_id":"themes/hexo-theme-xups/source/css/_variables.styl","hash":"d0314bd375ba70110ae95a716b7f53a949545f69","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/style.styl","hash":"ae25cdd604a9e4643caa04c704593fd4cc70dfd6","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/default.png","hash":"a0e8360a185c7516bc2dddb25241daee67b42972","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/scrolltoparrow.png","hash":"53bd140adb85b23d535d1e488550eda4624a58bd","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/share.png","hash":"20a860aeb842a556d067deabb99f6bfc024c97d0","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/tangtang.jpg","hash":"d184ae15dfa844b8bae5c6d426d366f64caa31dd","modified":1508207548000},{"_id":"themes/hexo-theme-xups/source/img/.DS_Store","hash":"a1bdef3a79e0c0f0c4f92e81c00a875f6422dab5","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/jelon.jpg","hash":"5a698f21552a8365ef44f7113665bff8121635cb","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/loading.gif","hash":"92dcf9179379355f05cf2d1c8cceba930a2a674f","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/url.png","hash":"be1f35666ed5bf03aa3f6db121bd03c407b158a7","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/wechat_jelon.png","hash":"f1e1cab54bfb69e7816b1d5f355100ea8b272ce4","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/js/main.js","hash":"060111624471f2d2b58fdcc717b5079391664ac8","modified":1524549327000},{"_id":"themes/hexo-theme-xups/source/img/wechat_mp.jpg","hash":"d58b7796093ca8cdd4034b2dd28021c147199099","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/js/comment.js","hash":"d6966f84ac478feefecdf00068c292f02ca91c2c","modified":1524549310000},{"_id":"themes/hexo-theme-xups/source/js/html5.js","hash":"4fefd28dcad6c973c44719ce8b3a8b82fe670a59","modified":1506220396000},{"_id":"source/_posts/css/css3.md","hash":"f4828365b80b4efc699628ce0993d82f7ddd82ac","modified":1523499862000},{"_id":"themes/hexo-theme-xups/source/img/wechat_pay.png","hash":"3fb3bbd4b1fae4259578dce0ca838e0696283041","modified":1506220396000},{"_id":"source/_posts/javascript/js数组.md","hash":"9d90dde5621d253f42b0e6580f1e2a7420db7203","modified":1527762461000},{"_id":"source/_posts/javascript/js继承.md","hash":"21b03c0dbad9551cf3ebb2443ac51c8032e35806","modified":1527762461000},{"_id":"source/_posts/javascript/正则.md","hash":"0fa159807803988d2040dc8f7625dc4bb27d9ef5","modified":1527762461000},{"_id":"source/_posts/javascript/创建型设计模式.md","hash":"e013b868d717113d34a39f0283875dd6b44bfecf","modified":1527762461000},{"_id":"source/_posts/javascript/结构型设计模式.md","hash":"cc626a8aec3a9a7dd7b222a843f5d5d2cf6008a7","modified":1527762461000},{"_id":"source/_posts/javascript/行为型设计模式.md","hash":"8fc0e4c43406c7e0facf8d9e04127ab77cf4b326","modified":1527762461000},{"_id":"source/_posts/工具/Git.md","hash":"f52154e3e6a0851ac5d55798db4886b7d264e35b","modified":1523499862000},{"_id":"source/_posts/小领悟/名人名言.md","hash":"c72616f00854f0b1a6e2911404bf06f69da4ce15","modified":1527762461000},{"_id":"source/_posts/小领悟/领悟.md","hash":"d72ce7c93beb25b3a083eb1609b8075168778b95","modified":1525660862000},{"_id":"source/_posts/工具/vsCode.md","hash":"fd292ea3430d105c18e0298b6e9adfc8606a4022","modified":1523499862000},{"_id":"source/_posts/工具/科学上网.md","hash":"4f4e2cf736a9b1980eeb621dae7eacc54f6e96cb","modified":1523499862000},{"_id":"source/_posts/收藏/书籍收藏.md","hash":"665a8af9946f64bcca29977ff0d45f89882217ba","modified":1513739606000},{"_id":"source/_posts/服务器/虚拟主机&VPS&ECS.md","hash":"f09a0a22a0eb59d2c966a37defcf11fa1d3426a7","modified":1523499862000},{"_id":"source/_posts/浏览器/浏览器工作原理.md","hash":"e91dde5784779309dc81467b2163437bf54d63ee","modified":1523499862000},{"_id":"source/_posts/生活小常识/健康类.md","hash":"3ccc742999d00301e4ede3db70221db1de9ec87e","modified":1523499862000},{"_id":"source/_posts/英语/word.md","hash":"f6b1b861d4788ef979bc25fa8098c5a90de21373","modified":1551159675000},{"_id":"source/_posts/英语/4-unit-1.md","hash":"38c9623262fe5e183c52d8c415e9fb73df3e3f1c","modified":1527762461000},{"_id":"source/_posts/英语/4-unit-2.md","hash":"334e3f982c79b6cb7515226603b7d6bf517768a3","modified":1527762461000},{"_id":"source/_posts/英语/4-unit-3.md","hash":"cbae9ccb6b7442e9f2009a894016b9b92dd99a03","modified":1527762461000},{"_id":"source/_posts/英语/定语.md","hash":"7f7a53195d7068b0c0499b379acf4856c27bbae7","modified":1527762461000},{"_id":"source/_posts/英语/音标.md","hash":"053f59222ed84d7376e0b853f7a3a6bc2c34f985","modified":1527762461000},{"_id":"source/_posts/英语/语法.md","hash":"3738a0e372958217e17910b0cae21d1e8e1a2fb9","modified":1527762461000},{"_id":"source/_posts/面试/react-vue-angular.md","hash":"a8fff99ea18f5ba8a6191d14261c6bfcd2619ad5","modified":1551176058000},{"_id":"source/_posts/英语/预习face-to-face.md","hash":"31737145a9c8dd20fc3f164df70d04e5cf65a033","modified":1527762461000},{"_id":"source/_posts/面试/interview.md","hash":"d5ca111bbe7b4dab112e55c275f406b5743c8273","modified":1551159675000},{"_id":"source/_posts/面试/summary.md","hash":"ffeae94b5f0d7516e84a5def7abf2a18063f922c","modified":1551159675000},{"_id":"source/img/book-collection/1.jpg","hash":"3d23c162c7b27225ce5693ee32f0d829815de432","modified":1513046895000},{"_id":"source/_posts/面试/网易.md","hash":"66100e790975e364dd30138a590f38a2e8725cd5","modified":1527762461000},{"_id":"source/img/book-collection/11.jpg","hash":"d4b7d49e1e4ffa28df1095c739972f4850bf1e2c","modified":1513739606000},{"_id":"source/img/book-collection/10.jpg","hash":"4a2084aca751e325dd8e822180e40fe105620743","modified":1513739606000},{"_id":"source/img/book-collection/12.jpg","hash":"b9abe6d34795572c72b4a1061167ff95249a4067","modified":1513739606000},{"_id":"source/img/book-collection/13.jpg","hash":"f4aedbe699c6af7e1af9b43b064d34b8881f5a76","modified":1513739606000},{"_id":"source/img/book-collection/14.jpg","hash":"f203688115fa537a14c2c6c9f6562027fb396ef6","modified":1513739606000},{"_id":"source/img/book-collection/17.jpg","hash":"a92c309bc6e60b1f9bd5b00d8d07b762a52b9a55","modified":1513739606000},{"_id":"source/img/book-collection/15.jpg","hash":"e35f29b5f34244d22572b8c44909f5e8f26371c0","modified":1513739606000},{"_id":"source/img/book-collection/18.jpg","hash":"1183d77436009879e44a842eaa0fccead0b34c0f","modified":1513739606000},{"_id":"source/img/book-collection/16.jpg","hash":"0245201f5ff7768a664f85191af4b7828c391d35","modified":1513739606000},{"_id":"source/img/book-collection/2.jpg","hash":"9afd3a9edf826d1552bb08e72484afd2b9f338a0","modified":1513046895000},{"_id":"source/img/book-collection/4.jpg","hash":"aa29f26e03df76b52efde90da00e2a3921f3828e","modified":1513046895000},{"_id":"source/img/book-collection/6.jpg","hash":"03085293f5fa40f0a7b218552ea63db0adc82f80","modified":1513046895000},{"_id":"source/img/book-collection/3.jpg","hash":"ef1008a5cf5a3bf5b0c037018421bfd942c44cef","modified":1513046895000},{"_id":"source/img/book-collection/7.jpg","hash":"a164dc93c362fa91a2fda23fb6392fba7b2fe5a0","modified":1513046895000},{"_id":"source/img/book-collection/8.jpg","hash":"accd40ec1f97e6a1fde826c4392e6842f392dcf2","modified":1513739606000},{"_id":"source/img/js/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1525662566000},{"_id":"source/img/book-collection/9.jpg","hash":"4b937efaa670d2b7524fe6c13d5f851cb0060d82","modified":1513739606000},{"_id":"source/img/broswer3.png","hash":"b19dccceca4c92755dd05c573027b2cc6f5cfad9","modified":1508461388000},{"_id":"source/img/js/array1.png","hash":"57767c14aedbb8c13e0efba37418e18ea41ab639","modified":1527762461000},{"_id":"themes/hexo-theme-xups/source/img/unsigned_avatar.jpg","hash":"8343a845110fca8317440fcf61aae209eec57edf","modified":1506220396000},{"_id":"source/img/book-collection/5.jpg","hash":"81e4bf0dd9bd034b2a419912bd38432e11046e4d","modified":1513046895000},{"_id":"themes/hexo-theme-xups/.git/objects/02/3625784f28f3b354eda20403620e9661c3a4fd","hash":"75bb30c28a89b226a6ca2e42abab6b65fd0a22fc","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/05/5a1d04e139a9d10625a9622b891154fa77f629","hash":"ab9174032d130baa26fd55a8fa171f792338b071","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/07/88c51ce319feeb1bb080748537cc35da5172df","hash":"f4509752a341930a3d2537a87a876f199cc7a180","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/09/c4795bee22292233eee1077386e08920c43a7d","hash":"8cfc5691c253651d052a099c8d19cea691d206ae","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/0a/c82eef9557083be88e460179d251a415bb3a1c","hash":"d7aa5ad339ae39101a2b9db1f9187fec9ef1415e","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/0a/5c67282b5dba810f61e1cb7423e6284d4ddd38","hash":"3b1ccef8911406fccd093dbce83c6090363ca1f0","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/0b/d5c02aabf8953a6987008bafb4422ca4365fc7","hash":"2503e6ce0dfe54cbe271d62687fdeb92efae7dc9","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/0a/dfdab7b06eb9ea445cba64ef40be14f905f962","hash":"d7ac4ade0917efe61dd69c02c4cdb32983c69def","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/0f/25f46992eaef9933022b7a1cfa820d5e9f1ac4","hash":"fddba857db379bf7afbfe7d5297dee90fa6fa5e7","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/16/f77a5d1f2ad2afb71fab8f5db13d60915982ea","hash":"37d4e4f45b0caf7f9a8cb844c56e170f3ea2e590","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/1a/3c261c21f50a8138dadf343e0ac1d8d80316c6","hash":"f122b42ddfc1f9a795634c339a7c30823c8454ed","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/1b/b95a064a2fc7b9bb02c0ee5fe4e0cadd4466b3","hash":"e25b0a9e132296b21fa20c4be9fa37cc2158f371","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/1b/cffcf714e3f0a621f7399c25bcffd3e53a482e","hash":"3dbe4e1d9de57cab6aa8c11b6defbbe44ad53e74","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/1c/2d2aff83d314113731eaecf75241a6b1312b58","hash":"cb13a6bdce24e53e15438a9e95a6f7a443d95c5e","modified":1508679578000},{"_id":"themes/hexo-theme-xups/.git/objects/1c/87998c6266c6fd7b4158c0ab19981d39551721","hash":"be9bfa2a420a921c1bb03908ab51baede6dc4d81","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/1d/2c4aeb49f25e97ff062c0ae3ccc6f80952bac8","hash":"313d990c336fdf542d5803338e539e797f486fb1","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/20/ef9b243c5746f41a2b773946cf69fc3b467bfa","hash":"b8922fa389dd4c6f9759f170b2b971befb699c75","modified":1508679578000},{"_id":"themes/hexo-theme-xups/.git/objects/21/fb261968647f5625feb4f4956f8d7956285c90","hash":"80ae3c7ba2ba38411b027117116d0780839d3391","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/28/15221d20d8de97a3b966972523fb6fb4e729df","hash":"451181110c87f4a63898e907f4c3778e136a5dfd","modified":1508679578000},{"_id":"themes/hexo-theme-xups/.git/objects/2a/735c01e0d2d533d5de48f8a976c46ddb82a973","hash":"34b3ce7a2cb1f75161c36640b81bdbccfca0aede","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/30/454533d11049a6f9b4c1df5c02878f94da0af3","hash":"a18b19bd7215b87ca1c126ec13c2dcdc0440c882","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/32/7e24d50b0fbad866e7f006329d409f66fd82c4","hash":"9fa291978f99abec9f1ebf9d59f0514f16172bc0","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/34/c95e1582dc6e7cdba9b6f21c7473d3fd0a6eda","hash":"7b29ea2c16410cc2402da4cb2685a12c4b5c9f6a","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/40/88aec8b60be8bef8c9a76ceac7e01ea9c700d5","hash":"4dc13fbcfbd26624a6c7a8a2ba949995961a36b2","modified":1508679578000},{"_id":"themes/hexo-theme-xups/.git/objects/33/92d491b2c78a84aabbb2b1f9dadb494f2d4dbe","hash":"348f8143f9873b01216bd4af5747ef840a074657","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/37/93b9e02a69f21551eec4436befccede285be6b","hash":"ee0731c0332ac71e5ef5f81ab7556423f9bbb5ff","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/44/a14f7497eb9f86ad07c4d96176619487526d6f","hash":"99f356e281158347ee064b36e3c4e07ea58ec45f","modified":1508679578000},{"_id":"themes/hexo-theme-xups/.git/objects/43/e5301ee4ab98687533340372fd65f35c77723b","hash":"5d3b893395b41221acbe7a83204f2beb699a0288","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/47/c66da03e207f5e578366b6a25e5934d66ba64a","hash":"67e1422f029d85123d1042fcbce506b0bcbcc0bb","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/4a/b3b0bb88ea4fdf4aec8bd0e94a5e7a9c494bbc","hash":"571877c62c3f2839dd8653e72bf14a8bcf9c0f2d","modified":1508679578000},{"_id":"themes/hexo-theme-xups/.git/objects/4d/e0bcb0cf0f5ab78ca0e2a55a558efd55ddafb9","hash":"4197ea7bef62c4654803f66e3b3310e492fdabbb","modified":1508679578000},{"_id":"themes/hexo-theme-xups/.git/objects/65/ffc311c4fa640d4567d3197d6889d66da91f40","hash":"1c0e6a88b5599029f5fd20a692d1a38f22608ff4","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/5a/82ddbe100d7d52828b4b46db34a6867f7d2d00","hash":"5c052134d36c885ed41a95282ec03082422b7b9c","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/69/3e0a471c73f140e040edad2e506fbb807c9ba8","hash":"7fb07c169173b3b5700409f5fae1076c52111943","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/5f/18014b3757c684fc4c2a77b2a72ba9858c355a","hash":"256e38419e8c1218be556d2b51cf325ba504724b","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/6c/edc7f1c1e6f841f2f0849d41f7fe5d30703493","hash":"d42b0b4f0d6815eac855f609b237a3ad15d80d3b","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/72/17719bb788fd8f612e605d7b7fe9cc7250dbf1","hash":"c3092be7ae90224b64201bb174d5ca265d86cb40","modified":1508679578000},{"_id":"themes/hexo-theme-xups/.git/objects/69/c5e9cc08c0970b7703dbf12c1f5f119ec4077c","hash":"258ae27f817d668ee0b0207b29ae9a6f95388a47","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/6d/06771be9d2f0e19e64f8bfc2c86d5f270520a2","hash":"c75321a57cc4b5d6d331ed466aec606bfdc7947b","modified":1508679578000},{"_id":"themes/hexo-theme-xups/.git/objects/73/5468ea8a7c20c50f9568d31075f0c62ee26d19","hash":"b6458d113a31769ed7bdcdf08922fef8a0110fb8","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/7b/d67ebc6d0e2c0123d7bc1e1bfc3bbc26a69336","hash":"b47a378d031f23365aac50bbea31ef109873ddc9","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/72/89429f650491effa3f2c2e881d446757f1682d","hash":"707fd7a130b09b775b6db68fcb33c065d63d8ff3","modified":1508679578000},{"_id":"themes/hexo-theme-xups/.git/objects/85/0d9b170b71c90cb014347bb9d93039777d0b50","hash":"74f684d73c9af56126632627ede2dbbfd36aa85a","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/88/83e959ec8ef7e365d6b5c9622d45b3b1a56331","hash":"f7f8aafaf9094ef34809d163a43679d74ff63ba3","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/95/57618caf0355561e4ee16a3ff734b76305adc3","hash":"578ff9be2e2709adb404c81ed20d04633e8cc2dc","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/8f/d6955083a1ec744133c72de8e7be50d6e217d6","hash":"3fb595695c1b51a59ef82f346e37fcdfc832cfce","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/af/ecb850eecfcb55e0abe0f92ff2a3f2f4ecc416","hash":"bed96f4e0f56af34d4737b9822ae71a22b53baa8","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/91/6d557bea88b6355ccb4550d5dc48320910b693","hash":"92ff46cd9bf13c3ce972aa9e20611c7c46f9fc19","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/99/b6bd1ec1debaafe8875958424a020a74ab6a63","hash":"4d9c85b3bccc3a1e7bbba4cec4511372f76c5983","modified":1508679578000},{"_id":"themes/hexo-theme-xups/.git/objects/a3/80fb56a3bad93913300206e839c9e4ff6f7688","hash":"1137a1e9b6bb9453b7a2bbe242e9fde43b44dfb5","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/a4/38b08492663224d8354343ab2ef9f2a45a9bb1","hash":"a8be62e53fa81bdc2490ef639337375144c1d5af","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/b8/bfe4a486283b8ba87fbb1a0e42eff7fc14a544","hash":"8610e738d6528257820099104c9e94013cf121df","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/b9/680f7de9883eceac4e6834d560b98f875fe9b6","hash":"dd07732d8a8d25ee400c52e0cc7a9e0efa9e4a6e","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/ba/9974f225a155745a377ffe456b6d630c84524c","hash":"3aeab0b8f79fb6fa0f38770c522c75c1b1356a02","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/ba/630ac5a7a8bce954aba3401deafa548a751a1b","hash":"845b94114fde7931b7e650db8e36a694595dd375","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/c3/26f2a80da95f641887df8d6fa61ac48776e198","hash":"76c9a8c618a4ff30ac09991f6f6df7607791eb01","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/bc/11c3258d2387c120b76eed80b927e047b1f55d","hash":"b11405e6e4c7aaa42d02172b539aaa69be53da72","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/bd/d0334dce3286472a2f475d78512bb763ef5c08","hash":"7488981d277026023697601c6dec086b79402fe4","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/bf/ceb0d675d535b0b033ffb172b2cbe0aec7ddea","hash":"7363cc843e19f47ae4c8e57661f487502a4f0077","modified":1508679578000},{"_id":"themes/hexo-theme-xups/.git/objects/c8/612046440e48d45062cbb26436a8c8252cebc1","hash":"bcdaad93aaae420cb54fef585356925169500ac5","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/ce/3fb1ffa476ddc4544e962860ab0c708adc2385","hash":"a21528ea94b7e4622b153a174e90735eef19a14a","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/d2/24f73929e1522f5378f6b271731bd4f0a7ef72","hash":"8c7cad9fb186e5d9f78371f697f5ca6fe85c1561","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/d2/1a90d911fb7ebe429e94fbdeae364556d07a49","hash":"d451f1a0b5d678ba3e7ca361b620a77f895cc1f6","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/d6/1a9c04e0bf0ed3be1ca1f2db53f3f824dd65af","hash":"d8cf67aea9de3e2acaa5b15d1e4bd158a718468d","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/d3/85317245e93a1f3ef1f2c7638a377c37ace0d1","hash":"9737a8d568828b473fcc2501a471e5b6757fc309","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/d3/119633b1ef55e1354e50603f1de82b6cdc6fef","hash":"f048c82fe5776bd6adb8342ff8f9bfbaaca44624","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/d8/1ebd139d54428f69b85ba598e34299aa715f11","hash":"3448f04fcaaa0cf160390ac68f264bb653116d3f","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/e7/cf199fb267d5047fd08e858f5b3bb65c13e8d3","hash":"00667017056877bdaa2a088e8290c7a1a4ebe4d4","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/d8/d5f931293cd0919db58b51f5dcd378bc99bdbe","hash":"3630c6105dba0aa7fe4fcd1ccb75bf937527668a","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/d8/3cb36dd6172840ce8ca3549f9f58db76818827","hash":"b5ef87cce326136a6488b3e64fdb3f40501ae6ca","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/objects/dc/395a169028dd46eebc2bdfa5c5ed74f0d9cd74","hash":"fbed7b08811b70dd88925e54ee3317dae4b15672","modified":1508203786000},{"_id":"themes/hexo-theme-xups/.git/refs/heads/master","hash":"2cb0532b3f83fb9763df827bc2972c05c55cc18b","modified":1506220396000},{"_id":"themes/hexo-theme-xups/.git/objects/pack/pack-12f44147bfecd427e87dadcdb2a2896bc6dad952.idx","hash":"a59a6c82e13c41dcc082e09b3c306d7823921602","modified":1506220400000},{"_id":"themes/hexo-theme-xups/.git/objects/f5/80eaa7f0e5ee9bb6f8d2ee4cfb6ae62dc7f8b5","hash":"964d4e1abba7f890fbb53af1ae1781fb07a808af","modified":1508203786000},{"_id":"themes/hexo-theme-xups/layout/_partial/post/category.ejs","hash":"2908913f083b0d95a5cd09a7996cacfe722a3118","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_partial/post/date.ejs","hash":"848f362936b3f21e067e2a0783efbdbdab338985","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_partial/post/gallery.ejs","hash":"ed531d1970eedabd2a454d51ac92fffcc0697bec","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_partial/post/nav.ejs","hash":"fa8cb2d5c593fa402e19e1089007812219596481","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_partial/post/comment.ejs","hash":"f2959e469729372f000fa7b561aae3badcac98b0","modified":1524549431000},{"_id":"themes/hexo-theme-xups/layout/_partial/post/tag.ejs","hash":"38a0810b82e69ddd105211e7ff4ee9f2fb832ce9","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_partial/post/title.ejs","hash":"4819520155fc4e389b09c80310af5c61fcd57c03","modified":1506220396000},{"_id":"themes/hexo-theme-xups/layout/_partial/post/share.ejs","hash":"877d6e2553be13be480ffd424415b50c471b8bc1","modified":1524549437000},{"_id":"themes/hexo-theme-xups/source/css/_base/global.styl","hash":"5ba865047a3438ab6c2347e7403c67a9f2085619","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_base/font.styl","hash":"52895afc3fd1e250d3359d9250f9f6a33e0c797a","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_base/normalize.styl","hash":"01e07a74da4031f9df347407f0061713e28c4c24","modified":1524467124000},{"_id":"themes/hexo-theme-xups/source/css/_base/reset.styl","hash":"ee2a445efc1fbfad1fcdf3cd141e81323171bd25","modified":1550932095000},{"_id":"themes/hexo-theme-xups/source/css/_partial/.DS_Store","hash":"16121b987e7a7a6c89f78f512e6e63eea583e25a","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_partial/article.styl","hash":"127dd055a12c250b13add12cd0615b707fe21fab","modified":1550925776000},{"_id":"themes/hexo-theme-xups/source/css/_partial/footer.styl","hash":"e4891d0642ab0816f29b8d42e014b9818def2a62","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_partial/comment.styl","hash":"120c5b9f0fcbc8a85cbc7baf24ddecce54bcb93c","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_partial/header.styl","hash":"796da02640d3501e269a828e634dcbc89ef41a11","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_partial/highlight.styl","hash":"c1c9655afa9739a4987dc196fff5af50688ea445","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_partial/post.styl","hash":"163988e3cb92deab32674175cb25048ca2f96ae6","modified":1513045987000},{"_id":"themes/hexo-theme-xups/source/css/_partial/responsive.styl","hash":"e522f71c84279b2bb041e931b451cde208e913c6","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_partial/searchform.styl","hash":"2a2ae54716da54d90eb1970ddec92a33e6fde6b5","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_partial/sidebar.styl","hash":"0e64e0a73a6befe0be43a9cb9458e7c690fe4883","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/_partial/theme.styl","hash":"e1eb40c93a39f2212b042fcb4481be2e901240af","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/fonts/.DS_Store","hash":"db2379b0a524b084530079a6a32ba976f2892009","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/lab/banner.jpg","hash":"daa0b3c13831b17182c3d587920f035c80816ae3","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/0.jpg","hash":"7285bbd93d25a0810df38b499fa2b9c201dd88f2","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/1.jpg","hash":"d56409526e114f07de70b9f6be036ee8939626bb","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/4.jpg","hash":"4ba83c3c4937b8068bcb9ed7002c186053482b86","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/5.jpg","hash":"b30fe3c75c445789d83b3d0f2f7b8d456802d306","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/6.jpg","hash":"767c9f7b42b7faf9966fcf87afc732045bf87167","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/7.jpg","hash":"74a4ed49b8823f7e93cad8dc53ed2bcc07f33254","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/8.jpg","hash":"ed356882b0a3015e7aec619bf22dd98e76a2dac8","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/9.jpg","hash":"64aa3752db2dd53e3dbbc7a84967afd2cdedd43e","modified":1506220396000},{"_id":"source/img/js/reg.png","hash":"f6eab626fb5f300a408232b197d37311750dbfcd","modified":1527762461000},{"_id":"themes/hexo-theme-xups/.git/objects/4c/b97e685698aa0517086f5e7d74d390154c21c4","hash":"ce1d58bd5de84645b44e84fd09e80273ad3b3d4f","modified":1508679580000},{"_id":"themes/hexo-theme-xups/source/css/fonts/icomoon/icomoon.ttf","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/2.jpg","hash":"edbd90ed95301d390a8aa8243cd4c08a4d862402","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/3.jpg","hash":"7870fb47e46f645332174f356148bbc8163dfe13","modified":1506220396000},{"_id":"themes/hexo-theme-xups/.git/logs/refs/heads/master","hash":"039b4bc62aeed6fcd4c08ec37b6c7d7d573ea5de","modified":1506220396000},{"_id":"themes/hexo-theme-xups/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1506220396000},{"_id":"themes/hexo-theme-xups/.git/refs/remotes/origin/master","hash":"9117f4e585db2a878870697c08d68f24da8d22b1","modified":1508679580000},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/.DS_Store","hash":"94c491df2256ef547252eed029a8bfb2961da5fe","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/italic.otf","hash":"5b50719da49c1ac26793384b1b68055f01dd4e85","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/italic.ttf","hash":"c62e2ba058f3dc49125dc514bcedde065ce64c5f","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/light_italic.ttf","hash":"de9be5ed440fc380f2cbaa1683e94518d3d44e02","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/light.otf","hash":"4afcc511fe6937b8e8d79e649d70dfb4fff6b406","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/light_italic.otf","hash":"29c648cf7caa087f36b1e1e1c479eb63da35af73","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/fonts/icomoon/icomoon.eot","hash":"26de148529b318cb8159c70ef5adbe3667fb3e6d","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/fonts/icomoon/icomoon.svg","hash":"2e3227e11e13917eecb676062ee953b37ea957c0","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/fonts/icomoon/icomoon.woff","hash":"a5a4ffc5ecda60e59beac6b0f096b25b243a2acb","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/regular.otf","hash":"c6e47b88647ac2b729c05d220cc5be19787b7835","modified":1506220396000},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/light.ttf","hash":"2ba5f36f461b540823978956af8c33b57b0b8ab1","modified":1506220396000},{"_id":"themes/hexo-theme-xups/.git/logs/refs/remotes/origin/HEAD","hash":"039b4bc62aeed6fcd4c08ec37b6c7d7d573ea5de","modified":1506220396000},{"_id":"themes/hexo-theme-xups/.git/logs/refs/remotes/origin/master","hash":"bf2a1bcf3883e188f15307fbcf5e8ab1e1b21c5a","modified":1508679580000},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/regular.ttf","hash":"0ab6cf8e5883d5693ba56065e4973cd8b3e896bc","modified":1506220396000},{"_id":"source/img/interview/react-ag-vue.png","hash":"60e0b2284373e1c2eaeeb67a50bebbb8e0a518cb","modified":1551159675000},{"_id":"themes/hexo-theme-xups/.git/objects/pack/pack-12f44147bfecd427e87dadcdb2a2896bc6dad952.pack","hash":"54fb12a32f2fee8e7cefeee8154de16198a79939","modified":1506220400000},{"_id":"public/about/index.html","hash":"1965a947969c89b870976db06d61962908dd1d9d","modified":1551176889988},{"_id":"public/comment/index.html","hash":"56515c8024161a6346235ef158b9ddee0e9ec8a1","modified":1551176889988},{"_id":"public/lab/index.html","hash":"16af829e1a068c3fcf893b8189a32db9fba8ccc8","modified":1551176889988},{"_id":"public/2018/05/31/英语/word/index.html","hash":"704d21fa1367b64e2e13853fc6e6c3854e7dc262","modified":1551176889988},{"_id":"public/2018/04/12/javascript/正则/index.html","hash":"2cc961d39a9f55d1e08fdd1e86216aa79c31c6fb","modified":1551176889988},{"_id":"public/2017/12/29/英语/预习face-to-face/index.html","hash":"e84c3fce4795d512275a3013d488a7e61c14c8be","modified":1551176889989},{"_id":"public/2017/12/26/英语/定语/index.html","hash":"052f61183a9fcdaf575bc924bd28d985504bec0b","modified":1551176889989},{"_id":"public/2017/12/25/英语/语法/index.html","hash":"c033b7e51b2d88896d856e28c999060c8d77503e","modified":1551176889989},{"_id":"public/2017/12/22/英语/音标/index.html","hash":"5e359e2c15bc2d3c14a853ed1bd79a8166d4116c","modified":1551176889989},{"_id":"public/2017/12/21/生活小常识/健康类/index.html","hash":"0d21fe45983a6c0148965d9b5ee0942bafc9dae7","modified":1551176889989},{"_id":"public/2017/12/20/小领悟/名人名言/index.html","hash":"9ff0fb04985dda9a08a6607dfd37f167ccc87476","modified":1551176889989},{"_id":"public/2017/12/20/小领悟/领悟/index.html","hash":"09a64e83ccb63568b3d51eed007b249a8cacdc57","modified":1551176889989},{"_id":"public/2017/10/23/工具/科学上网/index.html","hash":"ed73303918b4705da7dc15483c6406a821765afa","modified":1551176889990},{"_id":"public/2017/10/17/服务器/虚拟主机&VPS&ECS/index.html","hash":"b3d86030df3766e7a095da6293cf8d492ce1d6b1","modified":1551176889990},{"_id":"public/archives/index.html","hash":"579a9e06803507db20d061ab13bf976d8ff67393","modified":1551176889990},{"_id":"public/archives/page/2/index.html","hash":"dbf2b1b02abee153b1f75bf381e9dac5d1050156","modified":1551176889990},{"_id":"public/archives/page/4/index.html","hash":"722fcb9e7cd881514c0e625eb54f78854bee4c00","modified":1551176889990},{"_id":"public/archives/page/5/index.html","hash":"55ff69c961e265b50303ac73df5b03862fd3867a","modified":1551176889990},{"_id":"public/archives/page/6/index.html","hash":"be239f95dfef918516ede9b9eacaa28bce07a32c","modified":1551176889991},{"_id":"public/archives/2017/index.html","hash":"6c77456b6489b90e01e32ab9aea139cd58d3812a","modified":1551176889991},{"_id":"public/archives/2017/page/3/index.html","hash":"d25f7d6df53a686e758a038860a636ac6c44939f","modified":1551176889991},{"_id":"public/archives/2017/page/5/index.html","hash":"7c6c50ebdc9e3fc2fedb576b1c10ea5c343a1074","modified":1551176889991},{"_id":"public/archives/2017/01/index.html","hash":"91918dfacea5cbbff15c4dc5195324ea43f4d267","modified":1551176889991},{"_id":"public/archives/2017/10/index.html","hash":"4406c8abc0005b3479118b513ce9040bb4ab528f","modified":1551176889991},{"_id":"public/archives/2017/10/page/2/index.html","hash":"61758480a0d4837cc94640789e7e3c7abe9fff58","modified":1551176889991},{"_id":"public/archives/2017/11/index.html","hash":"536d6f151b14c444baec01595d3f01b09eb46b8f","modified":1551176889992},{"_id":"public/archives/2017/12/index.html","hash":"727c4ce0c02c8274317da1e4003a18a463616d90","modified":1551176889992},{"_id":"public/archives/2017/12/page/3/index.html","hash":"6ba91726f3bc6e6beedcb67d32ebb840ccde8cfb","modified":1551176889992},{"_id":"public/archives/2018/index.html","hash":"9ce82b99568b26d55d2023d12380b32d290b376a","modified":1551176889992},{"_id":"public/archives/2018/page/2/index.html","hash":"a1c7c33fc678a30fd3888d22b1174a9591548696","modified":1551176889993},{"_id":"public/archives/2018/01/index.html","hash":"e40626e64996a9b30b1a358deda9072d910aa5c5","modified":1551176889993},{"_id":"public/archives/2018/04/index.html","hash":"fb3a7dc22c6f967ee1dde7ffc6078b62a02df3d0","modified":1551176889993},{"_id":"public/archives/2018/05/index.html","hash":"fe9e8f5538ed701e2561f9cdd3a0b703d24430d2","modified":1551176889993},{"_id":"public/archives/2018/08/index.html","hash":"1d78bc690c51cc00651593eb7a7df10945ffb41f","modified":1551176889993},{"_id":"public/archives/2019/index.html","hash":"d52029b3c66cdeecffcb60d73c4200930f9eb5ce","modified":1551176889993},{"_id":"public/archives/2019/02/index.html","hash":"4ac34a251c8a833b87a92c704dbd697dc9a6fbfb","modified":1551176889993},{"_id":"public/categories/前端技术/index.html","hash":"4c9ee637ad56e670dde9f1e982991a72c6652c98","modified":1551176889993},{"_id":"public/categories/前端技术/page/2/index.html","hash":"0a2006bb6034396885052bad913d5362e19eeeb0","modified":1551176889994},{"_id":"public/categories/前端技术/page/4/index.html","hash":"a10705c2b79bf3fc5725aca1e515a68e415fb22c","modified":1551176889994},{"_id":"public/categories/小领悟/index.html","hash":"b40dce737b7a83600c13a9fbd7a7ffb75d82217b","modified":1551176889994},{"_id":"public/categories/收藏/index.html","hash":"c3aed701ef2d57c731678bf313a4adaed32e149f","modified":1551176889994},{"_id":"public/categories/生活小常识/index.html","hash":"3346786acab420fc20adc56449104592b1cf175d","modified":1551176889994},{"_id":"public/categories/英语/index.html","hash":"190d19be556be73c2f94eb73f0fd870e66d2c06c","modified":1551176889994},{"_id":"public/categories/英语/page/2/index.html","hash":"1d2364613a44076b8c79029d81734ca8675bd13e","modified":1551176889994},{"_id":"public/index.html","hash":"0d793cbd15cc8d72c1bbe292c6aab00b5e64e5bf","modified":1551176889994},{"_id":"public/page/2/index.html","hash":"ecb33fb40ff38e230f09fa0424cfa1ce94916702","modified":1551176889994},{"_id":"public/page/4/index.html","hash":"0bbb8ba5d0d846f684e5dbdba20e7f900d799b7a","modified":1551176889994},{"_id":"public/page/5/index.html","hash":"70ac5f2f9aae5e76318eed25a844231a77b28beb","modified":1551176889994},{"_id":"public/page/6/index.html","hash":"4c6087bff4516515732162eff8822cbf5d9fed61","modified":1551176889995},{"_id":"public/tags/语法/index.html","hash":"6fea0ce5b7a4e5c53803dea07d2a2144aea691af","modified":1551176889995},{"_id":"public/tags/css3/index.html","hash":"bafed847d9d01afa356b4cca022dc873ff7579a4","modified":1551176889995},{"_id":"public/tags/js/index.html","hash":"2a1ab4e52fa8e086cca04904d3b6e97418544a9b","modified":1551176889995},{"_id":"public/tags/js/page/2/index.html","hash":"f64f3336b1bc0266887570baba429675436bcd03","modified":1551176889995},{"_id":"public/tags/Git/index.html","hash":"9d562fda8789468a2ee096df32c89ed7cde9be5a","modified":1551176889995},{"_id":"public/tags/领悟/index.html","hash":"5baeb55440e978a5722b6502a7528cf1d9ee47ad","modified":1551176889995},{"_id":"public/tags/VPN/index.html","hash":"f53ab265f0552b9891be4f4abe8b25cbd5e2f697","modified":1551176889995},{"_id":"public/tags/vsCode插件/index.html","hash":"c9721d806f1ac8af016517e11c2928897aee6a0f","modified":1551176889995},{"_id":"public/tags/服务器区别/index.html","hash":"9b361f2f892259275c6c1c90af8457520fd1057d","modified":1551176889995},{"_id":"public/tags/书籍收藏/index.html","hash":"727105bc2a8a4673055eebf9b4884f2345795cb0","modified":1551176889995},{"_id":"public/tags/浏览器/index.html","hash":"e9d1ad7aae648fc7a1434cd6b9cb160599ba21e7","modified":1551176889995},{"_id":"public/tags/健康/index.html","hash":"4085ac85377552535318948117d5b61a5aceda57","modified":1551176889995},{"_id":"public/tags/英语/index.html","hash":"b1ba743020edbe99ba6c2991d97a16d92b023804","modified":1551176889995},{"_id":"public/tags/英语/page/2/index.html","hash":"74bfcf63347e8f3a8d46711b7030b6e056de8509","modified":1551176889995},{"_id":"public/tags/前端框架/index.html","hash":"7fcbe7b4c8886cc995a5f3dd1b8210d9724f985b","modified":1551176889995},{"_id":"public/tags/前端面试/index.html","hash":"6cfc5bae8e565ed40e6d4345edd314f9c603183b","modified":1551176889996},{"_id":"public/2019/02/24/面试/react-vue-angular/index.html","hash":"0d58cf33d7a3d549da409a05a3e831fb2fb95dfa","modified":1551176889996},{"_id":"public/2019/02/22/面试/summary/index.html","hash":"172ec95f351e89e237048fbc1055dea46616c2bb","modified":1551176889996},{"_id":"public/2018/08/23/面试/interview/index.html","hash":"643c7a5462298ad8a06bde7fe337e4b645d30888","modified":1551176889996},{"_id":"public/2018/05/07/javascript/js数组/index.html","hash":"959a2ebea347bd3f54e8e922a1d63946c6324600","modified":1551176889996},{"_id":"public/2018/04/12/面试/网易/index.html","hash":"ff8083c96f835aecee9c9cd7447ff3062f78bd64","modified":1551176889996},{"_id":"public/2018/01/04/英语/4-unit-2/index.html","hash":"4507345e5aa16c3f32d3f46ab34a8ca242df342f","modified":1551176889996},{"_id":"public/2017/12/28/英语/4-unit-1/index.html","hash":"85cf1a49e51670a463258823facc0fb66748363c","modified":1551176889996},{"_id":"public/2017/12/12/收藏/书籍收藏/index.html","hash":"03de6ba40d8f86d74698de137de950e161d9d0f6","modified":1551176889996},{"_id":"public/2017/12/05/javascript/行为型设计模式/index.html","hash":"cfca476213f8d3099b0f2b7bcedcdf7a90aed5c3","modified":1551176889996},{"_id":"public/2017/12/03/工具/vsCode/index.html","hash":"97c797b82b2331f063a3db4eaaa6aea7ba3c8f5f","modified":1551176889996},{"_id":"public/2017/11/27/javascript/结构型设计模式/index.html","hash":"ea353f61edc3de469d7e860cdd5d5965221f375f","modified":1551176889996},{"_id":"public/2017/11/20/javascript/创建型设计模式/index.html","hash":"d413584b1e2a038a9a11d03ae28997aa089fec70","modified":1551176889997},{"_id":"public/2017/11/05/javascript/js继承/index.html","hash":"ad20a85358a75885fac83ad8aa4e137d2b12613d","modified":1551176889997},{"_id":"public/2017/10/24/工具/Git/index.html","hash":"4615bdd85dd47236c0172d9402ec7690335582eb","modified":1551176889997},{"_id":"public/2017/10/19/浏览器/浏览器工作原理/index.html","hash":"eb28d2628dfe808049124dac0dc2caadc865e1d9","modified":1551176889997},{"_id":"public/2017/10/17/css/css3/index.html","hash":"e4cf847b35201f9c95a85b8538df9bfad52005e0","modified":1551176889997},{"_id":"public/2017/10/17/markdown/index.html","hash":"c9afa5a1a2d91015886936abf52d83c54aa2ee14","modified":1551176889997},{"_id":"public/2017/01/10/英语/4-unit-3/index.html","hash":"1bd5a9e2f57f1f5625dcaf6e8c015148730b77a1","modified":1551176889997},{"_id":"public/archives/page/3/index.html","hash":"9fab5dcccb12871826adc9c0315f104d662d90ea","modified":1551176889997},{"_id":"public/archives/2017/page/2/index.html","hash":"8c49dc11cf7aeb2442e9298a4215eeff9d755d15","modified":1551176889997},{"_id":"public/archives/2017/page/4/index.html","hash":"8120b1138969c60c070198acd2c6bc71a23b72a9","modified":1551176889997},{"_id":"public/archives/2017/12/page/2/index.html","hash":"56abe4f6dff69b711f12211c8b35bdeda5f83b4b","modified":1551176889998},{"_id":"public/categories/前端技术/page/3/index.html","hash":"2b675fb0a5f66dd9b1afe997b644045ff32ce0d0","modified":1551176889998},{"_id":"public/page/3/index.html","hash":"8b2b6d689948b685f3a83a6e825b7f9410eeb3e2","modified":1551176889998},{"_id":"public/css/fonts/icomoon/icomoon.ttf","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551176889998},{"_id":"public/img/VPS&ECS.png","hash":"e431db60727e7e12b33d8503d8abe81a75482b62","modified":1551176890001},{"_id":"public/img/broswer2.png","hash":"833735aedd34713060fd5ed98bdbe3f974634c29","modified":1551176890001},{"_id":"public/img/broswer1.png","hash":"df67868a7f4d73223459d6540ae2672fe29affd6","modified":1551176890001},{"_id":"public/img/wxmoney.png","hash":"59f5f4d6c8128a6125f7f3d4e9c34c6cf2550334","modified":1551176890001},{"_id":"public/img/book-collection/1.jpg","hash":"3d23c162c7b27225ce5693ee32f0d829815de432","modified":1551176890001},{"_id":"public/img/book-collection/11.jpg","hash":"d4b7d49e1e4ffa28df1095c739972f4850bf1e2c","modified":1551176890001},{"_id":"public/img/book-collection/10.jpg","hash":"4a2084aca751e325dd8e822180e40fe105620743","modified":1551176890001},{"_id":"public/img/book-collection/12.jpg","hash":"b9abe6d34795572c72b4a1061167ff95249a4067","modified":1551176890002},{"_id":"public/img/book-collection/13.jpg","hash":"f4aedbe699c6af7e1af9b43b064d34b8881f5a76","modified":1551176890002},{"_id":"public/img/book-collection/14.jpg","hash":"f203688115fa537a14c2c6c9f6562027fb396ef6","modified":1551176890002},{"_id":"public/img/book-collection/17.jpg","hash":"a92c309bc6e60b1f9bd5b00d8d07b762a52b9a55","modified":1551176890002},{"_id":"public/img/book-collection/15.jpg","hash":"e35f29b5f34244d22572b8c44909f5e8f26371c0","modified":1551176890002},{"_id":"public/img/book-collection/18.jpg","hash":"1183d77436009879e44a842eaa0fccead0b34c0f","modified":1551176890002},{"_id":"public/img/book-collection/16.jpg","hash":"0245201f5ff7768a664f85191af4b7828c391d35","modified":1551176890002},{"_id":"public/img/book-collection/2.jpg","hash":"9afd3a9edf826d1552bb08e72484afd2b9f338a0","modified":1551176890002},{"_id":"public/img/book-collection/4.jpg","hash":"aa29f26e03df76b52efde90da00e2a3921f3828e","modified":1551176890002},{"_id":"public/img/book-collection/6.jpg","hash":"03085293f5fa40f0a7b218552ea63db0adc82f80","modified":1551176890002},{"_id":"public/img/book-collection/3.jpg","hash":"ef1008a5cf5a3bf5b0c037018421bfd942c44cef","modified":1551176890002},{"_id":"public/img/book-collection/7.jpg","hash":"a164dc93c362fa91a2fda23fb6392fba7b2fe5a0","modified":1551176890002},{"_id":"public/img/book-collection/8.jpg","hash":"accd40ec1f97e6a1fde826c4392e6842f392dcf2","modified":1551176890003},{"_id":"public/img/book-collection/9.jpg","hash":"4b937efaa670d2b7524fe6c13d5f851cb0060d82","modified":1551176890003},{"_id":"public/img/js/array1.png","hash":"57767c14aedbb8c13e0efba37418e18ea41ab639","modified":1551176890003},{"_id":"public/img/default.png","hash":"a0e8360a185c7516bc2dddb25241daee67b42972","modified":1551176890003},{"_id":"public/img/scrolltoparrow.png","hash":"53bd140adb85b23d535d1e488550eda4624a58bd","modified":1551176890003},{"_id":"public/img/share.png","hash":"20a860aeb842a556d067deabb99f6bfc024c97d0","modified":1551176890003},{"_id":"public/img/jelon.jpg","hash":"5a698f21552a8365ef44f7113665bff8121635cb","modified":1551176890003},{"_id":"public/img/tangtang.jpg","hash":"d184ae15dfa844b8bae5c6d426d366f64caa31dd","modified":1551176890003},{"_id":"public/img/loading.gif","hash":"92dcf9179379355f05cf2d1c8cceba930a2a674f","modified":1551176890003},{"_id":"public/img/wechat_jelon.png","hash":"f1e1cab54bfb69e7816b1d5f355100ea8b272ce4","modified":1551176890003},{"_id":"public/img/url.png","hash":"be1f35666ed5bf03aa3f6db121bd03c407b158a7","modified":1551176890003},{"_id":"public/img/wechat_mp.jpg","hash":"d58b7796093ca8cdd4034b2dd28021c147199099","modified":1551176890003},{"_id":"public/img/wechat_pay.png","hash":"3fb3bbd4b1fae4259578dce0ca838e0696283041","modified":1551176890003},{"_id":"public/img/lab/banner.jpg","hash":"daa0b3c13831b17182c3d587920f035c80816ae3","modified":1551176890003},{"_id":"public/img/thumbnail/0.jpg","hash":"7285bbd93d25a0810df38b499fa2b9c201dd88f2","modified":1551176890004},{"_id":"public/img/thumbnail/4.jpg","hash":"4ba83c3c4937b8068bcb9ed7002c186053482b86","modified":1551176890004},{"_id":"public/img/thumbnail/1.jpg","hash":"d56409526e114f07de70b9f6be036ee8939626bb","modified":1551176890004},{"_id":"public/img/thumbnail/5.jpg","hash":"b30fe3c75c445789d83b3d0f2f7b8d456802d306","modified":1551176890004},{"_id":"public/img/thumbnail/6.jpg","hash":"767c9f7b42b7faf9966fcf87afc732045bf87167","modified":1551176890004},{"_id":"public/img/thumbnail/7.jpg","hash":"74a4ed49b8823f7e93cad8dc53ed2bcc07f33254","modified":1551176890004},{"_id":"public/img/thumbnail/8.jpg","hash":"ed356882b0a3015e7aec619bf22dd98e76a2dac8","modified":1551176890004},{"_id":"public/img/thumbnail/9.jpg","hash":"64aa3752db2dd53e3dbbc7a84967afd2cdedd43e","modified":1551176890004},{"_id":"public/css/fonts/homizio-nova/italic.otf","hash":"5b50719da49c1ac26793384b1b68055f01dd4e85","modified":1551176890004},{"_id":"public/css/fonts/homizio-nova/italic.ttf","hash":"c62e2ba058f3dc49125dc514bcedde065ce64c5f","modified":1551176890004},{"_id":"public/css/fonts/homizio-nova/light.otf","hash":"4afcc511fe6937b8e8d79e649d70dfb4fff6b406","modified":1551176890004},{"_id":"public/css/fonts/homizio-nova/light_italic.ttf","hash":"de9be5ed440fc380f2cbaa1683e94518d3d44e02","modified":1551176890004},{"_id":"public/css/fonts/homizio-nova/light_italic.otf","hash":"29c648cf7caa087f36b1e1e1c479eb63da35af73","modified":1551176890004},{"_id":"public/css/fonts/icomoon/icomoon.eot","hash":"26de148529b318cb8159c70ef5adbe3667fb3e6d","modified":1551176890004},{"_id":"public/css/fonts/icomoon/icomoon.svg","hash":"2e3227e11e13917eecb676062ee953b37ea957c0","modified":1551176890005},{"_id":"public/css/fonts/icomoon/icomoon.woff","hash":"a5a4ffc5ecda60e59beac6b0f096b25b243a2acb","modified":1551176890005},{"_id":"public/css/fonts/homizio-nova/regular.otf","hash":"c6e47b88647ac2b729c05d220cc5be19787b7835","modified":1551176890005},{"_id":"public/img/unsigned_avatar.jpg","hash":"8343a845110fca8317440fcf61aae209eec57edf","modified":1551176890435},{"_id":"public/img/book-collection/5.jpg","hash":"81e4bf0dd9bd034b2a419912bd38432e11046e4d","modified":1551176890435},{"_id":"public/img/thumbnail/3.jpg","hash":"7870fb47e46f645332174f356148bbc8163dfe13","modified":1551176890435},{"_id":"public/img/thumbnail/2.jpg","hash":"edbd90ed95301d390a8aa8243cd4c08a4d862402","modified":1551176890435},{"_id":"public/css/fonts/homizio-nova/light.ttf","hash":"2ba5f36f461b540823978956af8c33b57b0b8ab1","modified":1551176890435},{"_id":"public/css/fonts/homizio-nova/regular.ttf","hash":"0ab6cf8e5883d5693ba56065e4973cd8b3e896bc","modified":1551176890435},{"_id":"public/js/main.js","hash":"0696f2d47ebfb3c9ed2d6911d079907007edff60","modified":1551176890440},{"_id":"public/js/html5.js","hash":"4fefd28dcad6c973c44719ce8b3a8b82fe670a59","modified":1551176890440},{"_id":"public/css/style.css","hash":"5bddb4feacc71ee12d918ff1505226a85a204ed7","modified":1551176890440},{"_id":"public/js/comment.js","hash":"855d74f2002281e8b58ff56ce0281d2c4757cedb","modified":1551176890440},{"_id":"public/img/broswer3.png","hash":"b19dccceca4c92755dd05c573027b2cc6f5cfad9","modified":1551176890440},{"_id":"public/img/js/reg.png","hash":"f6eab626fb5f300a408232b197d37311750dbfcd","modified":1551176890440},{"_id":"public/img/interview/react-ag-vue.png","hash":"60e0b2284373e1c2eaeeb67a50bebbb8e0a518cb","modified":1551176890470}],"Category":[{"name":"前端技术","_id":"cjslmo3ct0004uox16l2tzw6e"},{"name":"小领悟","_id":"cjslmo3du0011uox1vvyvtpqr"},{"name":"收藏","_id":"cjslmo3dx0019uox1reqk2sge"},{"name":"生活小常识","_id":"cjslmo3dy001euox1zs78rz7n"},{"name":"英语","_id":"cjslmo3dz001iuox1kufbe4zl"}],"Data":[],"Page":[{"title":"关于","date":"2016-01-31T14:10:28.000Z","pageid":"about","_content":"","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2016-01-31 22:10:28\npageid: about\n---","updated":"2017-10-17T02:08:40.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjslmo3ca0000uox1be8bd6cc","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"留言","date":"2016-02-01T12:29:57.000Z","pageid":"comment","_content":"","source":"comment/index.md","raw":"---\ntitle: 留言\ndate: 2016-02-01 20:29:57\npageid: comment\n---\n","updated":"2017-10-17T02:08:50.000Z","path":"comment/index.html","comments":1,"layout":"page","_id":"cjslmo3ce0002uox1w4qjglwg","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"实验室","date":"2016-02-01T12:29:57.000Z","pageid":"lab","projects":{"hexo_theme_xups":{"title":"hexo-theme-xups 博客主题","time":"2017-07-12T00:00:00.000Z","content":{"1":{"name":"基于 hexo 静态博客系统的 博客主题 xups","link":"https://github.com/heqingha/blog"}}},"React":{"title":"react","time":"2017-10-17T00:00:00.000Z","content":{"1":{"name":"基于 react + redux + webpack 搭建的零基础项目","link":"https://github.com/heqingha/0-react"}}},"Vue":{"title":"vue-cli","time":"2018-10-15T00:00:00.000Z","content":{"1":{"name":"基于 vue + vuex + webpack + element 搭建的后台管理项目","link":"https://github.com/heqingha/vue-cli"}}},"Mini":{"title":"小程序","time":"2018-11-04T00:00:00.000Z","content":{"1":{"name":"基于 原生小程序技术的服务项目","link":"https://github.com/heqingha/Mini-Program"}}}},"_content":"","source":"lab/index.md","raw":"---\ntitle: 实验室\ndate: 2016-02-01 20:29:57\npageid: lab\n\nprojects:\n    hexo_theme_xups:\n        title: hexo-theme-xups 博客主题\n        time: 2017-07-12\n        content:\n            1:\n                name: 基于 hexo 静态博客系统的 博客主题 xups\n                link: https://github.com/heqingha/blog\n    React:\n        title: react\n        time: 2017-10-17\n        content: \n            1:\n                name: 基于 react + redux + webpack 搭建的零基础项目\n                link: https://github.com/heqingha/0-react\n    Vue:\n        title: vue-cli\n        time: 2018-10-15\n        content: \n            1:        \n                name: 基于 vue + vuex + webpack + element 搭建的后台管理项目\n                link: https://github.com/heqingha/vue-cli \n    Mini:\n        title: 小程序\n        time: 2018-11-04\n        content: \n            1:        \n                name: 基于 原生小程序技术的服务项目\n                link: https://github.com/heqingha/Mini-Program\n    \n---\n","updated":"2019-02-26T05:41:15.000Z","path":"lab/index.html","comments":1,"layout":"page","_id":"cjslmo3cf0003uox1296dk86b","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Markdown","date":"2017-10-17T05:49:58.000Z","_content":"\n> Markdown是一种可以使用普通文本编辑器编写的[标记语言](https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/5964436?fr=aladdin, '标记语言')，通过简单的标记语法，它可以使普通文本内容具有一定的格式\n\n<!-- more -->\n\n## 用途\n> Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客 当然还有其他的用途\n\n## 目标\n> 实现「易读易写」成为一种适用于网络的书写语言，Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然\n\n## Markdown 语法的简要规则\n\n## 1.标题\n\n> 标题是每篇文章都需要也是最常用的格式，Markdown支持两种标题语法，Settext和atx形式。\n\n> Settext形式：利用底线形式，用 = （最高级标题） 和 - （第二级标题）作为底线形式标题的标记。\n\n> atx形式：在行首插入 1 到 6 个 #，对应标题 1 到 6 级（从大到小顺序）。\n\n标题Settext形式\n=====================\n标题Settext形式\n---------------------\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n## 2.引用\n\n> 文章中经常引用别人的话，为区别开来可以用引用标记特别注明。Markdown中使用email形式的 ‘>‘（右尖括号号）。可以在引用段落前加一个，也可以在段落每行前面加一个。如果区块引用由几段组成，引用段落之间需要加一个 >区分引用不同段落（这是引用标记和段落标记的组合）\n\n> This is a blockquote.\n>\n> This is the second paragraph in the blockquote.\n>\n> ## This is an H2 in a blockquote\n\n## 3.段落\n\n> 一篇文章由N个段落组成。一个段落由一个或多个连续的行构成，Markdown通过一个以上的空行区别不同的段落。只要看起来像空行，不管是由空格符还是tab组成的，一律视为空行。\n\n> 多个空格会被看成一个空格。一般段落首行没有缩进，如果需要首行缩进的话可用&emsp; (全方大空白)或 &ensp; （半方大空格）\n\n&emsp;&emsp;这是段落1\n\n&ensp;&ensp;这是段落2\n\n## 4.强调\n\n> Markdown使用星号 * 和底线 _ 标记强调区段。在强调部分前加上标记，在强调部分结束后加上标记限制强调范围。注意星号强调标志与强调内容之间不能有空格存在，不然变成无序列表了。\n\n*强调部分变为斜体*   \n\n_强调部分变为斜体_\n\n**加重强调部分变为粗体**  \n\n__加重强调变为粗体__\n\n***特别强调部分变为粗斜体*** \n\n___特别强调部分变为粗斜体___\n\n## 5.列表\n\n> 列表分为无序列表和有序列表两种。 无序列表使用星号、加号、减号三种中任意一种作为无序列表的项目标记。三种符号可混用，但不建议这样做。注意列表标记和列表项目之间必须至少一个空格。\n\n*  无序列表中一项\n* 子项，以一个tab或者4个空格缩进\n* 无序列表中另一项\n+ 无序列表另一项\n- 无序列表另一项\n\n> 有序列表使用数字接一个英文句点作为项目标记。注意数字和句点间不能有空格，句点和项目内容之间至少有一个空格\n\n1. 有序列表一项\n2. 有序列表另一项\n1. 有序列表最后一项\n\n## 6.链接\n\n> Markdown支持两种形式链接语法\n\n> 1.行内插入链接：要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可\n\n[链接文字链接文字](链接地址)\n\n示例: [github](http://www.github.com)\n\nThis is [an example](http://example.com/ \"Title\") inline link.\n\n[This link](http://example.net/) has no title attribute.\n\n> 2.参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记\n\n[链接文字][链接引用标签]\n\n[链接引用标签]: 链接地址 \"http://www.baidu.com\"\n\n锚点  跳到页面的最后\n\nThis is [an example](#jump) reference-style link.\n\n## 7.图片\n\n> 图片引用类似于链接引用。图片可以是网络图片，也可以是本地图片，本地图片建议放在source/images目录中，按年月建立两层目录放置便于归档。本地图片的url类似为/images/year/month/img.png。\n\n```\n![alt MyEmail](/images/myemail.png \"MyEmail\")\n\n```\n\n例子：![alt MyEmail](/images/myemail.png \"MyEmail\")\n\n## 8.代码\n\n> 第一种：简单文字出现一个代码框。使用`<blockquote>`。（`不是单引号而是左上角的ESC下面~中的`）\n\n> 第二种：大片文字需要实现代码框。使用Tab和四个空格。\n\n`let a = 10;`\n\n        let b = 12;\n        let c = 22;\n\n## 9.水平分割线\n\n> 要生成水平分割线，可以在单独一行里输入3个或以上的短横线（减号）、星号或者下划线实现。短横线和星号之间可以输入任意空格。以下每一行都产生一条水平分割线\n\n-------------------\n**     *\n__  _\n__    _\n\n## 10.表格\n\n## 常用语法\n\n| 输出后的效果 | Markdown | 快捷键 |\n| ------------- |:-------------:| -----:|\n| Bold | **text** | Ctrl/⌘ + B |\n| Emphasize | *text* | Ctrl/⌘ + I |\n| Strike-through | ~~text~~ | Ctrl + Alt + U |\n| Link | [title](http://www.baidu.com)| Ctrl/⌘ + K |\n| Inline Code | `code` | Ctrl/⌘ + Shift + K |\n| Image | ![alt](http://) | Ctrl/⌘ + Shift + I |\n| List | * item |Ctrl + L |\n| Blockquote | > quote | Ctrl + Q |\n| H1 | # H1 | Ctrl/⌘ + I |\n| H2 | ## H2 | Ctrl/⌘ + H |\n| H3 | ### H3 | Ctrl/⌘ + H (x2) |\n\n## 11.片段\n\n这是一个普通段落：\n\n\t这是一个代码区块。\n\n<p>这是一个普通段落：</p>\n<pre>\n<code>这是一个代码区块。</code>\n</pre>\n\n```javascript\n  var ihubo = {\n    nickName  : \"草依山\",\n    site : \"http://jser.me\"\n  }\n```\n<span id = \"jump\">跳转到这里：</span>\n\n## 12. 引用中的引用\n\n>引用\n >>引用中的引用\n\n## 感谢链接：\n\n* [Markdown语法](http://www.appinn.com/markdown/)\n* [Markdown-语法手册](http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C)\n\n\n","source":"_posts/markdown.md","raw":"---\ntitle: Markdown\ndate: 2017-10-17 13:49:58\ncategories:\n- 前端技术\ntags: 语法\n---\n\n> Markdown是一种可以使用普通文本编辑器编写的[标记语言](https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/5964436?fr=aladdin, '标记语言')，通过简单的标记语法，它可以使普通文本内容具有一定的格式\n\n<!-- more -->\n\n## 用途\n> Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客 当然还有其他的用途\n\n## 目标\n> 实现「易读易写」成为一种适用于网络的书写语言，Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然\n\n## Markdown 语法的简要规则\n\n## 1.标题\n\n> 标题是每篇文章都需要也是最常用的格式，Markdown支持两种标题语法，Settext和atx形式。\n\n> Settext形式：利用底线形式，用 = （最高级标题） 和 - （第二级标题）作为底线形式标题的标记。\n\n> atx形式：在行首插入 1 到 6 个 #，对应标题 1 到 6 级（从大到小顺序）。\n\n标题Settext形式\n=====================\n标题Settext形式\n---------------------\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n## 2.引用\n\n> 文章中经常引用别人的话，为区别开来可以用引用标记特别注明。Markdown中使用email形式的 ‘>‘（右尖括号号）。可以在引用段落前加一个，也可以在段落每行前面加一个。如果区块引用由几段组成，引用段落之间需要加一个 >区分引用不同段落（这是引用标记和段落标记的组合）\n\n> This is a blockquote.\n>\n> This is the second paragraph in the blockquote.\n>\n> ## This is an H2 in a blockquote\n\n## 3.段落\n\n> 一篇文章由N个段落组成。一个段落由一个或多个连续的行构成，Markdown通过一个以上的空行区别不同的段落。只要看起来像空行，不管是由空格符还是tab组成的，一律视为空行。\n\n> 多个空格会被看成一个空格。一般段落首行没有缩进，如果需要首行缩进的话可用&emsp; (全方大空白)或 &ensp; （半方大空格）\n\n&emsp;&emsp;这是段落1\n\n&ensp;&ensp;这是段落2\n\n## 4.强调\n\n> Markdown使用星号 * 和底线 _ 标记强调区段。在强调部分前加上标记，在强调部分结束后加上标记限制强调范围。注意星号强调标志与强调内容之间不能有空格存在，不然变成无序列表了。\n\n*强调部分变为斜体*   \n\n_强调部分变为斜体_\n\n**加重强调部分变为粗体**  \n\n__加重强调变为粗体__\n\n***特别强调部分变为粗斜体*** \n\n___特别强调部分变为粗斜体___\n\n## 5.列表\n\n> 列表分为无序列表和有序列表两种。 无序列表使用星号、加号、减号三种中任意一种作为无序列表的项目标记。三种符号可混用，但不建议这样做。注意列表标记和列表项目之间必须至少一个空格。\n\n*  无序列表中一项\n* 子项，以一个tab或者4个空格缩进\n* 无序列表中另一项\n+ 无序列表另一项\n- 无序列表另一项\n\n> 有序列表使用数字接一个英文句点作为项目标记。注意数字和句点间不能有空格，句点和项目内容之间至少有一个空格\n\n1. 有序列表一项\n2. 有序列表另一项\n1. 有序列表最后一项\n\n## 6.链接\n\n> Markdown支持两种形式链接语法\n\n> 1.行内插入链接：要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可\n\n[链接文字链接文字](链接地址)\n\n示例: [github](http://www.github.com)\n\nThis is [an example](http://example.com/ \"Title\") inline link.\n\n[This link](http://example.net/) has no title attribute.\n\n> 2.参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记\n\n[链接文字][链接引用标签]\n\n[链接引用标签]: 链接地址 \"http://www.baidu.com\"\n\n锚点  跳到页面的最后\n\nThis is [an example](#jump) reference-style link.\n\n## 7.图片\n\n> 图片引用类似于链接引用。图片可以是网络图片，也可以是本地图片，本地图片建议放在source/images目录中，按年月建立两层目录放置便于归档。本地图片的url类似为/images/year/month/img.png。\n\n```\n![alt MyEmail](/images/myemail.png \"MyEmail\")\n\n```\n\n例子：![alt MyEmail](/images/myemail.png \"MyEmail\")\n\n## 8.代码\n\n> 第一种：简单文字出现一个代码框。使用`<blockquote>`。（`不是单引号而是左上角的ESC下面~中的`）\n\n> 第二种：大片文字需要实现代码框。使用Tab和四个空格。\n\n`let a = 10;`\n\n        let b = 12;\n        let c = 22;\n\n## 9.水平分割线\n\n> 要生成水平分割线，可以在单独一行里输入3个或以上的短横线（减号）、星号或者下划线实现。短横线和星号之间可以输入任意空格。以下每一行都产生一条水平分割线\n\n-------------------\n**     *\n__  _\n__    _\n\n## 10.表格\n\n## 常用语法\n\n| 输出后的效果 | Markdown | 快捷键 |\n| ------------- |:-------------:| -----:|\n| Bold | **text** | Ctrl/⌘ + B |\n| Emphasize | *text* | Ctrl/⌘ + I |\n| Strike-through | ~~text~~ | Ctrl + Alt + U |\n| Link | [title](http://www.baidu.com)| Ctrl/⌘ + K |\n| Inline Code | `code` | Ctrl/⌘ + Shift + K |\n| Image | ![alt](http://) | Ctrl/⌘ + Shift + I |\n| List | * item |Ctrl + L |\n| Blockquote | > quote | Ctrl + Q |\n| H1 | # H1 | Ctrl/⌘ + I |\n| H2 | ## H2 | Ctrl/⌘ + H |\n| H3 | ### H3 | Ctrl/⌘ + H (x2) |\n\n## 11.片段\n\n这是一个普通段落：\n\n\t这是一个代码区块。\n\n<p>这是一个普通段落：</p>\n<pre>\n<code>这是一个代码区块。</code>\n</pre>\n\n```javascript\n  var ihubo = {\n    nickName  : \"草依山\",\n    site : \"http://jser.me\"\n  }\n```\n<span id = \"jump\">跳转到这里：</span>\n\n## 12. 引用中的引用\n\n>引用\n >>引用中的引用\n\n## 感谢链接：\n\n* [Markdown语法](http://www.appinn.com/markdown/)\n* [Markdown-语法手册](http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C)\n\n\n","slug":"markdown","published":1,"updated":"2018-04-12T02:24:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3cb0001uox17mhyupxe","content":"<blockquote>\n<p>Markdown是一种可以使用普通文本编辑器编写的<a href=\"https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/5964436?fr=aladdin,\" title=\"标记语言\" target=\"_blank\" rel=\"noopener\">标记语言</a>，通过简单的标记语法，它可以使普通文本内容具有一定的格式</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h2><blockquote>\n<p>Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客 当然还有其他的用途</p>\n</blockquote>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><blockquote>\n<p>实现「易读易写」成为一种适用于网络的书写语言，Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然</p>\n</blockquote>\n<h2 id=\"Markdown-语法的简要规则\"><a href=\"#Markdown-语法的简要规则\" class=\"headerlink\" title=\"Markdown 语法的简要规则\"></a>Markdown 语法的简要规则</h2><h2 id=\"1-标题\"><a href=\"#1-标题\" class=\"headerlink\" title=\"1.标题\"></a>1.标题</h2><blockquote>\n<p>标题是每篇文章都需要也是最常用的格式，Markdown支持两种标题语法，Settext和atx形式。</p>\n<p>Settext形式：利用底线形式，用 = （最高级标题） 和 - （第二级标题）作为底线形式标题的标记。</p>\n<p>atx形式：在行首插入 1 到 6 个 #，对应标题 1 到 6 级（从大到小顺序）。</p>\n</blockquote>\n<h1 id=\"标题Settext形式\"><a href=\"#标题Settext形式\" class=\"headerlink\" title=\"标题Settext形式\"></a>标题Settext形式</h1><h2 id=\"标题Settext形式-1\"><a href=\"#标题Settext形式-1\" class=\"headerlink\" title=\"标题Settext形式\"></a>标题Settext形式</h2><h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><h6 id=\"六级标题\"><a href=\"#六级标题\" class=\"headerlink\" title=\"六级标题\"></a>六级标题</h6><h2 id=\"2-引用\"><a href=\"#2-引用\" class=\"headerlink\" title=\"2.引用\"></a>2.引用</h2><blockquote>\n<p>文章中经常引用别人的话，为区别开来可以用引用标记特别注明。Markdown中使用email形式的 ‘&gt;‘（右尖括号号）。可以在引用段落前加一个，也可以在段落每行前面加一个。如果区块引用由几段组成，引用段落之间需要加一个 &gt;区分引用不同段落（这是引用标记和段落标记的组合）</p>\n<p>This is a blockquote.</p>\n<p>This is the second paragraph in the blockquote.</p>\n<h2 id=\"This-is-an-H2-in-a-blockquote\"><a href=\"#This-is-an-H2-in-a-blockquote\" class=\"headerlink\" title=\"This is an H2 in a blockquote\"></a>This is an H2 in a blockquote</h2></blockquote>\n<h2 id=\"3-段落\"><a href=\"#3-段落\" class=\"headerlink\" title=\"3.段落\"></a>3.段落</h2><blockquote>\n<p>一篇文章由N个段落组成。一个段落由一个或多个连续的行构成，Markdown通过一个以上的空行区别不同的段落。只要看起来像空行，不管是由空格符还是tab组成的，一律视为空行。</p>\n<p>多个空格会被看成一个空格。一般段落首行没有缩进，如果需要首行缩进的话可用&emsp; (全方大空白)或 &ensp; （半方大空格）</p>\n</blockquote>\n<p>&emsp;&emsp;这是段落1</p>\n<p>&ensp;&ensp;这是段落2</p>\n<h2 id=\"4-强调\"><a href=\"#4-强调\" class=\"headerlink\" title=\"4.强调\"></a>4.强调</h2><blockquote>\n<p>Markdown使用星号 * 和底线 _ 标记强调区段。在强调部分前加上标记，在强调部分结束后加上标记限制强调范围。注意星号强调标志与强调内容之间不能有空格存在，不然变成无序列表了。</p>\n</blockquote>\n<p><em>强调部分变为斜体</em>   </p>\n<p><em>强调部分变为斜体</em></p>\n<p><strong>加重强调部分变为粗体</strong>  </p>\n<p><strong>加重强调变为粗体</strong></p>\n<p><strong><em>特别强调部分变为粗斜体</em></strong> </p>\n<p><strong><em>特别强调部分变为粗斜体</em></strong></p>\n<h2 id=\"5-列表\"><a href=\"#5-列表\" class=\"headerlink\" title=\"5.列表\"></a>5.列表</h2><blockquote>\n<p>列表分为无序列表和有序列表两种。 无序列表使用星号、加号、减号三种中任意一种作为无序列表的项目标记。三种符号可混用，但不建议这样做。注意列表标记和列表项目之间必须至少一个空格。</p>\n</blockquote>\n<ul>\n<li>无序列表中一项</li>\n<li>子项，以一个tab或者4个空格缩进</li>\n<li>无序列表中另一项</li>\n</ul>\n<ul>\n<li>无序列表另一项</li>\n</ul>\n<ul>\n<li>无序列表另一项</li>\n</ul>\n<blockquote>\n<p>有序列表使用数字接一个英文句点作为项目标记。注意数字和句点间不能有空格，句点和项目内容之间至少有一个空格</p>\n</blockquote>\n<ol>\n<li>有序列表一项</li>\n<li>有序列表另一项</li>\n<li>有序列表最后一项</li>\n</ol>\n<h2 id=\"6-链接\"><a href=\"#6-链接\" class=\"headerlink\" title=\"6.链接\"></a>6.链接</h2><blockquote>\n<p>Markdown支持两种形式链接语法</p>\n<p>1.行内插入链接：要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可</p>\n</blockquote>\n<p><a href=\"链接地址\">链接文字链接文字</a></p>\n<p>示例: <a href=\"http://www.github.com\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<p>This is <a href=\"http://example.com/\" title=\"Title\" target=\"_blank\" rel=\"noopener\">an example</a> inline link.</p>\n<p><a href=\"http://example.net/\" target=\"_blank\" rel=\"noopener\">This link</a> has no title attribute.</p>\n<blockquote>\n<p>2.参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记</p>\n</blockquote>\n<p><a href=\"链接地址\" title=\"http://www.baidu.com\">链接文字</a></p>\n<p>锚点  跳到页面的最后</p>\n<p>This is <a href=\"#jump\">an example</a> reference-style link.</p>\n<h2 id=\"7-图片\"><a href=\"#7-图片\" class=\"headerlink\" title=\"7.图片\"></a>7.图片</h2><blockquote>\n<p>图片引用类似于链接引用。图片可以是网络图片，也可以是本地图片，本地图片建议放在source/images目录中，按年月建立两层目录放置便于归档。本地图片的url类似为/images/year/month/img.png。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![alt MyEmail](/images/myemail.png &quot;MyEmail&quot;)</span><br></pre></td></tr></table></figure>\n<p>例子：<img src=\"/images/myemail.png\" alt=\"alt MyEmail\" title=\"MyEmail\"></p>\n<h2 id=\"8-代码\"><a href=\"#8-代码\" class=\"headerlink\" title=\"8.代码\"></a>8.代码</h2><blockquote>\n<p>第一种：简单文字出现一个代码框。使用<code>&lt;blockquote&gt;</code>。（<code>不是单引号而是左上角的ESC下面~中的</code>）</p>\n<p>第二种：大片文字需要实现代码框。使用Tab和四个空格。</p>\n</blockquote>\n<p><code>let a = 10;</code></p>\n<pre><code>let b = 12;\nlet c = 22;\n</code></pre><h2 id=\"9-水平分割线\"><a href=\"#9-水平分割线\" class=\"headerlink\" title=\"9.水平分割线\"></a>9.水平分割线</h2><blockquote>\n<p>要生成水平分割线，可以在单独一行里输入3个或以上的短横线（减号）、星号或者下划线实现。短横线和星号之间可以输入任意空格。以下每一行都产生一条水平分割线</p>\n</blockquote>\n<hr>\n<hr>\n<hr>\n<hr>\n<h2 id=\"10-表格\"><a href=\"#10-表格\" class=\"headerlink\" title=\"10.表格\"></a>10.表格</h2><h2 id=\"常用语法\"><a href=\"#常用语法\" class=\"headerlink\" title=\"常用语法\"></a>常用语法</h2><table>\n<thead>\n<tr>\n<th>输出后的效果</th>\n<th style=\"text-align:center\">Markdown</th>\n<th style=\"text-align:right\">快捷键</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Bold</td>\n<td style=\"text-align:center\"><strong>text</strong></td>\n<td style=\"text-align:right\">Ctrl/⌘ + B</td>\n</tr>\n<tr>\n<td>Emphasize</td>\n<td style=\"text-align:center\"><em>text</em></td>\n<td style=\"text-align:right\">Ctrl/⌘ + I</td>\n</tr>\n<tr>\n<td>Strike-through</td>\n<td style=\"text-align:center\"><del>text</del></td>\n<td style=\"text-align:right\">Ctrl + Alt + U</td>\n</tr>\n<tr>\n<td>Link</td>\n<td style=\"text-align:center\"><a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">title</a></td>\n<td style=\"text-align:right\">Ctrl/⌘ + K</td>\n</tr>\n<tr>\n<td>Inline Code</td>\n<td style=\"text-align:center\"><code>code</code></td>\n<td style=\"text-align:right\">Ctrl/⌘ + Shift + K</td>\n</tr>\n<tr>\n<td>Image</td>\n<td style=\"text-align:center\"><img src=\"http://\" alt=\"alt\"></td>\n<td style=\"text-align:right\">Ctrl/⌘ + Shift + I</td>\n</tr>\n<tr>\n<td>List</td>\n<td style=\"text-align:center\">* item</td>\n<td style=\"text-align:right\">Ctrl + L</td>\n</tr>\n<tr>\n<td>Blockquote</td>\n<td style=\"text-align:center\">&gt; quote</td>\n<td style=\"text-align:right\">Ctrl + Q</td>\n</tr>\n<tr>\n<td>H1</td>\n<td style=\"text-align:center\"># H1</td>\n<td style=\"text-align:right\">Ctrl/⌘ + I</td>\n</tr>\n<tr>\n<td>H2</td>\n<td style=\"text-align:center\">## H2</td>\n<td style=\"text-align:right\">Ctrl/⌘ + H</td>\n</tr>\n<tr>\n<td>H3</td>\n<td style=\"text-align:center\">### H3</td>\n<td style=\"text-align:right\">Ctrl/⌘ + H (x2)</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"11-片段\"><a href=\"#11-片段\" class=\"headerlink\" title=\"11.片段\"></a>11.片段</h2><p>这是一个普通段落：</p>\n<pre><code>这是一个代码区块。\n</code></pre><p></p><p>这是一个普通段落：</p><p></p>\n<pre>\n<code>这是一个代码区块。</code>\n</pre>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ihubo = &#123;</span><br><span class=\"line\">  nickName  : <span class=\"string\">\"草依山\"</span>,</span><br><span class=\"line\">  site : <span class=\"string\">\"http://jser.me\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><span id=\"jump\">跳转到这里：</span></p>\n<h2 id=\"12-引用中的引用\"><a href=\"#12-引用中的引用\" class=\"headerlink\" title=\"12. 引用中的引用\"></a>12. 引用中的引用</h2><blockquote>\n<p>引用</p>\n<blockquote>\n<p>引用中的引用</p>\n</blockquote>\n</blockquote>\n<h2 id=\"感谢链接：\"><a href=\"#感谢链接：\" class=\"headerlink\" title=\"感谢链接：\"></a>感谢链接：</h2><ul>\n<li><a href=\"http://www.appinn.com/markdown/\" target=\"_blank\" rel=\"noopener\">Markdown语法</a></li>\n<li><a href=\"http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C\" target=\"_blank\" rel=\"noopener\">Markdown-语法手册</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Markdown是一种可以使用普通文本编辑器编写的<a href=\"https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/5964436?fr=aladdin,\" title=\"标记语言\" target=\"_blank\" rel=\"noopener\">标记语言</a>，通过简单的标记语法，它可以使普通文本内容具有一定的格式</p>\n</blockquote>","more":"<h2 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h2><blockquote>\n<p>Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客 当然还有其他的用途</p>\n</blockquote>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><blockquote>\n<p>实现「易读易写」成为一种适用于网络的书写语言，Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然</p>\n</blockquote>\n<h2 id=\"Markdown-语法的简要规则\"><a href=\"#Markdown-语法的简要规则\" class=\"headerlink\" title=\"Markdown 语法的简要规则\"></a>Markdown 语法的简要规则</h2><h2 id=\"1-标题\"><a href=\"#1-标题\" class=\"headerlink\" title=\"1.标题\"></a>1.标题</h2><blockquote>\n<p>标题是每篇文章都需要也是最常用的格式，Markdown支持两种标题语法，Settext和atx形式。</p>\n<p>Settext形式：利用底线形式，用 = （最高级标题） 和 - （第二级标题）作为底线形式标题的标记。</p>\n<p>atx形式：在行首插入 1 到 6 个 #，对应标题 1 到 6 级（从大到小顺序）。</p>\n</blockquote>\n<h1 id=\"标题Settext形式\"><a href=\"#标题Settext形式\" class=\"headerlink\" title=\"标题Settext形式\"></a>标题Settext形式</h1><h2 id=\"标题Settext形式-1\"><a href=\"#标题Settext形式-1\" class=\"headerlink\" title=\"标题Settext形式\"></a>标题Settext形式</h2><h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><h6 id=\"六级标题\"><a href=\"#六级标题\" class=\"headerlink\" title=\"六级标题\"></a>六级标题</h6><h2 id=\"2-引用\"><a href=\"#2-引用\" class=\"headerlink\" title=\"2.引用\"></a>2.引用</h2><blockquote>\n<p>文章中经常引用别人的话，为区别开来可以用引用标记特别注明。Markdown中使用email形式的 ‘&gt;‘（右尖括号号）。可以在引用段落前加一个，也可以在段落每行前面加一个。如果区块引用由几段组成，引用段落之间需要加一个 &gt;区分引用不同段落（这是引用标记和段落标记的组合）</p>\n<p>This is a blockquote.</p>\n<p>This is the second paragraph in the blockquote.</p>\n<h2 id=\"This-is-an-H2-in-a-blockquote\"><a href=\"#This-is-an-H2-in-a-blockquote\" class=\"headerlink\" title=\"This is an H2 in a blockquote\"></a>This is an H2 in a blockquote</h2></blockquote>\n<h2 id=\"3-段落\"><a href=\"#3-段落\" class=\"headerlink\" title=\"3.段落\"></a>3.段落</h2><blockquote>\n<p>一篇文章由N个段落组成。一个段落由一个或多个连续的行构成，Markdown通过一个以上的空行区别不同的段落。只要看起来像空行，不管是由空格符还是tab组成的，一律视为空行。</p>\n<p>多个空格会被看成一个空格。一般段落首行没有缩进，如果需要首行缩进的话可用&emsp; (全方大空白)或 &ensp; （半方大空格）</p>\n</blockquote>\n<p>&emsp;&emsp;这是段落1</p>\n<p>&ensp;&ensp;这是段落2</p>\n<h2 id=\"4-强调\"><a href=\"#4-强调\" class=\"headerlink\" title=\"4.强调\"></a>4.强调</h2><blockquote>\n<p>Markdown使用星号 * 和底线 _ 标记强调区段。在强调部分前加上标记，在强调部分结束后加上标记限制强调范围。注意星号强调标志与强调内容之间不能有空格存在，不然变成无序列表了。</p>\n</blockquote>\n<p><em>强调部分变为斜体</em>   </p>\n<p><em>强调部分变为斜体</em></p>\n<p><strong>加重强调部分变为粗体</strong>  </p>\n<p><strong>加重强调变为粗体</strong></p>\n<p><strong><em>特别强调部分变为粗斜体</em></strong> </p>\n<p><strong><em>特别强调部分变为粗斜体</em></strong></p>\n<h2 id=\"5-列表\"><a href=\"#5-列表\" class=\"headerlink\" title=\"5.列表\"></a>5.列表</h2><blockquote>\n<p>列表分为无序列表和有序列表两种。 无序列表使用星号、加号、减号三种中任意一种作为无序列表的项目标记。三种符号可混用，但不建议这样做。注意列表标记和列表项目之间必须至少一个空格。</p>\n</blockquote>\n<ul>\n<li>无序列表中一项</li>\n<li>子项，以一个tab或者4个空格缩进</li>\n<li>无序列表中另一项</li>\n</ul>\n<ul>\n<li>无序列表另一项</li>\n</ul>\n<ul>\n<li>无序列表另一项</li>\n</ul>\n<blockquote>\n<p>有序列表使用数字接一个英文句点作为项目标记。注意数字和句点间不能有空格，句点和项目内容之间至少有一个空格</p>\n</blockquote>\n<ol>\n<li>有序列表一项</li>\n<li>有序列表另一项</li>\n<li>有序列表最后一项</li>\n</ol>\n<h2 id=\"6-链接\"><a href=\"#6-链接\" class=\"headerlink\" title=\"6.链接\"></a>6.链接</h2><blockquote>\n<p>Markdown支持两种形式链接语法</p>\n<p>1.行内插入链接：要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可</p>\n</blockquote>\n<p><a href=\"链接地址\">链接文字链接文字</a></p>\n<p>示例: <a href=\"http://www.github.com\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<p>This is <a href=\"http://example.com/\" title=\"Title\" target=\"_blank\" rel=\"noopener\">an example</a> inline link.</p>\n<p><a href=\"http://example.net/\" target=\"_blank\" rel=\"noopener\">This link</a> has no title attribute.</p>\n<blockquote>\n<p>2.参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记</p>\n</blockquote>\n<p><a href=\"链接地址\" title=\"http://www.baidu.com\">链接文字</a></p>\n<p>锚点  跳到页面的最后</p>\n<p>This is <a href=\"#jump\">an example</a> reference-style link.</p>\n<h2 id=\"7-图片\"><a href=\"#7-图片\" class=\"headerlink\" title=\"7.图片\"></a>7.图片</h2><blockquote>\n<p>图片引用类似于链接引用。图片可以是网络图片，也可以是本地图片，本地图片建议放在source/images目录中，按年月建立两层目录放置便于归档。本地图片的url类似为/images/year/month/img.png。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![alt MyEmail](/images/myemail.png &quot;MyEmail&quot;)</span><br></pre></td></tr></table></figure>\n<p>例子：<img src=\"/images/myemail.png\" alt=\"alt MyEmail\" title=\"MyEmail\"></p>\n<h2 id=\"8-代码\"><a href=\"#8-代码\" class=\"headerlink\" title=\"8.代码\"></a>8.代码</h2><blockquote>\n<p>第一种：简单文字出现一个代码框。使用<code>&lt;blockquote&gt;</code>。（<code>不是单引号而是左上角的ESC下面~中的</code>）</p>\n<p>第二种：大片文字需要实现代码框。使用Tab和四个空格。</p>\n</blockquote>\n<p><code>let a = 10;</code></p>\n<pre><code>let b = 12;\nlet c = 22;\n</code></pre><h2 id=\"9-水平分割线\"><a href=\"#9-水平分割线\" class=\"headerlink\" title=\"9.水平分割线\"></a>9.水平分割线</h2><blockquote>\n<p>要生成水平分割线，可以在单独一行里输入3个或以上的短横线（减号）、星号或者下划线实现。短横线和星号之间可以输入任意空格。以下每一行都产生一条水平分割线</p>\n</blockquote>\n<hr>\n<hr>\n<hr>\n<hr>\n<h2 id=\"10-表格\"><a href=\"#10-表格\" class=\"headerlink\" title=\"10.表格\"></a>10.表格</h2><h2 id=\"常用语法\"><a href=\"#常用语法\" class=\"headerlink\" title=\"常用语法\"></a>常用语法</h2><table>\n<thead>\n<tr>\n<th>输出后的效果</th>\n<th style=\"text-align:center\">Markdown</th>\n<th style=\"text-align:right\">快捷键</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Bold</td>\n<td style=\"text-align:center\"><strong>text</strong></td>\n<td style=\"text-align:right\">Ctrl/⌘ + B</td>\n</tr>\n<tr>\n<td>Emphasize</td>\n<td style=\"text-align:center\"><em>text</em></td>\n<td style=\"text-align:right\">Ctrl/⌘ + I</td>\n</tr>\n<tr>\n<td>Strike-through</td>\n<td style=\"text-align:center\"><del>text</del></td>\n<td style=\"text-align:right\">Ctrl + Alt + U</td>\n</tr>\n<tr>\n<td>Link</td>\n<td style=\"text-align:center\"><a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">title</a></td>\n<td style=\"text-align:right\">Ctrl/⌘ + K</td>\n</tr>\n<tr>\n<td>Inline Code</td>\n<td style=\"text-align:center\"><code>code</code></td>\n<td style=\"text-align:right\">Ctrl/⌘ + Shift + K</td>\n</tr>\n<tr>\n<td>Image</td>\n<td style=\"text-align:center\"><img src=\"http://\" alt=\"alt\"></td>\n<td style=\"text-align:right\">Ctrl/⌘ + Shift + I</td>\n</tr>\n<tr>\n<td>List</td>\n<td style=\"text-align:center\">* item</td>\n<td style=\"text-align:right\">Ctrl + L</td>\n</tr>\n<tr>\n<td>Blockquote</td>\n<td style=\"text-align:center\">&gt; quote</td>\n<td style=\"text-align:right\">Ctrl + Q</td>\n</tr>\n<tr>\n<td>H1</td>\n<td style=\"text-align:center\"># H1</td>\n<td style=\"text-align:right\">Ctrl/⌘ + I</td>\n</tr>\n<tr>\n<td>H2</td>\n<td style=\"text-align:center\">## H2</td>\n<td style=\"text-align:right\">Ctrl/⌘ + H</td>\n</tr>\n<tr>\n<td>H3</td>\n<td style=\"text-align:center\">### H3</td>\n<td style=\"text-align:right\">Ctrl/⌘ + H (x2)</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"11-片段\"><a href=\"#11-片段\" class=\"headerlink\" title=\"11.片段\"></a>11.片段</h2><p>这是一个普通段落：</p>\n<pre><code>这是一个代码区块。\n</code></pre><p></p><p>这是一个普通段落：</p><p></p>\n<pre>\n<code>这是一个代码区块。</code>\n</pre>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ihubo = &#123;</span><br><span class=\"line\">  nickName  : <span class=\"string\">\"草依山\"</span>,</span><br><span class=\"line\">  site : <span class=\"string\">\"http://jser.me\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><span id=\"jump\">跳转到这里：</span></p>\n<h2 id=\"12-引用中的引用\"><a href=\"#12-引用中的引用\" class=\"headerlink\" title=\"12. 引用中的引用\"></a>12. 引用中的引用</h2><blockquote>\n<p>引用</p>\n<blockquote>\n<p>引用中的引用</p>\n</blockquote>\n</blockquote>\n<h2 id=\"感谢链接：\"><a href=\"#感谢链接：\" class=\"headerlink\" title=\"感谢链接：\"></a>感谢链接：</h2><ul>\n<li><a href=\"http://www.appinn.com/markdown/\" target=\"_blank\" rel=\"noopener\">Markdown语法</a></li>\n<li><a href=\"http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C\" target=\"_blank\" rel=\"noopener\">Markdown-语法手册</a></li>\n</ul>"},{"title":"css3","date":"2017-10-17T06:37:12.000Z","_content":"\n## <span id='0'>[calc()使用](http://www.w3cplus.com/css3/how-to-use-css3-calc-function.html)</span>\n\n> 能实现自适应的布局 box-sizing, 浏览器对calc()的兼容性还算不错，在IE9+、FF4.0+、Chrome19+、Safari6+都得到较好支持著作权归作者所有。不过calc()最大的好处就是用在流体布局上(百分比)，可以通过calc()计算得到元素的宽度高度\n\n<!-- more -->\n\n```css\n    #div{\n        float: left;\n        width: 50%;\n        width:calc(50% - 2px - 80px);\n        height: 100px;\n        background: red;\n        border: thin solid;\n        padding: 40px;\n        //box-sizing: border-box;\n    }\n```\n\n* [calc()使用](#0)\n* [边框](#1)\n* [背景](#2)\n* [渐变](#3)\n* [文本效果](#4)\n* [2D转换](#5)\n* [3D转换](#6)\n* [过渡](#7)\n* [动画](#8)\n* [多列](#9)\n* [用户界面](#10)\n* [弹性盒](#11)\n\n## <span id='1'>边框</span>\n\n> 用 CSS3，你可以创建圆角边框，添加阴影框，并作为边界的形象而不使用设计程序\n\n* border-radius (圆角)\n```css\n    <div id='div'></div>\n    #div\n    {\n        width: 200px;\n        height: 200px;\n        border:2px solid;\n        border-radius:25px;\n    }\n```\n* box-shadow  (盒阴影)\n```css\n    #div\n        {\n            width: 200px;\n            height: 200px;\n            box-shadow: 20px 20px 20px 0 gold inset;\n            box-shadow: 10px 10px 5px #888888;\n            background: red;\n            margin: 50px;\n            // box-shadow: 10px(向右偏移,可取负数,必填) \n                           10px(向下偏移,可取负数,必填) \n                           20px(模糊距离,可选)\n                           5px(阴影尺寸 可选)                                      \n                           #888888(颜色,可选 默认黑色)\n                           inset(内阴影,可选);\n        }\n```\n* [border-image](http://www.runoob.com/cssref/css3-pr-border-image.html)  (边界图片) ...Internet Explorer 不支持\n\n        border-image:   source(图片路径) \n                        slice(图像边界向内偏移) \n                        width(图像边界的宽度) \n                        outset(用于指定在边框外部绘制 border-image-area 的量) \n                        repeat|initial|inherit(用于设置图像边界是否应重复（repeat）、拉伸（stretch）或铺满（round）);\n    默认border-image: none 100% 1 0 stretch\n\n## <span id='2'>背景</span>\n\n* background-size: 100% 100%(200px 200px)注:(写成px的时候不包含padding 加box-sizing: border-box 一样)   (规定背景的绘制区域)\n\n```css\n    #div {\n        width: 200px;\n        height: 200px;\n        padding: 20px;\n        background: #ccc url('http://pic10.nipic.com/20101014/5888301_112136782000_2.jpg') no-repeat;\n        background-size: 100% 100%;\n        box-sizing: border-box;\n        /* background-size: 240px 240px; *\n    }\n\n```\n* background-origin  (content-box(只填充内容区域)、padding-box(包含padding) 或 border-box(包含边框) ) =>  相对于背景图片(背景色完全没有作用  规定背景图片的定位区域)\n\n```css\n    #div {\n        width: 200px;\n        height: 200px;\n        padding: 20px;\n        border: 10px dotted red;\n        background: #ccc url('http://pic10.nipic.com/20101014/5888301_112136782000_2.jpg') no-repeat;\n        background-size: 100% 100%;\n        background-origin: content-box;\n        //background-origin: padding-box;\n        //background-origin: border-box;\n    }\n\n```\n* background-clip (content-box(只填充内容区域)、padding-box(包含padding) 或 border-box(包含边框) )=>相对于背景色(对图片的padding content 有作用  对border-box无用(默认就是))  (规定背景图片的尺寸)\n\n```css\n    #div {\n        width: 200px;\n        height: 200px;\n        padding: 20px;\n        background:  url('http://pic10.nipic.com/20101014/5888301_112136782000_2.jpg') no-repeat;\n        background-size: 100% 100%;\n        background-color: green;\n        background-clip: border-box;\n        /* background-origin: border-box; */\n        border: 10px dashed red;\n    }\n```\n* background-origin与background-clip区别\n\n1. background-origin只作用于背景图片,对背景色无用, background-clip即可作用于背景图片,也可作用于背景色\n2. 当两者都作用于背景图片时, 不同于border-box 属性,background-origin边框在图片上面, 并且填充了边框,  background-clip 没有填充边框\n\n## <span id='3'>渐变 (线性渐变) (径向渐变)</span>\n\n> 在两个或多个指定的颜色之间显示平稳的过渡,如果你想要在渐变的方向上做更多的控制，你可以定义一个角度(逆时针)，而不用预定义方向（to bottom、to top、to right、to left、to bottom right，等等）\n\n* 线性渐变 background: linear-gradient(direction(90deg), color-stop1, color-stop2, ...);\n\n```css\n    #div \n        {\n        width: 200px;\n        height: 200px;\n        background: -webkit-linear-gradient(top, red, blue, green);\n        //background: -webkit-linear-gradient(left, red, blue, green);\n        //background: -webkit-linear-gradient(top left, red, blue, green);\n        //background: -webkit-linear-gradient(left bottom, red, blue, green);\n        //background: -webkit-repeating-linear-gradient(top left, red, blue 10%,green 30%);//重复渐变\n    }\n```\n\n* 径向渐变 background: radial-gradient(center, shape(ellipse/circle) size, start-color, ..., last-color);\n\n```css\n    #div\n        {\n            width: 200px;\n            height: 200px;\n            background: -webkit-radial-gradient(red, green, blue);\n            //background: -webkit-radial-gradient(red 5%, green 15%, blue 60%);\n            //background: -webkit-repeating-radial-gradient(red, green 10%, blue 15%);//重复渐变\n        }\n```\n## <span id='4'>文本效果</span>\n\n* text-shadow: 5px(水平阴影)   5px(垂直阴影)   10px(模糊距离)   green;\n```css\n    #div\n        {\n            width: 200px;\n            height: 200px;\n            text-shadow: 5px 5px 5px #FF0000;\n            font-size: 40px;\n        }\n```\n* word-wrap:break-word(自动换行)   文字超出会自动换行    字母 数字 标点符号不换  (ps不兼容 Opera)\n\n```css\n #div\n    {\n        width: 200px;\n        height: 200px;\n        text-shadow: 5px 5px 5px #FF0000;\n        font-size: 40px;\n        border: 2px solid red;\n        word-wrap:break-word;\n    }\n```\n## <span id='5'>2D转换</span>\n\n > 可以移动，比例化，反过来，旋转，和拉伸元素。\n transform  (IE10 ff  Opera 支持. IE9(-ms-)和Chrome Safari(-webkit-) 要加前缀)\n\n* transform: translate(50px, 50px) (translateX/Y)    (上下 作用偏移,以元素中心点为中心偏移,设置transform-origin属性无用)\n* transform: rotate(90deg) rotate(X/Y)               (旋转,以中心为原点旋转,可改变中心点)\n* transform: scale(2,2) (scaleX/Y)                   (元素尺寸增加或减少倍数,中心点旋转,可改变中心点)\n* transform: skew(10deg,0deg) (skewX/Y)              (元素翻转 x y,中心点旋转,可改变中心点)\n* transform:matrix(0.866,0.5,-0.5,0.866,0,0)         (matrix()方法,六个参数，包含旋转，缩放，移动（平移）和倾斜功能)\n* transform-origin:0 0;                              (允许改变被转换元素的位置,默认元素中心点)\n\n```css\n    #div\n    {\n        width: 200px;\n        height: 200px;\n        background: red;\n        //transform:translate(200px,200px);\n        //transform: rotate(30deg);\n        //transform-origin:0 0;\n        //transform: skew(30deg,20deg);\n        transform: scale(2,2)\n        //transform:matrix(0.866,0.5,-0.5,0.866,0,0);\n        margin: 100px auto;\n        transform-origin:0 0;\n        //animation:myfirst 5s linear 2s infinite alternate;\n    }\n    @keyframes myfirst\n        {\n        from {transform: scale(1,1)}\n        to {transform: scale(2,2)}\n        }\n```\n## <span id='6'>3D转换</span>\n\n> 方法 同2D 只是多了Z轴  rotate可以规定X Y Z (transform: rotateX/Y/Z(30deg))\n\n* transform: translate3d(x,y,z)\n* transform: scale3d(x,y,z)\n* transform: rotate3d(x,y,z,angle)\n* perspective: 500 (设置从何处查看一个元素的角度,perspective 属性只影响 3D 转换元素)\n* perspective-origin: 10% 10% (设置一个3D元素的基数位置)\n* transform-style: preserve-3d (让转换的子元素保留3D转换)\n\n## <span id='7'>过渡</span>\n\n> 为了添加某种效果可以从一种样式转变到另一个的时候，无需使用Flash动画或JavaScript\n\n* transition 属性是一个简写属性，用于设置四个过渡属性  (默认all 0 ease 0) (给运动元素加此属性,hover时加要变的属性)\n* transition-property (哪个属性变)\n* transition-duration (完成这个效果的时间  必须设置 否则默认为0)\n* transition-timing-function ([规定速度效果的速度曲线](http://www.runoob.com/cssref/css3-pr-transition-timing-function.html)   linear|ease|ease-in|ease-out|ease-in-out)\n* transition-delay (效果延时多少开始)\n\n```css\n    #div\n        {\n            width:100px;\n            height:100px;\n            background:red;\n            transition:width 2s;\n        }\n\n    #div:hover\n        {\n            width:300px;\n        }\n```\n## <span id='8'>动画</span>\n\n* @keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果\n* 先定义动画,然后在动画元素属性里面调用,(animation: 动画名  运动的时间 [速度曲线](http://www.runoob.com/cssref/css3-pr-animation-timing-function.html) 延时多少开始 运动次数(infinite 无数次)  反向播放动画 )\n* animation:myfirst 5s linear 2s infinite alternate;\n* animation-play-state:running/paused (属性规定动画正在运行还是暂停 js中使用 可以控制动画暂停与播放)\n\n```css\n    #div \n        {\n            width: 100px;\n            height: 100px;\n            position:relative;\n            animation:myfirst 5s linear 2s infinite alternate;\n            //animation-play-state:paused;\n        }\n    @keyframes myfirst\n        {\n            0%   {background:red; left:0px; top:0px;}\n            25%  {background:yellow; left:200px; top:0px;}\n            50%  {background:blue; left:200px; top:200px;}\n            75%  {background:green; left:0px; top:200px;}\n            100% {background:red; left:0px; top:0px;}\n        } \n```\n\n## <span id='9'>多列</span>\n\n> 可以将文本内容设计成像报纸一样的多列布局\n\n* column-count 属性规定元素应该被分隔的列数  (column-count:3)\n* column-gap 属性规定列之间的间隔 (column-gap:30px)\n* column-rule 属性设置列之间的宽度、样式和颜色规则  (column-rule:4px outset #ff0000)\n* column-width 属性规定列的宽度  (column-width: auto(浏览器决定 没有效果) / 100px)\n* column-span 属性规定元素应横跨多少列  (column-span: 1 / all)\n* columns 属性是一个简写属性，用于设置列宽和列数   (columns:100px(4) 3(1);)\n\n```css\n    <div id=\"div\">\n        <h2>英国维斯米斯特教堂碑文</h2>\n        当我年轻的时候，我梦想改变这个世界；当我成熟以后，我发现我不能够改变这个世界，我将目光缩短了些，决定只改变我的国家；当我进入暮年以后，我发现我不能够改变我们的国家，我的最后愿望仅仅是改变一下我的家庭，但是，这也不可能。当我现在躺在床上，行将就木时，我突然意识到：如果一开始我仅仅去改变我自己，然后，我可能改变我的家庭；在家人的帮助和鼓励下，我可能为国家做一些事情；然后，谁知道呢?我甚至可能改变这个世界。\n    </div>\n    #div \n        {\n            column-count: 3;\n            column-gap:90px;\n            column-rule:4px outset #ff0000;\n            //column-rule:4px dotted #ff0000;\n            column-span: all;\n            column-width:100px;\n            //column-span: 1; // 默认\n            //columns:100px 3;\n        }\n        h2\n        {\n            column-span:1;\n            -webkit-column-span:1; /* Safari and Chrome */\n        }\n```\n\n## <span id=\"10\">用户界面</span> \n\n* 调整尺寸(Resizing)\n\n```css\n    <div id='div'>调整属性指定一个元素是否由用户可调整大小的</div>\n    #div\n        {\n            border:2px solid;\n            padding:10px 40px; \n            width:300px;\n            resize:both;\n            overflow:auto;\n        }\n```\n* 外形修饰（outline-offset ）\n\n```css\n    <div id='div'>\n        这个 div有一个轮廓边界15 px边境外的边缘。Internet Explorer 不兼容 outline-offset属性.\n    </div>\n    #div\n        {\n            margin:20px;\n            width:150px; \n            padding:10px;\n            height:70px;\n            border:2px solid black;\n            outline:2px solid red;\n            outline-offset:15px;\n        }\n```\n\n##  <span id=\"11\">弹性盒</span> \n\n> 弹性盒子是 CSS3 的一种新的布局模式。CSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间\n\n* 弹性盒子 = 弹性容器(Flex container) + 弹性子元素(Flex item)\n* 弹性容器设置 display 属性的值为 flex 或 inline-flex将其定义为弹性容器(弹性容器上)\n* direction: rtl (right-to-left) 修改弹性子元素的排列方式也会改变，页面布局也跟着改变 (弹性容器上)\n* flex-direction 顺序指定了弹性子元素在父容器中的位置 (flex-direction: row | row-reverse | column | column-reverse)(弹性容器上)\n    * row：横向从左到右排列（左对齐），默认\n    * row-reverse：反转横向排列（右对齐，从后往前排，最后一项排在最前面\n    * column：纵向排列\n    * column-reverse：反转纵向排列，从后往前排，最后一项排在最上面\n* justify-content(内容对齐): flex-start | flex-end | center | space-between | space-around (弹性容器上)\n* align-items(设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式): flex-start | flex-end | center | baseline | stretch(弹性容器上)\n* flex-wrap(用于指定弹性盒子的子元素换行方式): nowrap|wrap|wrap-reverse|initial|inherit; (弹性容器上)\n    * nowrap - 默认， 弹性容器为单行。该情况下弹性子项可能会溢出容器。\n    * wrap - 弹性容器为多行。该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行\n    * wrap-reverse -反转 wrap 排列\n* align-content(用于修改 flex-wrap 属性的行为): flex-start | flex-end | center | space-between | space-around | stretch, 类似于 align-items, 但它不是设置弹性子元素的对齐，而是设置各个行的对齐 (弹性容器上)\n    * stretch - 默认。各行将会伸展以占用剩余的空间。\n    * flex-start - 各行向弹性盒容器的起始位置堆叠。\n    * flex-end - 各行向弹性盒容器的结束位置堆叠。\n    * center -各行向弹性盒容器的中间位置堆叠。\n    * space-between -各行在弹性盒容器中平均分布。\n    * space-around - 各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。 \n\n### 弹性子元素属性\n\n* order 属性设置弹性容器内弹性子元素的属性\n* align-self (在弹性子元素上使用。覆盖容器的 align-items 属性): auto | flex-start | flex-end | center | baseline | stretch\n* flex (设置弹性盒子的子元素如何分配空间): auto | initial | none | inherit |  [ flex-grow ] || [ flex-shrink ] || [ flex-basis ]\n\n```css\n    <div class=\"flex-container\">\n        <div class=\"flex-item\">flex item 1</div>\n        <div class=\"flex-item\">flex item 2</div>\n        <div class=\"flex-item\">flex item 3</div>\n        <div class=\"flex-item\">flex item 4</div>  \n    </div>\n\n    .flex-container {\n        display: -webkit-flex;\n        display: flex;\n        width: 400px;\n        height: 250px;\n        background-color: lightgrey;\n        //direction: rtl;\n        //flex-direction: row;\n        //flex-direction: row-reverse;\n        //flex-direction: column;\n        //flex-direction: column-reverse;\n        //justify-content: flex-start;\n        //justify-content: flex-end;\n        //justify-content: center;\n        //justify-content: space-between;\n        //justify-content: space-around;\n        //flex-wrap: nowrap;\n        //flex-wrap: wrap;\n        //flex-wrap: wrap-reverse;\n    }\n\n    .flex-item {\n        background-color: cornflowerblue;\n        width: 15%;\n        height: 100px;\n        margin: 10px;\n    }\n```\n","source":"_posts/css/css3.md","raw":"---\ntitle: css3\ndate: 2017-10-17 14:37:12\ntags:\n- css3\ncategories:\n- 前端技术\n---\n\n## <span id='0'>[calc()使用](http://www.w3cplus.com/css3/how-to-use-css3-calc-function.html)</span>\n\n> 能实现自适应的布局 box-sizing, 浏览器对calc()的兼容性还算不错，在IE9+、FF4.0+、Chrome19+、Safari6+都得到较好支持著作权归作者所有。不过calc()最大的好处就是用在流体布局上(百分比)，可以通过calc()计算得到元素的宽度高度\n\n<!-- more -->\n\n```css\n    #div{\n        float: left;\n        width: 50%;\n        width:calc(50% - 2px - 80px);\n        height: 100px;\n        background: red;\n        border: thin solid;\n        padding: 40px;\n        //box-sizing: border-box;\n    }\n```\n\n* [calc()使用](#0)\n* [边框](#1)\n* [背景](#2)\n* [渐变](#3)\n* [文本效果](#4)\n* [2D转换](#5)\n* [3D转换](#6)\n* [过渡](#7)\n* [动画](#8)\n* [多列](#9)\n* [用户界面](#10)\n* [弹性盒](#11)\n\n## <span id='1'>边框</span>\n\n> 用 CSS3，你可以创建圆角边框，添加阴影框，并作为边界的形象而不使用设计程序\n\n* border-radius (圆角)\n```css\n    <div id='div'></div>\n    #div\n    {\n        width: 200px;\n        height: 200px;\n        border:2px solid;\n        border-radius:25px;\n    }\n```\n* box-shadow  (盒阴影)\n```css\n    #div\n        {\n            width: 200px;\n            height: 200px;\n            box-shadow: 20px 20px 20px 0 gold inset;\n            box-shadow: 10px 10px 5px #888888;\n            background: red;\n            margin: 50px;\n            // box-shadow: 10px(向右偏移,可取负数,必填) \n                           10px(向下偏移,可取负数,必填) \n                           20px(模糊距离,可选)\n                           5px(阴影尺寸 可选)                                      \n                           #888888(颜色,可选 默认黑色)\n                           inset(内阴影,可选);\n        }\n```\n* [border-image](http://www.runoob.com/cssref/css3-pr-border-image.html)  (边界图片) ...Internet Explorer 不支持\n\n        border-image:   source(图片路径) \n                        slice(图像边界向内偏移) \n                        width(图像边界的宽度) \n                        outset(用于指定在边框外部绘制 border-image-area 的量) \n                        repeat|initial|inherit(用于设置图像边界是否应重复（repeat）、拉伸（stretch）或铺满（round）);\n    默认border-image: none 100% 1 0 stretch\n\n## <span id='2'>背景</span>\n\n* background-size: 100% 100%(200px 200px)注:(写成px的时候不包含padding 加box-sizing: border-box 一样)   (规定背景的绘制区域)\n\n```css\n    #div {\n        width: 200px;\n        height: 200px;\n        padding: 20px;\n        background: #ccc url('http://pic10.nipic.com/20101014/5888301_112136782000_2.jpg') no-repeat;\n        background-size: 100% 100%;\n        box-sizing: border-box;\n        /* background-size: 240px 240px; *\n    }\n\n```\n* background-origin  (content-box(只填充内容区域)、padding-box(包含padding) 或 border-box(包含边框) ) =>  相对于背景图片(背景色完全没有作用  规定背景图片的定位区域)\n\n```css\n    #div {\n        width: 200px;\n        height: 200px;\n        padding: 20px;\n        border: 10px dotted red;\n        background: #ccc url('http://pic10.nipic.com/20101014/5888301_112136782000_2.jpg') no-repeat;\n        background-size: 100% 100%;\n        background-origin: content-box;\n        //background-origin: padding-box;\n        //background-origin: border-box;\n    }\n\n```\n* background-clip (content-box(只填充内容区域)、padding-box(包含padding) 或 border-box(包含边框) )=>相对于背景色(对图片的padding content 有作用  对border-box无用(默认就是))  (规定背景图片的尺寸)\n\n```css\n    #div {\n        width: 200px;\n        height: 200px;\n        padding: 20px;\n        background:  url('http://pic10.nipic.com/20101014/5888301_112136782000_2.jpg') no-repeat;\n        background-size: 100% 100%;\n        background-color: green;\n        background-clip: border-box;\n        /* background-origin: border-box; */\n        border: 10px dashed red;\n    }\n```\n* background-origin与background-clip区别\n\n1. background-origin只作用于背景图片,对背景色无用, background-clip即可作用于背景图片,也可作用于背景色\n2. 当两者都作用于背景图片时, 不同于border-box 属性,background-origin边框在图片上面, 并且填充了边框,  background-clip 没有填充边框\n\n## <span id='3'>渐变 (线性渐变) (径向渐变)</span>\n\n> 在两个或多个指定的颜色之间显示平稳的过渡,如果你想要在渐变的方向上做更多的控制，你可以定义一个角度(逆时针)，而不用预定义方向（to bottom、to top、to right、to left、to bottom right，等等）\n\n* 线性渐变 background: linear-gradient(direction(90deg), color-stop1, color-stop2, ...);\n\n```css\n    #div \n        {\n        width: 200px;\n        height: 200px;\n        background: -webkit-linear-gradient(top, red, blue, green);\n        //background: -webkit-linear-gradient(left, red, blue, green);\n        //background: -webkit-linear-gradient(top left, red, blue, green);\n        //background: -webkit-linear-gradient(left bottom, red, blue, green);\n        //background: -webkit-repeating-linear-gradient(top left, red, blue 10%,green 30%);//重复渐变\n    }\n```\n\n* 径向渐变 background: radial-gradient(center, shape(ellipse/circle) size, start-color, ..., last-color);\n\n```css\n    #div\n        {\n            width: 200px;\n            height: 200px;\n            background: -webkit-radial-gradient(red, green, blue);\n            //background: -webkit-radial-gradient(red 5%, green 15%, blue 60%);\n            //background: -webkit-repeating-radial-gradient(red, green 10%, blue 15%);//重复渐变\n        }\n```\n## <span id='4'>文本效果</span>\n\n* text-shadow: 5px(水平阴影)   5px(垂直阴影)   10px(模糊距离)   green;\n```css\n    #div\n        {\n            width: 200px;\n            height: 200px;\n            text-shadow: 5px 5px 5px #FF0000;\n            font-size: 40px;\n        }\n```\n* word-wrap:break-word(自动换行)   文字超出会自动换行    字母 数字 标点符号不换  (ps不兼容 Opera)\n\n```css\n #div\n    {\n        width: 200px;\n        height: 200px;\n        text-shadow: 5px 5px 5px #FF0000;\n        font-size: 40px;\n        border: 2px solid red;\n        word-wrap:break-word;\n    }\n```\n## <span id='5'>2D转换</span>\n\n > 可以移动，比例化，反过来，旋转，和拉伸元素。\n transform  (IE10 ff  Opera 支持. IE9(-ms-)和Chrome Safari(-webkit-) 要加前缀)\n\n* transform: translate(50px, 50px) (translateX/Y)    (上下 作用偏移,以元素中心点为中心偏移,设置transform-origin属性无用)\n* transform: rotate(90deg) rotate(X/Y)               (旋转,以中心为原点旋转,可改变中心点)\n* transform: scale(2,2) (scaleX/Y)                   (元素尺寸增加或减少倍数,中心点旋转,可改变中心点)\n* transform: skew(10deg,0deg) (skewX/Y)              (元素翻转 x y,中心点旋转,可改变中心点)\n* transform:matrix(0.866,0.5,-0.5,0.866,0,0)         (matrix()方法,六个参数，包含旋转，缩放，移动（平移）和倾斜功能)\n* transform-origin:0 0;                              (允许改变被转换元素的位置,默认元素中心点)\n\n```css\n    #div\n    {\n        width: 200px;\n        height: 200px;\n        background: red;\n        //transform:translate(200px,200px);\n        //transform: rotate(30deg);\n        //transform-origin:0 0;\n        //transform: skew(30deg,20deg);\n        transform: scale(2,2)\n        //transform:matrix(0.866,0.5,-0.5,0.866,0,0);\n        margin: 100px auto;\n        transform-origin:0 0;\n        //animation:myfirst 5s linear 2s infinite alternate;\n    }\n    @keyframes myfirst\n        {\n        from {transform: scale(1,1)}\n        to {transform: scale(2,2)}\n        }\n```\n## <span id='6'>3D转换</span>\n\n> 方法 同2D 只是多了Z轴  rotate可以规定X Y Z (transform: rotateX/Y/Z(30deg))\n\n* transform: translate3d(x,y,z)\n* transform: scale3d(x,y,z)\n* transform: rotate3d(x,y,z,angle)\n* perspective: 500 (设置从何处查看一个元素的角度,perspective 属性只影响 3D 转换元素)\n* perspective-origin: 10% 10% (设置一个3D元素的基数位置)\n* transform-style: preserve-3d (让转换的子元素保留3D转换)\n\n## <span id='7'>过渡</span>\n\n> 为了添加某种效果可以从一种样式转变到另一个的时候，无需使用Flash动画或JavaScript\n\n* transition 属性是一个简写属性，用于设置四个过渡属性  (默认all 0 ease 0) (给运动元素加此属性,hover时加要变的属性)\n* transition-property (哪个属性变)\n* transition-duration (完成这个效果的时间  必须设置 否则默认为0)\n* transition-timing-function ([规定速度效果的速度曲线](http://www.runoob.com/cssref/css3-pr-transition-timing-function.html)   linear|ease|ease-in|ease-out|ease-in-out)\n* transition-delay (效果延时多少开始)\n\n```css\n    #div\n        {\n            width:100px;\n            height:100px;\n            background:red;\n            transition:width 2s;\n        }\n\n    #div:hover\n        {\n            width:300px;\n        }\n```\n## <span id='8'>动画</span>\n\n* @keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果\n* 先定义动画,然后在动画元素属性里面调用,(animation: 动画名  运动的时间 [速度曲线](http://www.runoob.com/cssref/css3-pr-animation-timing-function.html) 延时多少开始 运动次数(infinite 无数次)  反向播放动画 )\n* animation:myfirst 5s linear 2s infinite alternate;\n* animation-play-state:running/paused (属性规定动画正在运行还是暂停 js中使用 可以控制动画暂停与播放)\n\n```css\n    #div \n        {\n            width: 100px;\n            height: 100px;\n            position:relative;\n            animation:myfirst 5s linear 2s infinite alternate;\n            //animation-play-state:paused;\n        }\n    @keyframes myfirst\n        {\n            0%   {background:red; left:0px; top:0px;}\n            25%  {background:yellow; left:200px; top:0px;}\n            50%  {background:blue; left:200px; top:200px;}\n            75%  {background:green; left:0px; top:200px;}\n            100% {background:red; left:0px; top:0px;}\n        } \n```\n\n## <span id='9'>多列</span>\n\n> 可以将文本内容设计成像报纸一样的多列布局\n\n* column-count 属性规定元素应该被分隔的列数  (column-count:3)\n* column-gap 属性规定列之间的间隔 (column-gap:30px)\n* column-rule 属性设置列之间的宽度、样式和颜色规则  (column-rule:4px outset #ff0000)\n* column-width 属性规定列的宽度  (column-width: auto(浏览器决定 没有效果) / 100px)\n* column-span 属性规定元素应横跨多少列  (column-span: 1 / all)\n* columns 属性是一个简写属性，用于设置列宽和列数   (columns:100px(4) 3(1);)\n\n```css\n    <div id=\"div\">\n        <h2>英国维斯米斯特教堂碑文</h2>\n        当我年轻的时候，我梦想改变这个世界；当我成熟以后，我发现我不能够改变这个世界，我将目光缩短了些，决定只改变我的国家；当我进入暮年以后，我发现我不能够改变我们的国家，我的最后愿望仅仅是改变一下我的家庭，但是，这也不可能。当我现在躺在床上，行将就木时，我突然意识到：如果一开始我仅仅去改变我自己，然后，我可能改变我的家庭；在家人的帮助和鼓励下，我可能为国家做一些事情；然后，谁知道呢?我甚至可能改变这个世界。\n    </div>\n    #div \n        {\n            column-count: 3;\n            column-gap:90px;\n            column-rule:4px outset #ff0000;\n            //column-rule:4px dotted #ff0000;\n            column-span: all;\n            column-width:100px;\n            //column-span: 1; // 默认\n            //columns:100px 3;\n        }\n        h2\n        {\n            column-span:1;\n            -webkit-column-span:1; /* Safari and Chrome */\n        }\n```\n\n## <span id=\"10\">用户界面</span> \n\n* 调整尺寸(Resizing)\n\n```css\n    <div id='div'>调整属性指定一个元素是否由用户可调整大小的</div>\n    #div\n        {\n            border:2px solid;\n            padding:10px 40px; \n            width:300px;\n            resize:both;\n            overflow:auto;\n        }\n```\n* 外形修饰（outline-offset ）\n\n```css\n    <div id='div'>\n        这个 div有一个轮廓边界15 px边境外的边缘。Internet Explorer 不兼容 outline-offset属性.\n    </div>\n    #div\n        {\n            margin:20px;\n            width:150px; \n            padding:10px;\n            height:70px;\n            border:2px solid black;\n            outline:2px solid red;\n            outline-offset:15px;\n        }\n```\n\n##  <span id=\"11\">弹性盒</span> \n\n> 弹性盒子是 CSS3 的一种新的布局模式。CSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间\n\n* 弹性盒子 = 弹性容器(Flex container) + 弹性子元素(Flex item)\n* 弹性容器设置 display 属性的值为 flex 或 inline-flex将其定义为弹性容器(弹性容器上)\n* direction: rtl (right-to-left) 修改弹性子元素的排列方式也会改变，页面布局也跟着改变 (弹性容器上)\n* flex-direction 顺序指定了弹性子元素在父容器中的位置 (flex-direction: row | row-reverse | column | column-reverse)(弹性容器上)\n    * row：横向从左到右排列（左对齐），默认\n    * row-reverse：反转横向排列（右对齐，从后往前排，最后一项排在最前面\n    * column：纵向排列\n    * column-reverse：反转纵向排列，从后往前排，最后一项排在最上面\n* justify-content(内容对齐): flex-start | flex-end | center | space-between | space-around (弹性容器上)\n* align-items(设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式): flex-start | flex-end | center | baseline | stretch(弹性容器上)\n* flex-wrap(用于指定弹性盒子的子元素换行方式): nowrap|wrap|wrap-reverse|initial|inherit; (弹性容器上)\n    * nowrap - 默认， 弹性容器为单行。该情况下弹性子项可能会溢出容器。\n    * wrap - 弹性容器为多行。该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行\n    * wrap-reverse -反转 wrap 排列\n* align-content(用于修改 flex-wrap 属性的行为): flex-start | flex-end | center | space-between | space-around | stretch, 类似于 align-items, 但它不是设置弹性子元素的对齐，而是设置各个行的对齐 (弹性容器上)\n    * stretch - 默认。各行将会伸展以占用剩余的空间。\n    * flex-start - 各行向弹性盒容器的起始位置堆叠。\n    * flex-end - 各行向弹性盒容器的结束位置堆叠。\n    * center -各行向弹性盒容器的中间位置堆叠。\n    * space-between -各行在弹性盒容器中平均分布。\n    * space-around - 各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。 \n\n### 弹性子元素属性\n\n* order 属性设置弹性容器内弹性子元素的属性\n* align-self (在弹性子元素上使用。覆盖容器的 align-items 属性): auto | flex-start | flex-end | center | baseline | stretch\n* flex (设置弹性盒子的子元素如何分配空间): auto | initial | none | inherit |  [ flex-grow ] || [ flex-shrink ] || [ flex-basis ]\n\n```css\n    <div class=\"flex-container\">\n        <div class=\"flex-item\">flex item 1</div>\n        <div class=\"flex-item\">flex item 2</div>\n        <div class=\"flex-item\">flex item 3</div>\n        <div class=\"flex-item\">flex item 4</div>  \n    </div>\n\n    .flex-container {\n        display: -webkit-flex;\n        display: flex;\n        width: 400px;\n        height: 250px;\n        background-color: lightgrey;\n        //direction: rtl;\n        //flex-direction: row;\n        //flex-direction: row-reverse;\n        //flex-direction: column;\n        //flex-direction: column-reverse;\n        //justify-content: flex-start;\n        //justify-content: flex-end;\n        //justify-content: center;\n        //justify-content: space-between;\n        //justify-content: space-around;\n        //flex-wrap: nowrap;\n        //flex-wrap: wrap;\n        //flex-wrap: wrap-reverse;\n    }\n\n    .flex-item {\n        background-color: cornflowerblue;\n        width: 15%;\n        height: 100px;\n        margin: 10px;\n    }\n```\n","slug":"css/css3","published":1,"updated":"2018-04-12T02:24:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3d30006uox1uxz9nqmn","content":"<h2 id=\"calc-使用\"><a href=\"#calc-使用\" class=\"headerlink\" title=\"calc()使用\"></a><span id=\"0\"><a href=\"http://www.w3cplus.com/css3/how-to-use-css3-calc-function.html\" target=\"_blank\" rel=\"noopener\">calc()使用</a></span></h2><blockquote>\n<p>能实现自适应的布局 box-sizing, 浏览器对calc()的兼容性还算不错，在IE9+、FF4.0+、Chrome19+、Safari6+都得到较好支持著作权归作者所有。不过calc()最大的好处就是用在流体布局上(百分比)，可以通过calc()计算得到元素的宽度高度</p>\n</blockquote>\n<a id=\"more\"></a>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"built_in\">calc</span>(50% - 2px - 80px);</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: thin solid;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">40px</span>;</span><br><span class=\"line\">    //box-sizing: border-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"#0\">calc()使用</a></li>\n<li><a href=\"#1\">边框</a></li>\n<li><a href=\"#2\">背景</a></li>\n<li><a href=\"#3\">渐变</a></li>\n<li><a href=\"#4\">文本效果</a></li>\n<li><a href=\"#5\">2D转换</a></li>\n<li><a href=\"#6\">3D转换</a></li>\n<li><a href=\"#7\">过渡</a></li>\n<li><a href=\"#8\">动画</a></li>\n<li><a href=\"#9\">多列</a></li>\n<li><a href=\"#10\">用户界面</a></li>\n<li><a href=\"#11\">弹性盒</a></li>\n</ul>\n<h2 id=\"边框\"><a href=\"#边框\" class=\"headerlink\" title=\"边框\"></a><span id=\"1\">边框</span></h2><blockquote>\n<p>用 CSS3，你可以创建圆角边框，添加阴影框，并作为边界的形象而不使用设计程序</p>\n</blockquote>\n<ul>\n<li><p>border-radius (圆角)</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id='div'&gt;&lt;/div&gt;</span><br><span class=\"line\"><span class=\"selector-id\">#div</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>:<span class=\"number\">2px</span> solid;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>:<span class=\"number\">25px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>box-shadow  (盒阴影)</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#div</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">box-shadow</span>: <span class=\"number\">20px</span> <span class=\"number\">20px</span> <span class=\"number\">20px</span> <span class=\"number\">0</span> gold inset;</span><br><span class=\"line\">        <span class=\"attribute\">box-shadow</span>: <span class=\"number\">10px</span> <span class=\"number\">10px</span> <span class=\"number\">5px</span> <span class=\"number\">#888888</span>;</span><br><span class=\"line\">        <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">        <span class=\"attribute\">margin</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">        // box-shadow: 10px(向右偏移,可取负数,必填) </span><br><span class=\"line\">                       10<span class=\"selector-tag\">px</span>(向下偏移,可取负数,必填) </span><br><span class=\"line\">                       20<span class=\"selector-tag\">px</span>(模糊距离,可选)</span><br><span class=\"line\">                       5<span class=\"selector-tag\">px</span>(阴影尺寸 可选)                                      </span><br><span class=\"line\">                       <span class=\"selector-id\">#888888</span>(颜色,可选 默认黑色)</span><br><span class=\"line\">                       <span class=\"selector-tag\">inset</span>(内阴影,可选);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"http://www.runoob.com/cssref/css3-pr-border-image.html\" target=\"_blank\" rel=\"noopener\">border-image</a>  (边界图片) …Internet Explorer 不支持</p>\n<pre><code>border-image:   source(图片路径) \n                slice(图像边界向内偏移) \n                width(图像边界的宽度) \n                outset(用于指定在边框外部绘制 border-image-area 的量) \n                repeat|initial|inherit(用于设置图像边界是否应重复（repeat）、拉伸（stretch）或铺满（round）);\n</code></pre><p>  默认border-image: none 100% 1 0 stretch</p>\n</li>\n</ul>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a><span id=\"2\">背景</span></h2><ul>\n<li>background-size: 100% 100%(200px 200px)注:(写成px的时候不包含padding 加box-sizing: border-box 一样)   (规定背景的绘制区域)</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#ccc</span> <span class=\"built_in\">url</span>(<span class=\"string\">'http://pic10.nipic.com/20101014/5888301_112136782000_2.jpg'</span>) no-repeat;</span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: <span class=\"number\">100%</span> <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">    <span class=\"comment\">/* background-size: 240px 240px; *</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>background-origin  (content-box(只填充内容区域)、padding-box(包含padding) 或 border-box(包含边框) ) =&gt;  相对于背景图片(背景色完全没有作用  规定背景图片的定位区域)</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">10px</span> dotted red;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#ccc</span> <span class=\"built_in\">url</span>(<span class=\"string\">'http://pic10.nipic.com/20101014/5888301_112136782000_2.jpg'</span>) no-repeat;</span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: <span class=\"number\">100%</span> <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-origin</span>: content-box;</span><br><span class=\"line\">    //background-origin: padding-box;</span><br><span class=\"line\">    //background-origin: border-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>background-clip (content-box(只填充内容区域)、padding-box(包含padding) 或 border-box(包含边框) )=&gt;相对于背景色(对图片的padding content 有作用  对border-box无用(默认就是))  (规定背景图片的尺寸)</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:  <span class=\"built_in\">url</span>(<span class=\"string\">'http://pic10.nipic.com/20101014/5888301_112136782000_2.jpg'</span>) no-repeat;</span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: <span class=\"number\">100%</span> <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: green;</span><br><span class=\"line\">    <span class=\"attribute\">background-clip</span>: border-box;</span><br><span class=\"line\">    <span class=\"comment\">/* background-origin: border-box; */</span></span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">10px</span> dashed red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>background-origin与background-clip区别</li>\n</ul>\n<ol>\n<li>background-origin只作用于背景图片,对背景色无用, background-clip即可作用于背景图片,也可作用于背景色</li>\n<li>当两者都作用于背景图片时, 不同于border-box 属性,background-origin边框在图片上面, 并且填充了边框,  background-clip 没有填充边框</li>\n</ol>\n<h2 id=\"渐变-线性渐变-径向渐变\"><a href=\"#渐变-线性渐变-径向渐变\" class=\"headerlink\" title=\"渐变 (线性渐变) (径向渐变)\"></a><span id=\"3\">渐变 (线性渐变) (径向渐变)</span></h2><blockquote>\n<p>在两个或多个指定的颜色之间显示平稳的过渡,如果你想要在渐变的方向上做更多的控制，你可以定义一个角度(逆时针)，而不用预定义方向（to bottom、to top、to right、to left、to bottom right，等等）</p>\n</blockquote>\n<ul>\n<li>线性渐变 background: linear-gradient(direction(90deg), color-stop1, color-stop2, …);</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#div</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">-webkit-linear-gradient</span>(top, red, blue, green);</span><br><span class=\"line\">    //background: -webkit-linear-gradient(left, red, blue, green);</span><br><span class=\"line\">    //background: -webkit-linear-gradient(top left, red, blue, green);</span><br><span class=\"line\">    //background: -webkit-linear-gradient(left bottom, red, blue, green);</span><br><span class=\"line\">    //background: -webkit-repeating-linear-gradient(top left, red, blue 10%,green 30%);//重复渐变</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>径向渐变 background: radial-gradient(center, shape(ellipse/circle) size, start-color, …, last-color);</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#div</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">background</span>: <span class=\"built_in\">-webkit-radial-gradient</span>(red, green, blue);</span><br><span class=\"line\">        //background: -webkit-radial-gradient(red 5%, green 15%, blue 60%);</span><br><span class=\"line\">        //background: -webkit-repeating-radial-gradient(red, green 10%, blue 15%);//重复渐变</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"文本效果\"><a href=\"#文本效果\" class=\"headerlink\" title=\"文本效果\"></a><span id=\"4\">文本效果</span></h2><ul>\n<li><p>text-shadow: 5px(水平阴影)   5px(垂直阴影)   10px(模糊距离)   green;</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#div</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">text-shadow</span>: <span class=\"number\">5px</span> <span class=\"number\">5px</span> <span class=\"number\">5px</span> <span class=\"number\">#FF0000</span>;</span><br><span class=\"line\">        <span class=\"attribute\">font-size</span>: <span class=\"number\">40px</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>word-wrap:break-word(自动换行)   文字超出会自动换行    字母 数字 标点符号不换  (ps不兼容 Opera)</p>\n</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#div</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">       <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">       <span class=\"attribute\">text-shadow</span>: <span class=\"number\">5px</span> <span class=\"number\">5px</span> <span class=\"number\">5px</span> <span class=\"number\">#FF0000</span>;</span><br><span class=\"line\">       <span class=\"attribute\">font-size</span>: <span class=\"number\">40px</span>;</span><br><span class=\"line\">       <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> solid red;</span><br><span class=\"line\">       <span class=\"attribute\">word-wrap</span>:break-word;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2D转换\"><a href=\"#2D转换\" class=\"headerlink\" title=\"2D转换\"></a><span id=\"5\">2D转换</span></h2><blockquote>\n<p>可以移动，比例化，反过来，旋转，和拉伸元素。<br> transform  (IE10 ff  Opera 支持. IE9(-ms-)和Chrome Safari(-webkit-) 要加前缀)</p>\n</blockquote>\n<ul>\n<li>transform: translate(50px, 50px) (translateX/Y)    (上下 作用偏移,以元素中心点为中心偏移,设置transform-origin属性无用)</li>\n<li>transform: rotate(90deg) rotate(X/Y)               (旋转,以中心为原点旋转,可改变中心点)</li>\n<li>transform: scale(2,2) (scaleX/Y)                   (元素尺寸增加或减少倍数,中心点旋转,可改变中心点)</li>\n<li>transform: skew(10deg,0deg) (skewX/Y)              (元素翻转 x y,中心点旋转,可改变中心点)</li>\n<li>transform:matrix(0.866,0.5,-0.5,0.866,0,0)         (matrix()方法,六个参数，包含旋转，缩放，移动（平移）和倾斜功能)</li>\n<li>transform-origin:0 0;                              (允许改变被转换元素的位置,默认元素中心点)</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#div</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">    //transform:translate(200px,200px);</span><br><span class=\"line\">    //transform: rotate(30deg);</span><br><span class=\"line\">    //transform-origin:0 0;</span><br><span class=\"line\">    //transform: skew(30deg,20deg);</span><br><span class=\"line\">    <span class=\"selector-tag\">transform</span>: <span class=\"selector-tag\">scale</span>(2,2)</span><br><span class=\"line\">    //transform:matrix(0.866,0.5,-0.5,0.866,0,0);</span><br><span class=\"line\">    <span class=\"selector-tag\">margin</span>: 100<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">auto</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">transform-origin</span><span class=\"selector-pseudo\">:0</span> 0;</span><br><span class=\"line\">    //animation:myfirst 5s linear 2s infinite alternate;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> myfirst</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">from</span> &#123;<span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(1,1)&#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">to</span> &#123;<span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(2,2)&#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3D转换\"><a href=\"#3D转换\" class=\"headerlink\" title=\"3D转换\"></a><span id=\"6\">3D转换</span></h2><blockquote>\n<p>方法 同2D 只是多了Z轴  rotate可以规定X Y Z (transform: rotateX/Y/Z(30deg))</p>\n</blockquote>\n<ul>\n<li>transform: translate3d(x,y,z)</li>\n<li>transform: scale3d(x,y,z)</li>\n<li>transform: rotate3d(x,y,z,angle)</li>\n<li>perspective: 500 (设置从何处查看一个元素的角度,perspective 属性只影响 3D 转换元素)</li>\n<li>perspective-origin: 10% 10% (设置一个3D元素的基数位置)</li>\n<li>transform-style: preserve-3d (让转换的子元素保留3D转换)</li>\n</ul>\n<h2 id=\"过渡\"><a href=\"#过渡\" class=\"headerlink\" title=\"过渡\"></a><span id=\"7\">过渡</span></h2><blockquote>\n<p>为了添加某种效果可以从一种样式转变到另一个的时候，无需使用Flash动画或JavaScript</p>\n</blockquote>\n<ul>\n<li>transition 属性是一个简写属性，用于设置四个过渡属性  (默认all 0 ease 0) (给运动元素加此属性,hover时加要变的属性)</li>\n<li>transition-property (哪个属性变)</li>\n<li>transition-duration (完成这个效果的时间  必须设置 否则默认为0)</li>\n<li>transition-timing-function (<a href=\"http://www.runoob.com/cssref/css3-pr-transition-timing-function.html\" target=\"_blank\" rel=\"noopener\">规定速度效果的速度曲线</a>   linear|ease|ease-in|ease-out|ease-in-out)</li>\n<li>transition-delay (效果延时多少开始)</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#div</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">background</span>:red;</span><br><span class=\"line\">        <span class=\"attribute\">transition</span>:width <span class=\"number\">2s</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#div</span><span class=\"selector-pseudo\">:hover</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>:<span class=\"number\">300px</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a><span id=\"8\">动画</span></h2><ul>\n<li>@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果</li>\n<li>先定义动画,然后在动画元素属性里面调用,(animation: 动画名  运动的时间 <a href=\"http://www.runoob.com/cssref/css3-pr-animation-timing-function.html\" target=\"_blank\" rel=\"noopener\">速度曲线</a> 延时多少开始 运动次数(infinite 无数次)  反向播放动画 )</li>\n<li>animation:myfirst 5s linear 2s infinite alternate;</li>\n<li>animation-play-state:running/paused (属性规定动画正在运行还是暂停 js中使用 可以控制动画暂停与播放)</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#div</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">position</span>:relative;</span><br><span class=\"line\">        <span class=\"attribute\">animation</span>:myfirst <span class=\"number\">5s</span> linear <span class=\"number\">2s</span> infinite alternate;</span><br><span class=\"line\">        //animation-play-state:paused;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> myfirst</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        0%   &#123;<span class=\"attribute\">background</span>:red; <span class=\"attribute\">left</span>:<span class=\"number\">0px</span>; <span class=\"attribute\">top</span>:<span class=\"number\">0px</span>;&#125;</span><br><span class=\"line\">        25%  &#123;<span class=\"attribute\">background</span>:yellow; <span class=\"attribute\">left</span>:<span class=\"number\">200px</span>; <span class=\"attribute\">top</span>:<span class=\"number\">0px</span>;&#125;</span><br><span class=\"line\">        50%  &#123;<span class=\"attribute\">background</span>:blue; <span class=\"attribute\">left</span>:<span class=\"number\">200px</span>; <span class=\"attribute\">top</span>:<span class=\"number\">200px</span>;&#125;</span><br><span class=\"line\">        75%  &#123;<span class=\"attribute\">background</span>:green; <span class=\"attribute\">left</span>:<span class=\"number\">0px</span>; <span class=\"attribute\">top</span>:<span class=\"number\">200px</span>;&#125;</span><br><span class=\"line\">        100% &#123;<span class=\"attribute\">background</span>:red; <span class=\"attribute\">left</span>:<span class=\"number\">0px</span>; <span class=\"attribute\">top</span>:<span class=\"number\">0px</span>;&#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"多列\"><a href=\"#多列\" class=\"headerlink\" title=\"多列\"></a><span id=\"9\">多列</span></h2><blockquote>\n<p>可以将文本内容设计成像报纸一样的多列布局</p>\n</blockquote>\n<ul>\n<li>column-count 属性规定元素应该被分隔的列数  (column-count:3)</li>\n<li>column-gap 属性规定列之间的间隔 (column-gap:30px)</li>\n<li>column-rule 属性设置列之间的宽度、样式和颜色规则  (column-rule:4px outset #ff0000)</li>\n<li>column-width 属性规定列的宽度  (column-width: auto(浏览器决定 没有效果) / 100px)</li>\n<li>column-span 属性规定元素应横跨多少列  (column-span: 1 / all)</li>\n<li>columns 属性是一个简写属性，用于设置列宽和列数   (columns:100px(4) 3(1);)</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=\"div\"&gt;</span><br><span class=\"line\">    &lt;h2&gt;英国维斯米斯特教堂碑文&lt;/h2&gt;</span><br><span class=\"line\">    当我年轻的时候，我梦想改变这个世界；当我成熟以后，我发现我不能够改变这个世界，我将目光缩短了些，决定只改变我的国家；当我进入暮年以后，我发现我不能够改变我们的国家，我的最后愿望仅仅是改变一下我的家庭，但是，这也不可能。当我现在躺在床上，行将就木时，我突然意识到：如果一开始我仅仅去改变我自己，然后，我可能改变我的家庭；在家人的帮助和鼓励下，我可能为国家做一些事情；然后，谁知道呢?我甚至可能改变这个世界。</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"><span class=\"selector-id\">#div</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attribute\">column-count</span>: <span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"attribute\">column-gap</span>:<span class=\"number\">90px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">column-rule</span>:<span class=\"number\">4px</span> outset <span class=\"number\">#ff0000</span>;</span><br><span class=\"line\">        //column-rule:4px dotted #ff0000;</span><br><span class=\"line\">        <span class=\"selector-tag\">column-span</span>: <span class=\"selector-tag\">all</span>;</span><br><span class=\"line\">        <span class=\"selector-tag\">column-width</span><span class=\"selector-pseudo\">:100px</span>;</span><br><span class=\"line\">        //column-span: 1; // 默认</span><br><span class=\"line\">        //columns:100px 3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">h2</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attribute\">column-span</span>:<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"attribute\">-webkit-column-span</span>:<span class=\"number\">1</span>; <span class=\"comment\">/* Safari and Chrome */</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"用户界面\"><a href=\"#用户界面\" class=\"headerlink\" title=\"用户界面\"></a><span id=\"10\">用户界面</span></h2><ul>\n<li>调整尺寸(Resizing)</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id='div'&gt;调整属性指定一个元素是否由用户可调整大小的&lt;/div&gt;</span><br><span class=\"line\"><span class=\"selector-id\">#div</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attribute\">border</span>:<span class=\"number\">2px</span> solid;</span><br><span class=\"line\">        <span class=\"attribute\">padding</span>:<span class=\"number\">10px</span> <span class=\"number\">40px</span>; </span><br><span class=\"line\">        <span class=\"attribute\">width</span>:<span class=\"number\">300px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">resize</span>:both;</span><br><span class=\"line\">        <span class=\"attribute\">overflow</span>:auto;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>外形修饰（outline-offset ）</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id='div'&gt;</span><br><span class=\"line\">    这个 <span class=\"selector-tag\">div</span>有一个轮廓边界15 <span class=\"selector-tag\">px</span>边境外的边缘。<span class=\"selector-tag\">Internet</span> <span class=\"selector-tag\">Explorer</span> 不兼容 <span class=\"selector-tag\">outline-offset</span>属性.</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"><span class=\"selector-id\">#div</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attribute\">margin</span>:<span class=\"number\">20px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>:<span class=\"number\">150px</span>; </span><br><span class=\"line\">        <span class=\"attribute\">padding</span>:<span class=\"number\">10px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">height</span>:<span class=\"number\">70px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">border</span>:<span class=\"number\">2px</span> solid black;</span><br><span class=\"line\">        <span class=\"attribute\">outline</span>:<span class=\"number\">2px</span> solid red;</span><br><span class=\"line\">        <span class=\"attribute\">outline-offset</span>:<span class=\"number\">15px</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"弹性盒\"><a href=\"#弹性盒\" class=\"headerlink\" title=\"弹性盒\"></a><span id=\"11\">弹性盒</span></h2><blockquote>\n<p>弹性盒子是 CSS3 的一种新的布局模式。CSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间</p>\n</blockquote>\n<ul>\n<li>弹性盒子 = 弹性容器(Flex container) + 弹性子元素(Flex item)</li>\n<li>弹性容器设置 display 属性的值为 flex 或 inline-flex将其定义为弹性容器(弹性容器上)</li>\n<li>direction: rtl (right-to-left) 修改弹性子元素的排列方式也会改变，页面布局也跟着改变 (弹性容器上)</li>\n<li>flex-direction 顺序指定了弹性子元素在父容器中的位置 (flex-direction: row | row-reverse | column | column-reverse)(弹性容器上)<ul>\n<li>row：横向从左到右排列（左对齐），默认</li>\n<li>row-reverse：反转横向排列（右对齐，从后往前排，最后一项排在最前面</li>\n<li>column：纵向排列</li>\n<li>column-reverse：反转纵向排列，从后往前排，最后一项排在最上面</li>\n</ul>\n</li>\n<li>justify-content(内容对齐): flex-start | flex-end | center | space-between | space-around (弹性容器上)</li>\n<li>align-items(设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式): flex-start | flex-end | center | baseline | stretch(弹性容器上)</li>\n<li>flex-wrap(用于指定弹性盒子的子元素换行方式): nowrap|wrap|wrap-reverse|initial|inherit; (弹性容器上)<ul>\n<li>nowrap - 默认， 弹性容器为单行。该情况下弹性子项可能会溢出容器。</li>\n<li>wrap - 弹性容器为多行。该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行</li>\n<li>wrap-reverse -反转 wrap 排列</li>\n</ul>\n</li>\n<li>align-content(用于修改 flex-wrap 属性的行为): flex-start | flex-end | center | space-between | space-around | stretch, 类似于 align-items, 但它不是设置弹性子元素的对齐，而是设置各个行的对齐 (弹性容器上)<ul>\n<li>stretch - 默认。各行将会伸展以占用剩余的空间。</li>\n<li>flex-start - 各行向弹性盒容器的起始位置堆叠。</li>\n<li>flex-end - 各行向弹性盒容器的结束位置堆叠。</li>\n<li>center -各行向弹性盒容器的中间位置堆叠。</li>\n<li>space-between -各行在弹性盒容器中平均分布。</li>\n<li>space-around - 各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"弹性子元素属性\"><a href=\"#弹性子元素属性\" class=\"headerlink\" title=\"弹性子元素属性\"></a>弹性子元素属性</h3><ul>\n<li>order 属性设置弹性容器内弹性子元素的属性</li>\n<li>align-self (在弹性子元素上使用。覆盖容器的 align-items 属性): auto | flex-start | flex-end | center | baseline | stretch</li>\n<li>flex (设置弹性盒子的子元素如何分配空间): auto | initial | none | inherit |  [ flex-grow ] || [ flex-shrink ] || [ flex-basis ]</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=\"flex-container\"&gt;</span><br><span class=\"line\">    &lt;div class=\"flex-item\"&gt;flex item 1&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=\"flex-item\"&gt;flex item 2&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=\"flex-item\"&gt;flex item 3&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=\"flex-item\"&gt;flex item 4&lt;/div&gt;  </span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.flex-container</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: -webkit-flex;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">400px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">250px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: lightgrey;</span><br><span class=\"line\">    //direction: rtl;</span><br><span class=\"line\">    //flex-direction: row;</span><br><span class=\"line\">    //flex-direction: row-reverse;</span><br><span class=\"line\">    //flex-direction: column;</span><br><span class=\"line\">    //flex-direction: column-reverse;</span><br><span class=\"line\">    //justify-content: flex-start;</span><br><span class=\"line\">    //justify-content: flex-end;</span><br><span class=\"line\">    //justify-content: center;</span><br><span class=\"line\">    //justify-content: space-between;</span><br><span class=\"line\">    //justify-content: space-around;</span><br><span class=\"line\">    //flex-wrap: nowrap;</span><br><span class=\"line\">    //flex-wrap: wrap;</span><br><span class=\"line\">    //flex-wrap: wrap-reverse;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.flex-item</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: cornflowerblue;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">15%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"calc-使用\"><a href=\"#calc-使用\" class=\"headerlink\" title=\"calc()使用\"></a><span id=\"0\"><a href=\"http://www.w3cplus.com/css3/how-to-use-css3-calc-function.html\" target=\"_blank\" rel=\"noopener\">calc()使用</a></span></h2><blockquote>\n<p>能实现自适应的布局 box-sizing, 浏览器对calc()的兼容性还算不错，在IE9+、FF4.0+、Chrome19+、Safari6+都得到较好支持著作权归作者所有。不过calc()最大的好处就是用在流体布局上(百分比)，可以通过calc()计算得到元素的宽度高度</p>\n</blockquote>","more":"<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"built_in\">calc</span>(50% - 2px - 80px);</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: thin solid;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">40px</span>;</span><br><span class=\"line\">    //box-sizing: border-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"#0\">calc()使用</a></li>\n<li><a href=\"#1\">边框</a></li>\n<li><a href=\"#2\">背景</a></li>\n<li><a href=\"#3\">渐变</a></li>\n<li><a href=\"#4\">文本效果</a></li>\n<li><a href=\"#5\">2D转换</a></li>\n<li><a href=\"#6\">3D转换</a></li>\n<li><a href=\"#7\">过渡</a></li>\n<li><a href=\"#8\">动画</a></li>\n<li><a href=\"#9\">多列</a></li>\n<li><a href=\"#10\">用户界面</a></li>\n<li><a href=\"#11\">弹性盒</a></li>\n</ul>\n<h2 id=\"边框\"><a href=\"#边框\" class=\"headerlink\" title=\"边框\"></a><span id=\"1\">边框</span></h2><blockquote>\n<p>用 CSS3，你可以创建圆角边框，添加阴影框，并作为边界的形象而不使用设计程序</p>\n</blockquote>\n<ul>\n<li><p>border-radius (圆角)</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id='div'&gt;&lt;/div&gt;</span><br><span class=\"line\"><span class=\"selector-id\">#div</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>:<span class=\"number\">2px</span> solid;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>:<span class=\"number\">25px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>box-shadow  (盒阴影)</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#div</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">box-shadow</span>: <span class=\"number\">20px</span> <span class=\"number\">20px</span> <span class=\"number\">20px</span> <span class=\"number\">0</span> gold inset;</span><br><span class=\"line\">        <span class=\"attribute\">box-shadow</span>: <span class=\"number\">10px</span> <span class=\"number\">10px</span> <span class=\"number\">5px</span> <span class=\"number\">#888888</span>;</span><br><span class=\"line\">        <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">        <span class=\"attribute\">margin</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">        // box-shadow: 10px(向右偏移,可取负数,必填) </span><br><span class=\"line\">                       10<span class=\"selector-tag\">px</span>(向下偏移,可取负数,必填) </span><br><span class=\"line\">                       20<span class=\"selector-tag\">px</span>(模糊距离,可选)</span><br><span class=\"line\">                       5<span class=\"selector-tag\">px</span>(阴影尺寸 可选)                                      </span><br><span class=\"line\">                       <span class=\"selector-id\">#888888</span>(颜色,可选 默认黑色)</span><br><span class=\"line\">                       <span class=\"selector-tag\">inset</span>(内阴影,可选);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"http://www.runoob.com/cssref/css3-pr-border-image.html\" target=\"_blank\" rel=\"noopener\">border-image</a>  (边界图片) …Internet Explorer 不支持</p>\n<pre><code>border-image:   source(图片路径) \n                slice(图像边界向内偏移) \n                width(图像边界的宽度) \n                outset(用于指定在边框外部绘制 border-image-area 的量) \n                repeat|initial|inherit(用于设置图像边界是否应重复（repeat）、拉伸（stretch）或铺满（round）);\n</code></pre><p>  默认border-image: none 100% 1 0 stretch</p>\n</li>\n</ul>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a><span id=\"2\">背景</span></h2><ul>\n<li>background-size: 100% 100%(200px 200px)注:(写成px的时候不包含padding 加box-sizing: border-box 一样)   (规定背景的绘制区域)</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#ccc</span> <span class=\"built_in\">url</span>(<span class=\"string\">'http://pic10.nipic.com/20101014/5888301_112136782000_2.jpg'</span>) no-repeat;</span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: <span class=\"number\">100%</span> <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">    <span class=\"comment\">/* background-size: 240px 240px; *</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>background-origin  (content-box(只填充内容区域)、padding-box(包含padding) 或 border-box(包含边框) ) =&gt;  相对于背景图片(背景色完全没有作用  规定背景图片的定位区域)</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">10px</span> dotted red;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#ccc</span> <span class=\"built_in\">url</span>(<span class=\"string\">'http://pic10.nipic.com/20101014/5888301_112136782000_2.jpg'</span>) no-repeat;</span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: <span class=\"number\">100%</span> <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-origin</span>: content-box;</span><br><span class=\"line\">    //background-origin: padding-box;</span><br><span class=\"line\">    //background-origin: border-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>background-clip (content-box(只填充内容区域)、padding-box(包含padding) 或 border-box(包含边框) )=&gt;相对于背景色(对图片的padding content 有作用  对border-box无用(默认就是))  (规定背景图片的尺寸)</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:  <span class=\"built_in\">url</span>(<span class=\"string\">'http://pic10.nipic.com/20101014/5888301_112136782000_2.jpg'</span>) no-repeat;</span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: <span class=\"number\">100%</span> <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: green;</span><br><span class=\"line\">    <span class=\"attribute\">background-clip</span>: border-box;</span><br><span class=\"line\">    <span class=\"comment\">/* background-origin: border-box; */</span></span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">10px</span> dashed red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>background-origin与background-clip区别</li>\n</ul>\n<ol>\n<li>background-origin只作用于背景图片,对背景色无用, background-clip即可作用于背景图片,也可作用于背景色</li>\n<li>当两者都作用于背景图片时, 不同于border-box 属性,background-origin边框在图片上面, 并且填充了边框,  background-clip 没有填充边框</li>\n</ol>\n<h2 id=\"渐变-线性渐变-径向渐变\"><a href=\"#渐变-线性渐变-径向渐变\" class=\"headerlink\" title=\"渐变 (线性渐变) (径向渐变)\"></a><span id=\"3\">渐变 (线性渐变) (径向渐变)</span></h2><blockquote>\n<p>在两个或多个指定的颜色之间显示平稳的过渡,如果你想要在渐变的方向上做更多的控制，你可以定义一个角度(逆时针)，而不用预定义方向（to bottom、to top、to right、to left、to bottom right，等等）</p>\n</blockquote>\n<ul>\n<li>线性渐变 background: linear-gradient(direction(90deg), color-stop1, color-stop2, …);</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#div</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">-webkit-linear-gradient</span>(top, red, blue, green);</span><br><span class=\"line\">    //background: -webkit-linear-gradient(left, red, blue, green);</span><br><span class=\"line\">    //background: -webkit-linear-gradient(top left, red, blue, green);</span><br><span class=\"line\">    //background: -webkit-linear-gradient(left bottom, red, blue, green);</span><br><span class=\"line\">    //background: -webkit-repeating-linear-gradient(top left, red, blue 10%,green 30%);//重复渐变</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>径向渐变 background: radial-gradient(center, shape(ellipse/circle) size, start-color, …, last-color);</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#div</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">background</span>: <span class=\"built_in\">-webkit-radial-gradient</span>(red, green, blue);</span><br><span class=\"line\">        //background: -webkit-radial-gradient(red 5%, green 15%, blue 60%);</span><br><span class=\"line\">        //background: -webkit-repeating-radial-gradient(red, green 10%, blue 15%);//重复渐变</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"文本效果\"><a href=\"#文本效果\" class=\"headerlink\" title=\"文本效果\"></a><span id=\"4\">文本效果</span></h2><ul>\n<li><p>text-shadow: 5px(水平阴影)   5px(垂直阴影)   10px(模糊距离)   green;</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#div</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">text-shadow</span>: <span class=\"number\">5px</span> <span class=\"number\">5px</span> <span class=\"number\">5px</span> <span class=\"number\">#FF0000</span>;</span><br><span class=\"line\">        <span class=\"attribute\">font-size</span>: <span class=\"number\">40px</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>word-wrap:break-word(自动换行)   文字超出会自动换行    字母 数字 标点符号不换  (ps不兼容 Opera)</p>\n</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#div</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">       <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">       <span class=\"attribute\">text-shadow</span>: <span class=\"number\">5px</span> <span class=\"number\">5px</span> <span class=\"number\">5px</span> <span class=\"number\">#FF0000</span>;</span><br><span class=\"line\">       <span class=\"attribute\">font-size</span>: <span class=\"number\">40px</span>;</span><br><span class=\"line\">       <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> solid red;</span><br><span class=\"line\">       <span class=\"attribute\">word-wrap</span>:break-word;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2D转换\"><a href=\"#2D转换\" class=\"headerlink\" title=\"2D转换\"></a><span id=\"5\">2D转换</span></h2><blockquote>\n<p>可以移动，比例化，反过来，旋转，和拉伸元素。<br> transform  (IE10 ff  Opera 支持. IE9(-ms-)和Chrome Safari(-webkit-) 要加前缀)</p>\n</blockquote>\n<ul>\n<li>transform: translate(50px, 50px) (translateX/Y)    (上下 作用偏移,以元素中心点为中心偏移,设置transform-origin属性无用)</li>\n<li>transform: rotate(90deg) rotate(X/Y)               (旋转,以中心为原点旋转,可改变中心点)</li>\n<li>transform: scale(2,2) (scaleX/Y)                   (元素尺寸增加或减少倍数,中心点旋转,可改变中心点)</li>\n<li>transform: skew(10deg,0deg) (skewX/Y)              (元素翻转 x y,中心点旋转,可改变中心点)</li>\n<li>transform:matrix(0.866,0.5,-0.5,0.866,0,0)         (matrix()方法,六个参数，包含旋转，缩放，移动（平移）和倾斜功能)</li>\n<li>transform-origin:0 0;                              (允许改变被转换元素的位置,默认元素中心点)</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#div</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">    //transform:translate(200px,200px);</span><br><span class=\"line\">    //transform: rotate(30deg);</span><br><span class=\"line\">    //transform-origin:0 0;</span><br><span class=\"line\">    //transform: skew(30deg,20deg);</span><br><span class=\"line\">    <span class=\"selector-tag\">transform</span>: <span class=\"selector-tag\">scale</span>(2,2)</span><br><span class=\"line\">    //transform:matrix(0.866,0.5,-0.5,0.866,0,0);</span><br><span class=\"line\">    <span class=\"selector-tag\">margin</span>: 100<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">auto</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">transform-origin</span><span class=\"selector-pseudo\">:0</span> 0;</span><br><span class=\"line\">    //animation:myfirst 5s linear 2s infinite alternate;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> myfirst</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">from</span> &#123;<span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(1,1)&#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">to</span> &#123;<span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(2,2)&#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3D转换\"><a href=\"#3D转换\" class=\"headerlink\" title=\"3D转换\"></a><span id=\"6\">3D转换</span></h2><blockquote>\n<p>方法 同2D 只是多了Z轴  rotate可以规定X Y Z (transform: rotateX/Y/Z(30deg))</p>\n</blockquote>\n<ul>\n<li>transform: translate3d(x,y,z)</li>\n<li>transform: scale3d(x,y,z)</li>\n<li>transform: rotate3d(x,y,z,angle)</li>\n<li>perspective: 500 (设置从何处查看一个元素的角度,perspective 属性只影响 3D 转换元素)</li>\n<li>perspective-origin: 10% 10% (设置一个3D元素的基数位置)</li>\n<li>transform-style: preserve-3d (让转换的子元素保留3D转换)</li>\n</ul>\n<h2 id=\"过渡\"><a href=\"#过渡\" class=\"headerlink\" title=\"过渡\"></a><span id=\"7\">过渡</span></h2><blockquote>\n<p>为了添加某种效果可以从一种样式转变到另一个的时候，无需使用Flash动画或JavaScript</p>\n</blockquote>\n<ul>\n<li>transition 属性是一个简写属性，用于设置四个过渡属性  (默认all 0 ease 0) (给运动元素加此属性,hover时加要变的属性)</li>\n<li>transition-property (哪个属性变)</li>\n<li>transition-duration (完成这个效果的时间  必须设置 否则默认为0)</li>\n<li>transition-timing-function (<a href=\"http://www.runoob.com/cssref/css3-pr-transition-timing-function.html\" target=\"_blank\" rel=\"noopener\">规定速度效果的速度曲线</a>   linear|ease|ease-in|ease-out|ease-in-out)</li>\n<li>transition-delay (效果延时多少开始)</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#div</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">background</span>:red;</span><br><span class=\"line\">        <span class=\"attribute\">transition</span>:width <span class=\"number\">2s</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#div</span><span class=\"selector-pseudo\">:hover</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>:<span class=\"number\">300px</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a><span id=\"8\">动画</span></h2><ul>\n<li>@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果</li>\n<li>先定义动画,然后在动画元素属性里面调用,(animation: 动画名  运动的时间 <a href=\"http://www.runoob.com/cssref/css3-pr-animation-timing-function.html\" target=\"_blank\" rel=\"noopener\">速度曲线</a> 延时多少开始 运动次数(infinite 无数次)  反向播放动画 )</li>\n<li>animation:myfirst 5s linear 2s infinite alternate;</li>\n<li>animation-play-state:running/paused (属性规定动画正在运行还是暂停 js中使用 可以控制动画暂停与播放)</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#div</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">position</span>:relative;</span><br><span class=\"line\">        <span class=\"attribute\">animation</span>:myfirst <span class=\"number\">5s</span> linear <span class=\"number\">2s</span> infinite alternate;</span><br><span class=\"line\">        //animation-play-state:paused;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> myfirst</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        0%   &#123;<span class=\"attribute\">background</span>:red; <span class=\"attribute\">left</span>:<span class=\"number\">0px</span>; <span class=\"attribute\">top</span>:<span class=\"number\">0px</span>;&#125;</span><br><span class=\"line\">        25%  &#123;<span class=\"attribute\">background</span>:yellow; <span class=\"attribute\">left</span>:<span class=\"number\">200px</span>; <span class=\"attribute\">top</span>:<span class=\"number\">0px</span>;&#125;</span><br><span class=\"line\">        50%  &#123;<span class=\"attribute\">background</span>:blue; <span class=\"attribute\">left</span>:<span class=\"number\">200px</span>; <span class=\"attribute\">top</span>:<span class=\"number\">200px</span>;&#125;</span><br><span class=\"line\">        75%  &#123;<span class=\"attribute\">background</span>:green; <span class=\"attribute\">left</span>:<span class=\"number\">0px</span>; <span class=\"attribute\">top</span>:<span class=\"number\">200px</span>;&#125;</span><br><span class=\"line\">        100% &#123;<span class=\"attribute\">background</span>:red; <span class=\"attribute\">left</span>:<span class=\"number\">0px</span>; <span class=\"attribute\">top</span>:<span class=\"number\">0px</span>;&#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"多列\"><a href=\"#多列\" class=\"headerlink\" title=\"多列\"></a><span id=\"9\">多列</span></h2><blockquote>\n<p>可以将文本内容设计成像报纸一样的多列布局</p>\n</blockquote>\n<ul>\n<li>column-count 属性规定元素应该被分隔的列数  (column-count:3)</li>\n<li>column-gap 属性规定列之间的间隔 (column-gap:30px)</li>\n<li>column-rule 属性设置列之间的宽度、样式和颜色规则  (column-rule:4px outset #ff0000)</li>\n<li>column-width 属性规定列的宽度  (column-width: auto(浏览器决定 没有效果) / 100px)</li>\n<li>column-span 属性规定元素应横跨多少列  (column-span: 1 / all)</li>\n<li>columns 属性是一个简写属性，用于设置列宽和列数   (columns:100px(4) 3(1);)</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=\"div\"&gt;</span><br><span class=\"line\">    &lt;h2&gt;英国维斯米斯特教堂碑文&lt;/h2&gt;</span><br><span class=\"line\">    当我年轻的时候，我梦想改变这个世界；当我成熟以后，我发现我不能够改变这个世界，我将目光缩短了些，决定只改变我的国家；当我进入暮年以后，我发现我不能够改变我们的国家，我的最后愿望仅仅是改变一下我的家庭，但是，这也不可能。当我现在躺在床上，行将就木时，我突然意识到：如果一开始我仅仅去改变我自己，然后，我可能改变我的家庭；在家人的帮助和鼓励下，我可能为国家做一些事情；然后，谁知道呢?我甚至可能改变这个世界。</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"><span class=\"selector-id\">#div</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attribute\">column-count</span>: <span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"attribute\">column-gap</span>:<span class=\"number\">90px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">column-rule</span>:<span class=\"number\">4px</span> outset <span class=\"number\">#ff0000</span>;</span><br><span class=\"line\">        //column-rule:4px dotted #ff0000;</span><br><span class=\"line\">        <span class=\"selector-tag\">column-span</span>: <span class=\"selector-tag\">all</span>;</span><br><span class=\"line\">        <span class=\"selector-tag\">column-width</span><span class=\"selector-pseudo\">:100px</span>;</span><br><span class=\"line\">        //column-span: 1; // 默认</span><br><span class=\"line\">        //columns:100px 3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">h2</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attribute\">column-span</span>:<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"attribute\">-webkit-column-span</span>:<span class=\"number\">1</span>; <span class=\"comment\">/* Safari and Chrome */</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"用户界面\"><a href=\"#用户界面\" class=\"headerlink\" title=\"用户界面\"></a><span id=\"10\">用户界面</span></h2><ul>\n<li>调整尺寸(Resizing)</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id='div'&gt;调整属性指定一个元素是否由用户可调整大小的&lt;/div&gt;</span><br><span class=\"line\"><span class=\"selector-id\">#div</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attribute\">border</span>:<span class=\"number\">2px</span> solid;</span><br><span class=\"line\">        <span class=\"attribute\">padding</span>:<span class=\"number\">10px</span> <span class=\"number\">40px</span>; </span><br><span class=\"line\">        <span class=\"attribute\">width</span>:<span class=\"number\">300px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">resize</span>:both;</span><br><span class=\"line\">        <span class=\"attribute\">overflow</span>:auto;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>外形修饰（outline-offset ）</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id='div'&gt;</span><br><span class=\"line\">    这个 <span class=\"selector-tag\">div</span>有一个轮廓边界15 <span class=\"selector-tag\">px</span>边境外的边缘。<span class=\"selector-tag\">Internet</span> <span class=\"selector-tag\">Explorer</span> 不兼容 <span class=\"selector-tag\">outline-offset</span>属性.</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"><span class=\"selector-id\">#div</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attribute\">margin</span>:<span class=\"number\">20px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>:<span class=\"number\">150px</span>; </span><br><span class=\"line\">        <span class=\"attribute\">padding</span>:<span class=\"number\">10px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">height</span>:<span class=\"number\">70px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">border</span>:<span class=\"number\">2px</span> solid black;</span><br><span class=\"line\">        <span class=\"attribute\">outline</span>:<span class=\"number\">2px</span> solid red;</span><br><span class=\"line\">        <span class=\"attribute\">outline-offset</span>:<span class=\"number\">15px</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"弹性盒\"><a href=\"#弹性盒\" class=\"headerlink\" title=\"弹性盒\"></a><span id=\"11\">弹性盒</span></h2><blockquote>\n<p>弹性盒子是 CSS3 的一种新的布局模式。CSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间</p>\n</blockquote>\n<ul>\n<li>弹性盒子 = 弹性容器(Flex container) + 弹性子元素(Flex item)</li>\n<li>弹性容器设置 display 属性的值为 flex 或 inline-flex将其定义为弹性容器(弹性容器上)</li>\n<li>direction: rtl (right-to-left) 修改弹性子元素的排列方式也会改变，页面布局也跟着改变 (弹性容器上)</li>\n<li>flex-direction 顺序指定了弹性子元素在父容器中的位置 (flex-direction: row | row-reverse | column | column-reverse)(弹性容器上)<ul>\n<li>row：横向从左到右排列（左对齐），默认</li>\n<li>row-reverse：反转横向排列（右对齐，从后往前排，最后一项排在最前面</li>\n<li>column：纵向排列</li>\n<li>column-reverse：反转纵向排列，从后往前排，最后一项排在最上面</li>\n</ul>\n</li>\n<li>justify-content(内容对齐): flex-start | flex-end | center | space-between | space-around (弹性容器上)</li>\n<li>align-items(设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式): flex-start | flex-end | center | baseline | stretch(弹性容器上)</li>\n<li>flex-wrap(用于指定弹性盒子的子元素换行方式): nowrap|wrap|wrap-reverse|initial|inherit; (弹性容器上)<ul>\n<li>nowrap - 默认， 弹性容器为单行。该情况下弹性子项可能会溢出容器。</li>\n<li>wrap - 弹性容器为多行。该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行</li>\n<li>wrap-reverse -反转 wrap 排列</li>\n</ul>\n</li>\n<li>align-content(用于修改 flex-wrap 属性的行为): flex-start | flex-end | center | space-between | space-around | stretch, 类似于 align-items, 但它不是设置弹性子元素的对齐，而是设置各个行的对齐 (弹性容器上)<ul>\n<li>stretch - 默认。各行将会伸展以占用剩余的空间。</li>\n<li>flex-start - 各行向弹性盒容器的起始位置堆叠。</li>\n<li>flex-end - 各行向弹性盒容器的结束位置堆叠。</li>\n<li>center -各行向弹性盒容器的中间位置堆叠。</li>\n<li>space-between -各行在弹性盒容器中平均分布。</li>\n<li>space-around - 各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"弹性子元素属性\"><a href=\"#弹性子元素属性\" class=\"headerlink\" title=\"弹性子元素属性\"></a>弹性子元素属性</h3><ul>\n<li>order 属性设置弹性容器内弹性子元素的属性</li>\n<li>align-self (在弹性子元素上使用。覆盖容器的 align-items 属性): auto | flex-start | flex-end | center | baseline | stretch</li>\n<li>flex (设置弹性盒子的子元素如何分配空间): auto | initial | none | inherit |  [ flex-grow ] || [ flex-shrink ] || [ flex-basis ]</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=\"flex-container\"&gt;</span><br><span class=\"line\">    &lt;div class=\"flex-item\"&gt;flex item 1&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=\"flex-item\"&gt;flex item 2&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=\"flex-item\"&gt;flex item 3&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=\"flex-item\"&gt;flex item 4&lt;/div&gt;  </span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.flex-container</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: -webkit-flex;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">400px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">250px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: lightgrey;</span><br><span class=\"line\">    //direction: rtl;</span><br><span class=\"line\">    //flex-direction: row;</span><br><span class=\"line\">    //flex-direction: row-reverse;</span><br><span class=\"line\">    //flex-direction: column;</span><br><span class=\"line\">    //flex-direction: column-reverse;</span><br><span class=\"line\">    //justify-content: flex-start;</span><br><span class=\"line\">    //justify-content: flex-end;</span><br><span class=\"line\">    //justify-content: center;</span><br><span class=\"line\">    //justify-content: space-between;</span><br><span class=\"line\">    //justify-content: space-around;</span><br><span class=\"line\">    //flex-wrap: nowrap;</span><br><span class=\"line\">    //flex-wrap: wrap;</span><br><span class=\"line\">    //flex-wrap: wrap-reverse;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.flex-item</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: cornflowerblue;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">15%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"js数组","date":"2018-05-07T03:03:28.000Z","_content":"\n> javascript数组的方法，包含es6，Array 对象用于在单个的变量中存储多个值。\n\n<!-- more -->\n\n创建 Array 对象的语法：\n\n```js\nnew Array();\nnew Array(size);\nnew Array(element0, element1, ..., elementn);\n```\n![for example](/img/js/array1.png);\n\n### 1. concat() 方法用于连接两个或多个数组\n\n该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本\n\n```js\nvar a = [1,2,3]\nvar b = [4,5,6]\na.concat(b)\n\nresult: 返回新数组 [1,2,3,4,5,6]  a = [1,2,3]  b = [3,4,5]\n```\n\n### 2. join() 方法用于把数组中的所有元素放入一个字符串。\n\n元素是通过指定的分隔符进行分隔的。\n\n```js\nvar a = [1,2,3]\na.join('-')\n\nresult: 返回新string '1-2-3'   a = [1,2,3]\n```\n\n### 3. pop() 方法用于删除并返回数组的最后一个元素。\n\n```js\nvar a = [1,2,3]\na.pop()\n\nresult: [1,2]    a = [1,2] (被改变) 返回被删除的值\n```\n### 4. push() 方法用于添加元素，返回push的最后一个值。\n\n```js\nvar a = [1,2,3]\na.push(4,5,6)\n\nresult: [1,2,3,4,5,6]    a = [1,2,3,4,5,6] (被改变) 返回push的最后一个值\n```\n\n### 5. reverse() 方法用于颠倒数组中元素的顺序。\n\n```js\nvar a = [1,2,3]\na.reverse()\n\nresult: [3,2,1]    a = [3,2,1] (被改变) 返回颠倒数组\n```\n### 6. shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。\n\n```js\nvar a = [1,2,3]\na.shift()\n\nresult: [2,3]    a = [2,3] (被改变) 返回第一个元素的值 1\n```\n### 7. unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。\n\n```js\nvar a = [1,2,3]\na.unshift(0,9)\n\nresult [0,9,1,2,3]  a = [0,9,1,2,3] (被改变) 返回数组的长度 6\n```\n\n### 8. slice() 方法可从已有的数组中返回选定的元素。\n\n```js\nvar a = [1,2,3]\na.slice(0,2)\n\nresult [1,2]  a = [1,2,3] 返回截取的数组 [1,2], 和splice()不同，splice会改变原数组\n```\n\n### 9. sort() 方法用于对数组的元素进行排序。\n\n```js\nvar a = [6,9,1]\nvar b = [1, 5, 10, 25, 40, 1000]\na.sort()\nb.sort()  // 1, 10, 1000, 25, 40, 5(说明)\nfunction sortNumber(a,b) {\n    return a - b\n    }\nb.sort(sortNumber) //right\n\nresult [1,6,9]  a = [1,6,9] (被改变) 返回排序后的数组\n\n```\n\nps : 说明\n\n如果调用该方法时没有使用参数，将按 **字母** 顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。\n\n如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：\n\n若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。\n若 a 等于 b，则返回 0。\n若 a 大于 b，则返回一个大于 0 的值。\n\n### 10. splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。该方法会改变原始数组\n\n```js\nvar a = [1,2,3]\na.splice(0,0,4)  \n//1.规定添加/删除项目的位置，使用负数可从数组结尾处规定位置\n//2.要删除的项目数量。如果设置为 0，则不会删除项目\n//3.可选。向数组添加的新项目。\nresult [4,1,2,3]  a = [4,1,2,3] (被改变) 返回选取的数组\n```\n### 11. splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。该方法会改变原始数组\n\n```js\nvar a = [1,2,3]\na.splice(0,0,4)  \n//1.规定添加/删除项目的位置，使用负数可从数组结尾处规定位置\n//2.要删除的项目数量。如果设置为 0，则不会删除项目\n//3.可选。向数组添加的新项目。\nresult [4,1,2,3]  a = [4,1,2,3] (被改变) 返回选取的数组\n```\n\n### 11. toSource()方法表示对象的源代码\n\n```js\nfunction employee(name,job,born)\n    {\n    this.name=name;\n    this.job=job;\n    this.born=born;\n}\n\nvar bill=new employee(\"Bill Gates\",\"Engineer\",1985);\ndocument.write(bill.toSource());\n//只有 Gecko 核心的浏览器（比如 Firefox）支持该方法，也就是说 IE、Safari、Chrome、Opera 等浏览器均不支持该方法。\n```\n\n### 12. toString() 方法可把数组转换为字符串，并返回结果。\n\n```js\nvar a = [1,2,3]\na.toString()  // 1,2,3 不接受参数，带, 不同于join,'1-2-3'\n\nresult: '1,2,3' 不改变原数组， 返回字符串\n```\n\n### 13. valueOf() 方法返回 Array 对象的原始值。\n\n```js\nvar a = ['1', '2', '3']\na.valueOf() \n\nresult: [\"1\", \"2\", \"3\"] \n```\n### 14. toLocaleString() 把数组转换为本地字符串.\n\n```js\nvar a = ['1', '2', '3', 'a']\na.toLocaleString() \n\nresult: \"1,2,3,a\"  不改变原数组\n```\n\n### 15. indexOf()从数组开头开始查找所在项的位置,lastIndexOf() 从数组末尾开始向前查找\n\n> 比较参数和数组中每一项时，使用全等操作符。=== 没有找到时返回-1\n\n### 参考链接\n\n[MDN Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array)\n\n[SegmentFault](https://segmentfault.com/a/1190000005029014)\n\n[阮一峰 ECMAScript 6 入门 Array](http://es6.ruanyifeng.com/#docs/array)\n\n","source":"_posts/javascript/js数组.md","raw":"---\ntitle: js数组\ncategories:\n  - 前端技术\ntags:\n  - js\ndate: 2018-05-07 11:03:28\n---\n\n> javascript数组的方法，包含es6，Array 对象用于在单个的变量中存储多个值。\n\n<!-- more -->\n\n创建 Array 对象的语法：\n\n```js\nnew Array();\nnew Array(size);\nnew Array(element0, element1, ..., elementn);\n```\n![for example](/img/js/array1.png);\n\n### 1. concat() 方法用于连接两个或多个数组\n\n该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本\n\n```js\nvar a = [1,2,3]\nvar b = [4,5,6]\na.concat(b)\n\nresult: 返回新数组 [1,2,3,4,5,6]  a = [1,2,3]  b = [3,4,5]\n```\n\n### 2. join() 方法用于把数组中的所有元素放入一个字符串。\n\n元素是通过指定的分隔符进行分隔的。\n\n```js\nvar a = [1,2,3]\na.join('-')\n\nresult: 返回新string '1-2-3'   a = [1,2,3]\n```\n\n### 3. pop() 方法用于删除并返回数组的最后一个元素。\n\n```js\nvar a = [1,2,3]\na.pop()\n\nresult: [1,2]    a = [1,2] (被改变) 返回被删除的值\n```\n### 4. push() 方法用于添加元素，返回push的最后一个值。\n\n```js\nvar a = [1,2,3]\na.push(4,5,6)\n\nresult: [1,2,3,4,5,6]    a = [1,2,3,4,5,6] (被改变) 返回push的最后一个值\n```\n\n### 5. reverse() 方法用于颠倒数组中元素的顺序。\n\n```js\nvar a = [1,2,3]\na.reverse()\n\nresult: [3,2,1]    a = [3,2,1] (被改变) 返回颠倒数组\n```\n### 6. shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。\n\n```js\nvar a = [1,2,3]\na.shift()\n\nresult: [2,3]    a = [2,3] (被改变) 返回第一个元素的值 1\n```\n### 7. unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。\n\n```js\nvar a = [1,2,3]\na.unshift(0,9)\n\nresult [0,9,1,2,3]  a = [0,9,1,2,3] (被改变) 返回数组的长度 6\n```\n\n### 8. slice() 方法可从已有的数组中返回选定的元素。\n\n```js\nvar a = [1,2,3]\na.slice(0,2)\n\nresult [1,2]  a = [1,2,3] 返回截取的数组 [1,2], 和splice()不同，splice会改变原数组\n```\n\n### 9. sort() 方法用于对数组的元素进行排序。\n\n```js\nvar a = [6,9,1]\nvar b = [1, 5, 10, 25, 40, 1000]\na.sort()\nb.sort()  // 1, 10, 1000, 25, 40, 5(说明)\nfunction sortNumber(a,b) {\n    return a - b\n    }\nb.sort(sortNumber) //right\n\nresult [1,6,9]  a = [1,6,9] (被改变) 返回排序后的数组\n\n```\n\nps : 说明\n\n如果调用该方法时没有使用参数，将按 **字母** 顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。\n\n如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：\n\n若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。\n若 a 等于 b，则返回 0。\n若 a 大于 b，则返回一个大于 0 的值。\n\n### 10. splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。该方法会改变原始数组\n\n```js\nvar a = [1,2,3]\na.splice(0,0,4)  \n//1.规定添加/删除项目的位置，使用负数可从数组结尾处规定位置\n//2.要删除的项目数量。如果设置为 0，则不会删除项目\n//3.可选。向数组添加的新项目。\nresult [4,1,2,3]  a = [4,1,2,3] (被改变) 返回选取的数组\n```\n### 11. splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。该方法会改变原始数组\n\n```js\nvar a = [1,2,3]\na.splice(0,0,4)  \n//1.规定添加/删除项目的位置，使用负数可从数组结尾处规定位置\n//2.要删除的项目数量。如果设置为 0，则不会删除项目\n//3.可选。向数组添加的新项目。\nresult [4,1,2,3]  a = [4,1,2,3] (被改变) 返回选取的数组\n```\n\n### 11. toSource()方法表示对象的源代码\n\n```js\nfunction employee(name,job,born)\n    {\n    this.name=name;\n    this.job=job;\n    this.born=born;\n}\n\nvar bill=new employee(\"Bill Gates\",\"Engineer\",1985);\ndocument.write(bill.toSource());\n//只有 Gecko 核心的浏览器（比如 Firefox）支持该方法，也就是说 IE、Safari、Chrome、Opera 等浏览器均不支持该方法。\n```\n\n### 12. toString() 方法可把数组转换为字符串，并返回结果。\n\n```js\nvar a = [1,2,3]\na.toString()  // 1,2,3 不接受参数，带, 不同于join,'1-2-3'\n\nresult: '1,2,3' 不改变原数组， 返回字符串\n```\n\n### 13. valueOf() 方法返回 Array 对象的原始值。\n\n```js\nvar a = ['1', '2', '3']\na.valueOf() \n\nresult: [\"1\", \"2\", \"3\"] \n```\n### 14. toLocaleString() 把数组转换为本地字符串.\n\n```js\nvar a = ['1', '2', '3', 'a']\na.toLocaleString() \n\nresult: \"1,2,3,a\"  不改变原数组\n```\n\n### 15. indexOf()从数组开头开始查找所在项的位置,lastIndexOf() 从数组末尾开始向前查找\n\n> 比较参数和数组中每一项时，使用全等操作符。=== 没有找到时返回-1\n\n### 参考链接\n\n[MDN Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array)\n\n[SegmentFault](https://segmentfault.com/a/1190000005029014)\n\n[阮一峰 ECMAScript 6 入门 Array](http://es6.ruanyifeng.com/#docs/array)\n\n","slug":"javascript/js数组","published":1,"updated":"2018-05-31T10:27:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3d40009uox17g2xpreh","content":"<blockquote>\n<p>javascript数组的方法，包含es6，Array 对象用于在单个的变量中存储多个值。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>创建 Array 对象的语法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(size);</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(element0, element1, ..., elementn);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/js/array1.png\" alt=\"for example\">;</p>\n<h3 id=\"1-concat-方法用于连接两个或多个数组\"><a href=\"#1-concat-方法用于连接两个或多个数组\" class=\"headerlink\" title=\"1. concat() 方法用于连接两个或多个数组\"></a>1. concat() 方法用于连接两个或多个数组</h3><p>该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\">a.concat(b)</span><br><span class=\"line\"></span><br><span class=\"line\">result: 返回新数组 [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]  a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]  b = [<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-join-方法用于把数组中的所有元素放入一个字符串。\"><a href=\"#2-join-方法用于把数组中的所有元素放入一个字符串。\" class=\"headerlink\" title=\"2. join() 方法用于把数组中的所有元素放入一个字符串。\"></a>2. join() 方法用于把数组中的所有元素放入一个字符串。</h3><p>元素是通过指定的分隔符进行分隔的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">a.join(<span class=\"string\">'-'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">result: 返回新string <span class=\"string\">'1-2-3'</span>   a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-pop-方法用于删除并返回数组的最后一个元素。\"><a href=\"#3-pop-方法用于删除并返回数组的最后一个元素。\" class=\"headerlink\" title=\"3. pop() 方法用于删除并返回数组的最后一个元素。\"></a>3. pop() 方法用于删除并返回数组的最后一个元素。</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">a.pop()</span><br><span class=\"line\"></span><br><span class=\"line\">result: [<span class=\"number\">1</span>,<span class=\"number\">2</span>]    a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>] (被改变) 返回被删除的值</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-push-方法用于添加元素，返回push的最后一个值。\"><a href=\"#4-push-方法用于添加元素，返回push的最后一个值。\" class=\"headerlink\" title=\"4. push() 方法用于添加元素，返回push的最后一个值。\"></a>4. push() 方法用于添加元素，返回push的最后一个值。</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">a.push(<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">result: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]    a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>] (被改变) 返回push的最后一个值</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-reverse-方法用于颠倒数组中元素的顺序。\"><a href=\"#5-reverse-方法用于颠倒数组中元素的顺序。\" class=\"headerlink\" title=\"5. reverse() 方法用于颠倒数组中元素的顺序。\"></a>5. reverse() 方法用于颠倒数组中元素的顺序。</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">a.reverse()</span><br><span class=\"line\"></span><br><span class=\"line\">result: [<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]    a = [<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>] (被改变) 返回颠倒数组</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-shift-方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。\"><a href=\"#6-shift-方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。\" class=\"headerlink\" title=\"6. shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。\"></a>6. shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">a.shift()</span><br><span class=\"line\"></span><br><span class=\"line\">result: [<span class=\"number\">2</span>,<span class=\"number\">3</span>]    a = [<span class=\"number\">2</span>,<span class=\"number\">3</span>] (被改变) 返回第一个元素的值 <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"7-unshift-方法可向数组的开头添加一个或更多元素，并返回新的长度。\"><a href=\"#7-unshift-方法可向数组的开头添加一个或更多元素，并返回新的长度。\" class=\"headerlink\" title=\"7. unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。\"></a>7. unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">a.unshift(<span class=\"number\">0</span>,<span class=\"number\">9</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">result [<span class=\"number\">0</span>,<span class=\"number\">9</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]  a = [<span class=\"number\">0</span>,<span class=\"number\">9</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] (被改变) 返回数组的长度 <span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"8-slice-方法可从已有的数组中返回选定的元素。\"><a href=\"#8-slice-方法可从已有的数组中返回选定的元素。\" class=\"headerlink\" title=\"8. slice() 方法可从已有的数组中返回选定的元素。\"></a>8. slice() 方法可从已有的数组中返回选定的元素。</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">a.slice(<span class=\"number\">0</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">result [<span class=\"number\">1</span>,<span class=\"number\">2</span>]  a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] 返回截取的数组 [<span class=\"number\">1</span>,<span class=\"number\">2</span>], 和splice()不同，splice会改变原数组</span><br></pre></td></tr></table></figure>\n<h3 id=\"9-sort-方法用于对数组的元素进行排序。\"><a href=\"#9-sort-方法用于对数组的元素进行排序。\" class=\"headerlink\" title=\"9. sort() 方法用于对数组的元素进行排序。\"></a>9. sort() 方法用于对数组的元素进行排序。</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">6</span>,<span class=\"number\">9</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">25</span>, <span class=\"number\">40</span>, <span class=\"number\">1000</span>]</span><br><span class=\"line\">a.sort()</span><br><span class=\"line\">b.sort()  <span class=\"comment\">// 1, 10, 1000, 25, 40, 5(说明)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sortNumber</span>(<span class=\"params\">a,b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a - b</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">b.sort(sortNumber) <span class=\"comment\">//right</span></span><br><span class=\"line\"></span><br><span class=\"line\">result [<span class=\"number\">1</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>]  a = [<span class=\"number\">1</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>] (被改变) 返回排序后的数组</span><br></pre></td></tr></table></figure>\n<p>ps : 说明</p>\n<p>如果调用该方法时没有使用参数，将按 <strong>字母</strong> 顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。</p>\n<p>如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：</p>\n<p>若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。<br>若 a 等于 b，则返回 0。<br>若 a 大于 b，则返回一个大于 0 的值。</p>\n<h3 id=\"10-splice-方法向-从数组中添加-删除项目，然后返回被删除的项目。该方法会改变原始数组\"><a href=\"#10-splice-方法向-从数组中添加-删除项目，然后返回被删除的项目。该方法会改变原始数组\" class=\"headerlink\" title=\"10. splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。该方法会改变原始数组\"></a>10. splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。该方法会改变原始数组</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">a.splice(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">4</span>)  </span><br><span class=\"line\"><span class=\"comment\">//1.规定添加/删除项目的位置，使用负数可从数组结尾处规定位置</span></span><br><span class=\"line\"><span class=\"comment\">//2.要删除的项目数量。如果设置为 0，则不会删除项目</span></span><br><span class=\"line\"><span class=\"comment\">//3.可选。向数组添加的新项目。</span></span><br><span class=\"line\">result [<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]  a = [<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] (被改变) 返回选取的数组</span><br></pre></td></tr></table></figure>\n<h3 id=\"11-splice-方法向-从数组中添加-删除项目，然后返回被删除的项目。该方法会改变原始数组\"><a href=\"#11-splice-方法向-从数组中添加-删除项目，然后返回被删除的项目。该方法会改变原始数组\" class=\"headerlink\" title=\"11. splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。该方法会改变原始数组\"></a>11. splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。该方法会改变原始数组</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">a.splice(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">4</span>)  </span><br><span class=\"line\"><span class=\"comment\">//1.规定添加/删除项目的位置，使用负数可从数组结尾处规定位置</span></span><br><span class=\"line\"><span class=\"comment\">//2.要删除的项目数量。如果设置为 0，则不会删除项目</span></span><br><span class=\"line\"><span class=\"comment\">//3.可选。向数组添加的新项目。</span></span><br><span class=\"line\">result [<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]  a = [<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] (被改变) 返回选取的数组</span><br></pre></td></tr></table></figure>\n<h3 id=\"11-toSource-方法表示对象的源代码\"><a href=\"#11-toSource-方法表示对象的源代码\" class=\"headerlink\" title=\"11. toSource()方法表示对象的源代码\"></a>11. toSource()方法表示对象的源代码</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">employee</span>(<span class=\"params\">name,job,born</span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.job=job;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.born=born;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bill=<span class=\"keyword\">new</span> employee(<span class=\"string\">\"Bill Gates\"</span>,<span class=\"string\">\"Engineer\"</span>,<span class=\"number\">1985</span>);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(bill.toSource());</span><br><span class=\"line\"><span class=\"comment\">//只有 Gecko 核心的浏览器（比如 Firefox）支持该方法，也就是说 IE、Safari、Chrome、Opera 等浏览器均不支持该方法。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"12-toString-方法可把数组转换为字符串，并返回结果。\"><a href=\"#12-toString-方法可把数组转换为字符串，并返回结果。\" class=\"headerlink\" title=\"12. toString() 方法可把数组转换为字符串，并返回结果。\"></a>12. toString() 方法可把数组转换为字符串，并返回结果。</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">a.toString()  <span class=\"comment\">// 1,2,3 不接受参数，带, 不同于join,'1-2-3'</span></span><br><span class=\"line\"></span><br><span class=\"line\">result: <span class=\"string\">'1,2,3'</span> 不改变原数组， 返回字符串</span><br></pre></td></tr></table></figure>\n<h3 id=\"13-valueOf-方法返回-Array-对象的原始值。\"><a href=\"#13-valueOf-方法返回-Array-对象的原始值。\" class=\"headerlink\" title=\"13. valueOf() 方法返回 Array 对象的原始值。\"></a>13. valueOf() 方法返回 Array 对象的原始值。</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>, <span class=\"string\">'3'</span>]</span><br><span class=\"line\">a.valueOf() </span><br><span class=\"line\"></span><br><span class=\"line\">result: [<span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"14-toLocaleString-把数组转换为本地字符串\"><a href=\"#14-toLocaleString-把数组转换为本地字符串\" class=\"headerlink\" title=\"14. toLocaleString() 把数组转换为本地字符串.\"></a>14. toLocaleString() 把数组转换为本地字符串.</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>, <span class=\"string\">'3'</span>, <span class=\"string\">'a'</span>]</span><br><span class=\"line\">a.toLocaleString() </span><br><span class=\"line\"></span><br><span class=\"line\">result: <span class=\"string\">\"1,2,3,a\"</span>  不改变原数组</span><br></pre></td></tr></table></figure>\n<h3 id=\"15-indexOf-从数组开头开始查找所在项的位置-lastIndexOf-从数组末尾开始向前查找\"><a href=\"#15-indexOf-从数组开头开始查找所在项的位置-lastIndexOf-从数组末尾开始向前查找\" class=\"headerlink\" title=\"15. indexOf()从数组开头开始查找所在项的位置,lastIndexOf() 从数组末尾开始向前查找\"></a>15. indexOf()从数组开头开始查找所在项的位置,lastIndexOf() 从数组末尾开始向前查找</h3><blockquote>\n<p>比较参数和数组中每一项时，使用全等操作符。=== 没有找到时返回-1</p>\n</blockquote>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\" target=\"_blank\" rel=\"noopener\">MDN Array</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000005029014\" target=\"_blank\" rel=\"noopener\">SegmentFault</a></p>\n<p><a href=\"http://es6.ruanyifeng.com/#docs/array\" target=\"_blank\" rel=\"noopener\">阮一峰 ECMAScript 6 入门 Array</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>javascript数组的方法，包含es6，Array 对象用于在单个的变量中存储多个值。</p>\n</blockquote>","more":"<p>创建 Array 对象的语法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(size);</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(element0, element1, ..., elementn);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/js/array1.png\" alt=\"for example\">;</p>\n<h3 id=\"1-concat-方法用于连接两个或多个数组\"><a href=\"#1-concat-方法用于连接两个或多个数组\" class=\"headerlink\" title=\"1. concat() 方法用于连接两个或多个数组\"></a>1. concat() 方法用于连接两个或多个数组</h3><p>该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\">a.concat(b)</span><br><span class=\"line\"></span><br><span class=\"line\">result: 返回新数组 [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]  a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]  b = [<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-join-方法用于把数组中的所有元素放入一个字符串。\"><a href=\"#2-join-方法用于把数组中的所有元素放入一个字符串。\" class=\"headerlink\" title=\"2. join() 方法用于把数组中的所有元素放入一个字符串。\"></a>2. join() 方法用于把数组中的所有元素放入一个字符串。</h3><p>元素是通过指定的分隔符进行分隔的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">a.join(<span class=\"string\">'-'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">result: 返回新string <span class=\"string\">'1-2-3'</span>   a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-pop-方法用于删除并返回数组的最后一个元素。\"><a href=\"#3-pop-方法用于删除并返回数组的最后一个元素。\" class=\"headerlink\" title=\"3. pop() 方法用于删除并返回数组的最后一个元素。\"></a>3. pop() 方法用于删除并返回数组的最后一个元素。</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">a.pop()</span><br><span class=\"line\"></span><br><span class=\"line\">result: [<span class=\"number\">1</span>,<span class=\"number\">2</span>]    a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>] (被改变) 返回被删除的值</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-push-方法用于添加元素，返回push的最后一个值。\"><a href=\"#4-push-方法用于添加元素，返回push的最后一个值。\" class=\"headerlink\" title=\"4. push() 方法用于添加元素，返回push的最后一个值。\"></a>4. push() 方法用于添加元素，返回push的最后一个值。</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">a.push(<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">result: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]    a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>] (被改变) 返回push的最后一个值</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-reverse-方法用于颠倒数组中元素的顺序。\"><a href=\"#5-reverse-方法用于颠倒数组中元素的顺序。\" class=\"headerlink\" title=\"5. reverse() 方法用于颠倒数组中元素的顺序。\"></a>5. reverse() 方法用于颠倒数组中元素的顺序。</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">a.reverse()</span><br><span class=\"line\"></span><br><span class=\"line\">result: [<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]    a = [<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>] (被改变) 返回颠倒数组</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-shift-方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。\"><a href=\"#6-shift-方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。\" class=\"headerlink\" title=\"6. shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。\"></a>6. shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">a.shift()</span><br><span class=\"line\"></span><br><span class=\"line\">result: [<span class=\"number\">2</span>,<span class=\"number\">3</span>]    a = [<span class=\"number\">2</span>,<span class=\"number\">3</span>] (被改变) 返回第一个元素的值 <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"7-unshift-方法可向数组的开头添加一个或更多元素，并返回新的长度。\"><a href=\"#7-unshift-方法可向数组的开头添加一个或更多元素，并返回新的长度。\" class=\"headerlink\" title=\"7. unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。\"></a>7. unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">a.unshift(<span class=\"number\">0</span>,<span class=\"number\">9</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">result [<span class=\"number\">0</span>,<span class=\"number\">9</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]  a = [<span class=\"number\">0</span>,<span class=\"number\">9</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] (被改变) 返回数组的长度 <span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"8-slice-方法可从已有的数组中返回选定的元素。\"><a href=\"#8-slice-方法可从已有的数组中返回选定的元素。\" class=\"headerlink\" title=\"8. slice() 方法可从已有的数组中返回选定的元素。\"></a>8. slice() 方法可从已有的数组中返回选定的元素。</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">a.slice(<span class=\"number\">0</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">result [<span class=\"number\">1</span>,<span class=\"number\">2</span>]  a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] 返回截取的数组 [<span class=\"number\">1</span>,<span class=\"number\">2</span>], 和splice()不同，splice会改变原数组</span><br></pre></td></tr></table></figure>\n<h3 id=\"9-sort-方法用于对数组的元素进行排序。\"><a href=\"#9-sort-方法用于对数组的元素进行排序。\" class=\"headerlink\" title=\"9. sort() 方法用于对数组的元素进行排序。\"></a>9. sort() 方法用于对数组的元素进行排序。</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">6</span>,<span class=\"number\">9</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">25</span>, <span class=\"number\">40</span>, <span class=\"number\">1000</span>]</span><br><span class=\"line\">a.sort()</span><br><span class=\"line\">b.sort()  <span class=\"comment\">// 1, 10, 1000, 25, 40, 5(说明)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sortNumber</span>(<span class=\"params\">a,b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a - b</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">b.sort(sortNumber) <span class=\"comment\">//right</span></span><br><span class=\"line\"></span><br><span class=\"line\">result [<span class=\"number\">1</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>]  a = [<span class=\"number\">1</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>] (被改变) 返回排序后的数组</span><br></pre></td></tr></table></figure>\n<p>ps : 说明</p>\n<p>如果调用该方法时没有使用参数，将按 <strong>字母</strong> 顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。</p>\n<p>如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：</p>\n<p>若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。<br>若 a 等于 b，则返回 0。<br>若 a 大于 b，则返回一个大于 0 的值。</p>\n<h3 id=\"10-splice-方法向-从数组中添加-删除项目，然后返回被删除的项目。该方法会改变原始数组\"><a href=\"#10-splice-方法向-从数组中添加-删除项目，然后返回被删除的项目。该方法会改变原始数组\" class=\"headerlink\" title=\"10. splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。该方法会改变原始数组\"></a>10. splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。该方法会改变原始数组</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">a.splice(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">4</span>)  </span><br><span class=\"line\"><span class=\"comment\">//1.规定添加/删除项目的位置，使用负数可从数组结尾处规定位置</span></span><br><span class=\"line\"><span class=\"comment\">//2.要删除的项目数量。如果设置为 0，则不会删除项目</span></span><br><span class=\"line\"><span class=\"comment\">//3.可选。向数组添加的新项目。</span></span><br><span class=\"line\">result [<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]  a = [<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] (被改变) 返回选取的数组</span><br></pre></td></tr></table></figure>\n<h3 id=\"11-splice-方法向-从数组中添加-删除项目，然后返回被删除的项目。该方法会改变原始数组\"><a href=\"#11-splice-方法向-从数组中添加-删除项目，然后返回被删除的项目。该方法会改变原始数组\" class=\"headerlink\" title=\"11. splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。该方法会改变原始数组\"></a>11. splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。该方法会改变原始数组</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">a.splice(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">4</span>)  </span><br><span class=\"line\"><span class=\"comment\">//1.规定添加/删除项目的位置，使用负数可从数组结尾处规定位置</span></span><br><span class=\"line\"><span class=\"comment\">//2.要删除的项目数量。如果设置为 0，则不会删除项目</span></span><br><span class=\"line\"><span class=\"comment\">//3.可选。向数组添加的新项目。</span></span><br><span class=\"line\">result [<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]  a = [<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] (被改变) 返回选取的数组</span><br></pre></td></tr></table></figure>\n<h3 id=\"11-toSource-方法表示对象的源代码\"><a href=\"#11-toSource-方法表示对象的源代码\" class=\"headerlink\" title=\"11. toSource()方法表示对象的源代码\"></a>11. toSource()方法表示对象的源代码</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">employee</span>(<span class=\"params\">name,job,born</span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.job=job;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.born=born;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bill=<span class=\"keyword\">new</span> employee(<span class=\"string\">\"Bill Gates\"</span>,<span class=\"string\">\"Engineer\"</span>,<span class=\"number\">1985</span>);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(bill.toSource());</span><br><span class=\"line\"><span class=\"comment\">//只有 Gecko 核心的浏览器（比如 Firefox）支持该方法，也就是说 IE、Safari、Chrome、Opera 等浏览器均不支持该方法。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"12-toString-方法可把数组转换为字符串，并返回结果。\"><a href=\"#12-toString-方法可把数组转换为字符串，并返回结果。\" class=\"headerlink\" title=\"12. toString() 方法可把数组转换为字符串，并返回结果。\"></a>12. toString() 方法可把数组转换为字符串，并返回结果。</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">a.toString()  <span class=\"comment\">// 1,2,3 不接受参数，带, 不同于join,'1-2-3'</span></span><br><span class=\"line\"></span><br><span class=\"line\">result: <span class=\"string\">'1,2,3'</span> 不改变原数组， 返回字符串</span><br></pre></td></tr></table></figure>\n<h3 id=\"13-valueOf-方法返回-Array-对象的原始值。\"><a href=\"#13-valueOf-方法返回-Array-对象的原始值。\" class=\"headerlink\" title=\"13. valueOf() 方法返回 Array 对象的原始值。\"></a>13. valueOf() 方法返回 Array 对象的原始值。</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>, <span class=\"string\">'3'</span>]</span><br><span class=\"line\">a.valueOf() </span><br><span class=\"line\"></span><br><span class=\"line\">result: [<span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"14-toLocaleString-把数组转换为本地字符串\"><a href=\"#14-toLocaleString-把数组转换为本地字符串\" class=\"headerlink\" title=\"14. toLocaleString() 把数组转换为本地字符串.\"></a>14. toLocaleString() 把数组转换为本地字符串.</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>, <span class=\"string\">'3'</span>, <span class=\"string\">'a'</span>]</span><br><span class=\"line\">a.toLocaleString() </span><br><span class=\"line\"></span><br><span class=\"line\">result: <span class=\"string\">\"1,2,3,a\"</span>  不改变原数组</span><br></pre></td></tr></table></figure>\n<h3 id=\"15-indexOf-从数组开头开始查找所在项的位置-lastIndexOf-从数组末尾开始向前查找\"><a href=\"#15-indexOf-从数组开头开始查找所在项的位置-lastIndexOf-从数组末尾开始向前查找\" class=\"headerlink\" title=\"15. indexOf()从数组开头开始查找所在项的位置,lastIndexOf() 从数组末尾开始向前查找\"></a>15. indexOf()从数组开头开始查找所在项的位置,lastIndexOf() 从数组末尾开始向前查找</h3><blockquote>\n<p>比较参数和数组中每一项时，使用全等操作符。=== 没有找到时返回-1</p>\n</blockquote>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\" target=\"_blank\" rel=\"noopener\">MDN Array</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000005029014\" target=\"_blank\" rel=\"noopener\">SegmentFault</a></p>\n<p><a href=\"http://es6.ruanyifeng.com/#docs/array\" target=\"_blank\" rel=\"noopener\">阮一峰 ECMAScript 6 入门 Array</a></p>"},{"title":"js继承","date":"2017-11-05T13:49:20.000Z","_content":"\n> 每个类都有三个部分组成\n\n* 构造函数内的，供实例对象复制用的\n* 构造函数外的，直接通过点语法添加的，这是供类使用的，实例对象访问不到\n* 类的原型中的，实例化对象可以通过其原型链间接的访问到，也是为供所有实例化对象所共有\n\n<!--- more -->\n\n### 子类的原型继承---类式继承\n\n> 类式继承需要将第一个类的实例赋值给第二个类的原型\n\n```javascript\n// 父类\nfunction SuperClass() {\n    this.SuperValue = true;\n}\n// 为父类原型添加方法\nSuperClass.prototype.getSuperValue = function() {\n    // alert(1)\n    return this.SuperValue;\n}\n// console.dir(SuperClass);\nvar supe = new SuperClass();\n// console.dir(supe);\n// supe.getSuperValue();\n// 声明子类\nfunction SubClass() {\n    this.subValue = false;\n}\n// 子类继承父类\nSubClass.prototype = new SuperClass();\n// 为子类添加共有方法\nSubClass.prototype.getSubValue = function() {\n    // alert(2);\n    return this.subValue;\n}\n// console.dir(SubClass);\n// 子类继承父类SuperValue属性，\n// 访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找，这就是原型链。\nvar sub = new SubClass();\n// sub.getSuperValue();\n// sub.getSubValue();\n// console.log(sub.SuperValue);\n// console.log(sub.subValue);\n// console.dir(sub);\n\n```\n\n> 为什么这样做？？？\n\n类的原型对象的作用就是为类的原型添加共有方法，但是累不能直接访问这些属性和方法，必须通过prototype来访问。\n\n我们在实例化一个父类的时候，新创建的对象复制了父类的构造函数内的属性和方法并且将隐氏原型_proto_指向父类的原型对象，这样就拥有了父类的原型对象上的方法和属性。\n\n如果将新创建的对象赋值给子类的原型，那么子类的原型就可以访问到父类的原型上的属性和方法，同样也可以访问从父类构造函数中复制的属性和方法，同样子类也可以访问父类原型上的属性和方法与父类构造函数中复制的属性和方法。\n\n> 检测继承关系\n\ninstanceof通过判断对象的_proto_与构造函数的prototype，来确定这个对象是否是某个类的实例，而不关心对象与类的自身结构\n\n```javascript\nconsole.log(sub instanceof SubClass);         //true\nconsole.log(sub instanceof SuperClass);       //true\nconsole.log(SubClass instanceof SuperClass);  //false\n\n// why false??\n// instanceof 是判断前面的对象是否是后面类的实例，他并不表示两者的继承，\nconsole.log(SubClass.prototype instanceof SuperClass); //true\n\n```\n\n> 类式继承的缺点\n\n* 由于子类通过其原型Prototype对父类实例化，继承了父类，所以说父类中的共有属性要是引用类型，就会在子类中被所有属性共有，因此一个子类的实例更改子类原型从父类构造函数中继承来的共有属性就会直接影响到其他子类\n\n```javascript\nfunction SuperClass() {\n    this.books = ['javascript', 'html', 'css']\n    this.a = 12\n}\nfunction SubClass() {}\nSubClass.prototype = new SuperClass()\nvar instance1 = new SubClass()\nvar instance2 = new SubClass()\nconsole.log(instance2.books)\ninstance1.books.push('设计模式')\ninstance1.a = 34\nconsole.log(instance2.books)\nconsole.log(instance2.a)\n```\n* 由于子类实现的继承是靠原型prototype对付类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的，因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化。\n\n### 创建即继承---构造函数继承\n\n```javascript\n// 构造函数继承\n// 声明父类\nfunction SuperClass(id) {\n    this.books = ['javascript', 'html', 'css'];\n    this.id = id;\n}\n// 父类声明原型\nSuperClass.prototype.showBooks = function() {\n    console.log(this.books);\n}\n// 声明子类\nfunction SubClass(id) {\n    // 继承父类\n    SuperClass.call(this, id);\n}\n// 创建第一个子类的实例\nvar instance1 = new SubClass(11);\n// 创建第二个子类的实例\nvar instance2 = new SubClass(22);\n// 验证\ninstance1.books.push('设计模式');\nconsole.log(instance1.books);\nconsole.log(instance2.books);\nconsole.log(instance1.id);\nconsole.log(instance2.id);\n\n```\n> 继承原理\n\n* 由于call这个方法可以更改函数的作用域，因此在子类中，对superClass调用这个方法就是将子类中的变量在父类中执行一遍。\n\n* 由于父类中是=给this绑定属性的，因此子类自然也就继承了父类的共有属性\n\n* 由于这种类型的继承没有涉及原型prototype，所以父类的原型方法自然不会被子类继承\n\n> 每个函数都包含两个非继承而来的方法：call()方法和apply()方法。\n\n* 相同点：这两个方法的作用是一样的。\n\n都是在特定的作用域中调用函数，等于设置函数体内this对象的值，以扩充函数赖以运行的作用域。\n\n一般来说，this总是指向调用某个方法的对象，但是使用call()和apply()方法时，就会改变this的指向。\n\n* 不同点：接收参数的方式不同。\n\napply()方法 接收两个参数，一个是函数运行的作用域（this），另一个是参数数组。\n\n### 将有点为我所用---组合继承 \n\n#### 总结前面两种特点\n\n> 类式继承式通过子类的原型prototype对父类实例化来实现的。\n\n> 构造函数式继承式通过在子类的构造函数作用环境中执行一次父类的构造函数来实现。\n\n```javascript\n// 组合式继承\n// 声明父类\n\nfunction SuperClass(name) {\n    this.name = name;\n    this,boob = ['html', 'css', 'javascript'];\n}\n// 父类原型共有方法\nSuperClass.prototype.getName = function() {\n    console.log(this.name);\n}\n// 声明子类\nfunction SubClass(name, time) {\n    // 构造函数式继承父类name 属性\n    SuperClass.call(this, name);\n    // 子类中新增共有属性\n    this.time = time;\n}\n// 类式继承  子类原型继承父类\nSubClass.prototype = new SuperClass();\n// 子类原型方法\nSubClass.prototype.getTime = function() {\n    console.log(this.time);\n}\n// 测试\nvar instance1 = new SubClass('js book', 2017);\ninstance1.books.push('设计模式');\nconsole.log(instance1.books);\ninstance1.getName();\ninstance1.getTime();\nvar instance2 = new SubClass('css book', 2018);\nconsole.log(instance2.books);\ninstance2.getName();\ninstance2.getTime();\n\n```\n> 结合了类式继承和构造函数继承两种方式的优点\n\n> 不足之处\n\n在使用构造函数继承时执行了一遍父类的构造函数，而在实现子类原型的类式继承式又调用了一遍父类的构造函数。因此父类构造函数调用了两遍。\n\n### 洁净的继承者---原型式继承\n\n```javascript\nfunction inheritObject(o) {\n    // 声明一个过渡函数对象\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\n```\n> 和类式继承有点像？？\n\n对，是对类式继承的一个封装，过渡对象相当于类式继承中的子类，只不过在原型式继承中作为一个过渡对象出现的，目的是为了创建要返回的新的实例化对象。\n\n> ??是不是类式继承中的问题在这里也会出现？？？\n\n是的，！！！，不过这种方式由于F过渡类的构造函数中无内容，所以开销比较小，使用起来也比较方便，\n\n```javascript\nvar book = {\n    name: 'js book',\n    alikeBook: ['css book', 'html book']\n}\nvar newBook = inheritObject(book)\nnewBook.name = 'ajax book'\nnewBook.alikeBook.push('xml books')\n\nvar otherBook = inheritObject(book)\notherBook.name = 'flash book'\notherBook.alikeBook.push('as books')\nconsole.log(newBook.name)\nconsole.log(newBook.alikeBook)\n\nconsole.log(otherBook.name)\nconsole.log(otherBook.alikeBook)\n\nconsole.log(book.name)\nconsole.log(book.alikeBook)\n```\n\n和类式继承一样，父类对象book中的值类型的属性被复制，引用类型的属性被共用。\n\n### 如虎添翼---寄生式继承\n\n\n```javascript\n// 寄生式继承\n// 声明基对象\nvar book = {\n    name: 'js book',\n    alikeBook: ['css book', 'html book']\n}\nfunction inheritObject(o) {\n    // 声明一个过渡函数对象\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\n// var c = new inheritObject(book);\n// console.log(c)\nfunction createBook(obj) {\n    // 通过原型继承方式创建新对象\n    var o = new inheritObject(obj)\n    // 拓展新对象\n    o.getName = function() {\n        console.log(name)\n    }\n    return o;\n}\n\nvar a1  = createBook(book)\nvar a2  = createBook(book)\na1.alikeBook.push('设计模式')\nconsole.log(a1.alikeBook)\nconsole.log(a2.alikeBook)\n```\n\n其实寄生式继承就是对原型继承的第二次封装，并且在第二次封装的过程中对继承的对象进行了扩展，这样新创建的对象不仅仅有父类中的属性和方法而且还添加了新的属性和方法。\n\n### 终极继承者---寄生组合式继承\n\n> 之前学习了组合继承，就是将类式继承通构造函数继承组合，这种方式存在的问题就是子类不是父类的实例，而子类的原型式父类的实例，因此才有了寄生组合式继承。是寄生式继承与构造函数继承的组合，但是这里寄生式继承有点特殊，这里他处理的不是对象，而是类的原型。\n\n```javascript\nfunction inheritObject(o) {\n    // 声明一个过渡函数对象\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\n\nfunction inheritPrototype(SubClass, SuperClass) {\n    // 复制一份父类的原型副本保存在变量中\n    var p = inheritObject(SuperClass.prototype);\n    // 修正因为重写子原型导致子类的constructor属性被修改\n    p.constructor = SubClass;\n    // 设置子类的原型\n    SubClass.prototype = p;\n}\n\n```\n\n> 在寄生组合式继承中，通过构造函数继承的属性和方法是没有问题的吗，这里主要探究通过寄生式继承重新继承父类的原型，我们需要继承的仅仅是父类的原型，不在需要调用父类的构造函数，换句话说，在构造函数继承中，我们已经调用了父类的构造函数，因此我们需要的就是父类的原型对象的一个副本，而这个副本我们我们通过原型继承便可得到，但是直接赋值个子类会有问题，因为对父类原型对象复制得到的复制对象p中的constroctor指向的不是SubClass子类对象，因此在寄生式继承中要对复制对象p做一次增强，修复其constroctor属性指向不正确问题，最后将得到的复制对象p赋值给子类的原型，这样子类的原型就继承了父类的原型并且没有执行父类的构造函数。\n\n```javascript\n// 寄生式继承  继承原型\n// 传递参数  SuperClass  父了\n// 传递参数  SubClass    子类\n\nfunction inheritObject(o) {\n    // 声明一个过渡函数对象\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\nfunction inheritPrototype(SubClass, SuperClass) {\n    // 复制一份父类的原型副本保存在变量中\n    var p = inheritObject(SuperClass.prototype);\n    // 修正因为重写子原型导致子类的constructor属性被修改\n    p.constructor = SubClass;\n    // 设置子类的原型\n    SubClass.prototype = p;\n} \nfunction SuperClass(name) {\n    this.name = name;\n    this.colors = ['red', 'blue', 'green']\n}\nSuperClass.prototype.getName = function() {\n    console.log(this.name)\n}\nfunction SubClass(name, time) {\n    // 构造函数继承\n    SuperClass.call(this, name)\n    this.time = time\n}\n// 寄生式继承父类原型\ninheritPrototype(SubClass, SuperClass)\nSubClass.prototype.getTime = function() {\n    console.log(this.time)\n}\n// 创建两个测试方法\nvar instance1 = new SubClass('js book', 2017);\nvar instance2 = new SubClass('css book', 2018);\n\ninstance1.colors.push('black')\nconsole.log(instance1.colors)\nconsole.log(instance2.colors)\ninstance2.getName();\ninstance2.getTime();\n\n```\n\n> 这中继承最大的改变就是对子类原型的处理，被赋予父类原型的一个应用，这是一个对象，因此有一点要注意，就是子类在想添加原型方法必须通过prototype对象，通过点语法的形式一个个添加方法了，否则直接赋予对象就会覆盖掉从父类原型继承的对象了。\n\n","source":"_posts/javascript/js继承.md","raw":"---\ntitle: js继承\ncategories:\n  - 前端技术\ntags:\n  - js\ndate: 2017-11-05 21:49:20\n---\n\n> 每个类都有三个部分组成\n\n* 构造函数内的，供实例对象复制用的\n* 构造函数外的，直接通过点语法添加的，这是供类使用的，实例对象访问不到\n* 类的原型中的，实例化对象可以通过其原型链间接的访问到，也是为供所有实例化对象所共有\n\n<!--- more -->\n\n### 子类的原型继承---类式继承\n\n> 类式继承需要将第一个类的实例赋值给第二个类的原型\n\n```javascript\n// 父类\nfunction SuperClass() {\n    this.SuperValue = true;\n}\n// 为父类原型添加方法\nSuperClass.prototype.getSuperValue = function() {\n    // alert(1)\n    return this.SuperValue;\n}\n// console.dir(SuperClass);\nvar supe = new SuperClass();\n// console.dir(supe);\n// supe.getSuperValue();\n// 声明子类\nfunction SubClass() {\n    this.subValue = false;\n}\n// 子类继承父类\nSubClass.prototype = new SuperClass();\n// 为子类添加共有方法\nSubClass.prototype.getSubValue = function() {\n    // alert(2);\n    return this.subValue;\n}\n// console.dir(SubClass);\n// 子类继承父类SuperValue属性，\n// 访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找，这就是原型链。\nvar sub = new SubClass();\n// sub.getSuperValue();\n// sub.getSubValue();\n// console.log(sub.SuperValue);\n// console.log(sub.subValue);\n// console.dir(sub);\n\n```\n\n> 为什么这样做？？？\n\n类的原型对象的作用就是为类的原型添加共有方法，但是累不能直接访问这些属性和方法，必须通过prototype来访问。\n\n我们在实例化一个父类的时候，新创建的对象复制了父类的构造函数内的属性和方法并且将隐氏原型_proto_指向父类的原型对象，这样就拥有了父类的原型对象上的方法和属性。\n\n如果将新创建的对象赋值给子类的原型，那么子类的原型就可以访问到父类的原型上的属性和方法，同样也可以访问从父类构造函数中复制的属性和方法，同样子类也可以访问父类原型上的属性和方法与父类构造函数中复制的属性和方法。\n\n> 检测继承关系\n\ninstanceof通过判断对象的_proto_与构造函数的prototype，来确定这个对象是否是某个类的实例，而不关心对象与类的自身结构\n\n```javascript\nconsole.log(sub instanceof SubClass);         //true\nconsole.log(sub instanceof SuperClass);       //true\nconsole.log(SubClass instanceof SuperClass);  //false\n\n// why false??\n// instanceof 是判断前面的对象是否是后面类的实例，他并不表示两者的继承，\nconsole.log(SubClass.prototype instanceof SuperClass); //true\n\n```\n\n> 类式继承的缺点\n\n* 由于子类通过其原型Prototype对父类实例化，继承了父类，所以说父类中的共有属性要是引用类型，就会在子类中被所有属性共有，因此一个子类的实例更改子类原型从父类构造函数中继承来的共有属性就会直接影响到其他子类\n\n```javascript\nfunction SuperClass() {\n    this.books = ['javascript', 'html', 'css']\n    this.a = 12\n}\nfunction SubClass() {}\nSubClass.prototype = new SuperClass()\nvar instance1 = new SubClass()\nvar instance2 = new SubClass()\nconsole.log(instance2.books)\ninstance1.books.push('设计模式')\ninstance1.a = 34\nconsole.log(instance2.books)\nconsole.log(instance2.a)\n```\n* 由于子类实现的继承是靠原型prototype对付类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的，因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化。\n\n### 创建即继承---构造函数继承\n\n```javascript\n// 构造函数继承\n// 声明父类\nfunction SuperClass(id) {\n    this.books = ['javascript', 'html', 'css'];\n    this.id = id;\n}\n// 父类声明原型\nSuperClass.prototype.showBooks = function() {\n    console.log(this.books);\n}\n// 声明子类\nfunction SubClass(id) {\n    // 继承父类\n    SuperClass.call(this, id);\n}\n// 创建第一个子类的实例\nvar instance1 = new SubClass(11);\n// 创建第二个子类的实例\nvar instance2 = new SubClass(22);\n// 验证\ninstance1.books.push('设计模式');\nconsole.log(instance1.books);\nconsole.log(instance2.books);\nconsole.log(instance1.id);\nconsole.log(instance2.id);\n\n```\n> 继承原理\n\n* 由于call这个方法可以更改函数的作用域，因此在子类中，对superClass调用这个方法就是将子类中的变量在父类中执行一遍。\n\n* 由于父类中是=给this绑定属性的，因此子类自然也就继承了父类的共有属性\n\n* 由于这种类型的继承没有涉及原型prototype，所以父类的原型方法自然不会被子类继承\n\n> 每个函数都包含两个非继承而来的方法：call()方法和apply()方法。\n\n* 相同点：这两个方法的作用是一样的。\n\n都是在特定的作用域中调用函数，等于设置函数体内this对象的值，以扩充函数赖以运行的作用域。\n\n一般来说，this总是指向调用某个方法的对象，但是使用call()和apply()方法时，就会改变this的指向。\n\n* 不同点：接收参数的方式不同。\n\napply()方法 接收两个参数，一个是函数运行的作用域（this），另一个是参数数组。\n\n### 将有点为我所用---组合继承 \n\n#### 总结前面两种特点\n\n> 类式继承式通过子类的原型prototype对父类实例化来实现的。\n\n> 构造函数式继承式通过在子类的构造函数作用环境中执行一次父类的构造函数来实现。\n\n```javascript\n// 组合式继承\n// 声明父类\n\nfunction SuperClass(name) {\n    this.name = name;\n    this,boob = ['html', 'css', 'javascript'];\n}\n// 父类原型共有方法\nSuperClass.prototype.getName = function() {\n    console.log(this.name);\n}\n// 声明子类\nfunction SubClass(name, time) {\n    // 构造函数式继承父类name 属性\n    SuperClass.call(this, name);\n    // 子类中新增共有属性\n    this.time = time;\n}\n// 类式继承  子类原型继承父类\nSubClass.prototype = new SuperClass();\n// 子类原型方法\nSubClass.prototype.getTime = function() {\n    console.log(this.time);\n}\n// 测试\nvar instance1 = new SubClass('js book', 2017);\ninstance1.books.push('设计模式');\nconsole.log(instance1.books);\ninstance1.getName();\ninstance1.getTime();\nvar instance2 = new SubClass('css book', 2018);\nconsole.log(instance2.books);\ninstance2.getName();\ninstance2.getTime();\n\n```\n> 结合了类式继承和构造函数继承两种方式的优点\n\n> 不足之处\n\n在使用构造函数继承时执行了一遍父类的构造函数，而在实现子类原型的类式继承式又调用了一遍父类的构造函数。因此父类构造函数调用了两遍。\n\n### 洁净的继承者---原型式继承\n\n```javascript\nfunction inheritObject(o) {\n    // 声明一个过渡函数对象\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\n```\n> 和类式继承有点像？？\n\n对，是对类式继承的一个封装，过渡对象相当于类式继承中的子类，只不过在原型式继承中作为一个过渡对象出现的，目的是为了创建要返回的新的实例化对象。\n\n> ??是不是类式继承中的问题在这里也会出现？？？\n\n是的，！！！，不过这种方式由于F过渡类的构造函数中无内容，所以开销比较小，使用起来也比较方便，\n\n```javascript\nvar book = {\n    name: 'js book',\n    alikeBook: ['css book', 'html book']\n}\nvar newBook = inheritObject(book)\nnewBook.name = 'ajax book'\nnewBook.alikeBook.push('xml books')\n\nvar otherBook = inheritObject(book)\notherBook.name = 'flash book'\notherBook.alikeBook.push('as books')\nconsole.log(newBook.name)\nconsole.log(newBook.alikeBook)\n\nconsole.log(otherBook.name)\nconsole.log(otherBook.alikeBook)\n\nconsole.log(book.name)\nconsole.log(book.alikeBook)\n```\n\n和类式继承一样，父类对象book中的值类型的属性被复制，引用类型的属性被共用。\n\n### 如虎添翼---寄生式继承\n\n\n```javascript\n// 寄生式继承\n// 声明基对象\nvar book = {\n    name: 'js book',\n    alikeBook: ['css book', 'html book']\n}\nfunction inheritObject(o) {\n    // 声明一个过渡函数对象\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\n// var c = new inheritObject(book);\n// console.log(c)\nfunction createBook(obj) {\n    // 通过原型继承方式创建新对象\n    var o = new inheritObject(obj)\n    // 拓展新对象\n    o.getName = function() {\n        console.log(name)\n    }\n    return o;\n}\n\nvar a1  = createBook(book)\nvar a2  = createBook(book)\na1.alikeBook.push('设计模式')\nconsole.log(a1.alikeBook)\nconsole.log(a2.alikeBook)\n```\n\n其实寄生式继承就是对原型继承的第二次封装，并且在第二次封装的过程中对继承的对象进行了扩展，这样新创建的对象不仅仅有父类中的属性和方法而且还添加了新的属性和方法。\n\n### 终极继承者---寄生组合式继承\n\n> 之前学习了组合继承，就是将类式继承通构造函数继承组合，这种方式存在的问题就是子类不是父类的实例，而子类的原型式父类的实例，因此才有了寄生组合式继承。是寄生式继承与构造函数继承的组合，但是这里寄生式继承有点特殊，这里他处理的不是对象，而是类的原型。\n\n```javascript\nfunction inheritObject(o) {\n    // 声明一个过渡函数对象\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\n\nfunction inheritPrototype(SubClass, SuperClass) {\n    // 复制一份父类的原型副本保存在变量中\n    var p = inheritObject(SuperClass.prototype);\n    // 修正因为重写子原型导致子类的constructor属性被修改\n    p.constructor = SubClass;\n    // 设置子类的原型\n    SubClass.prototype = p;\n}\n\n```\n\n> 在寄生组合式继承中，通过构造函数继承的属性和方法是没有问题的吗，这里主要探究通过寄生式继承重新继承父类的原型，我们需要继承的仅仅是父类的原型，不在需要调用父类的构造函数，换句话说，在构造函数继承中，我们已经调用了父类的构造函数，因此我们需要的就是父类的原型对象的一个副本，而这个副本我们我们通过原型继承便可得到，但是直接赋值个子类会有问题，因为对父类原型对象复制得到的复制对象p中的constroctor指向的不是SubClass子类对象，因此在寄生式继承中要对复制对象p做一次增强，修复其constroctor属性指向不正确问题，最后将得到的复制对象p赋值给子类的原型，这样子类的原型就继承了父类的原型并且没有执行父类的构造函数。\n\n```javascript\n// 寄生式继承  继承原型\n// 传递参数  SuperClass  父了\n// 传递参数  SubClass    子类\n\nfunction inheritObject(o) {\n    // 声明一个过渡函数对象\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\nfunction inheritPrototype(SubClass, SuperClass) {\n    // 复制一份父类的原型副本保存在变量中\n    var p = inheritObject(SuperClass.prototype);\n    // 修正因为重写子原型导致子类的constructor属性被修改\n    p.constructor = SubClass;\n    // 设置子类的原型\n    SubClass.prototype = p;\n} \nfunction SuperClass(name) {\n    this.name = name;\n    this.colors = ['red', 'blue', 'green']\n}\nSuperClass.prototype.getName = function() {\n    console.log(this.name)\n}\nfunction SubClass(name, time) {\n    // 构造函数继承\n    SuperClass.call(this, name)\n    this.time = time\n}\n// 寄生式继承父类原型\ninheritPrototype(SubClass, SuperClass)\nSubClass.prototype.getTime = function() {\n    console.log(this.time)\n}\n// 创建两个测试方法\nvar instance1 = new SubClass('js book', 2017);\nvar instance2 = new SubClass('css book', 2018);\n\ninstance1.colors.push('black')\nconsole.log(instance1.colors)\nconsole.log(instance2.colors)\ninstance2.getName();\ninstance2.getTime();\n\n```\n\n> 这中继承最大的改变就是对子类原型的处理，被赋予父类原型的一个应用，这是一个对象，因此有一点要注意，就是子类在想添加原型方法必须通过prototype对象，通过点语法的形式一个个添加方法了，否则直接赋予对象就会覆盖掉从父类原型继承的对象了。\n\n","slug":"javascript/js继承","published":1,"updated":"2018-05-31T10:27:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3d5000auox11zwzlt0b","content":"<blockquote>\n<p>每个类都有三个部分组成</p>\n</blockquote>\n<ul>\n<li>构造函数内的，供实例对象复制用的</li>\n<li>构造函数外的，直接通过点语法添加的，这是供类使用的，实例对象访问不到</li>\n<li>类的原型中的，实例化对象可以通过其原型链间接的访问到，也是为供所有实例化对象所共有</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"子类的原型继承—类式继承\"><a href=\"#子类的原型继承—类式继承\" class=\"headerlink\" title=\"子类的原型继承—类式继承\"></a>子类的原型继承—类式继承</h3><blockquote>\n<p>类式继承需要将第一个类的实例赋值给第二个类的原型</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperClass</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.SuperValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 为父类原型添加方法</span></span><br><span class=\"line\">SuperClass.prototype.getSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// alert(1)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.SuperValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// console.dir(SuperClass);</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> supe = <span class=\"keyword\">new</span> SuperClass();</span><br><span class=\"line\"><span class=\"comment\">// console.dir(supe);</span></span><br><span class=\"line\"><span class=\"comment\">// supe.getSuperValue();</span></span><br><span class=\"line\"><span class=\"comment\">// 声明子类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subValue = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 子类继承父类</span></span><br><span class=\"line\">SubClass.prototype = <span class=\"keyword\">new</span> SuperClass();</span><br><span class=\"line\"><span class=\"comment\">// 为子类添加共有方法</span></span><br><span class=\"line\">SubClass.prototype.getSubValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// alert(2);</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.subValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// console.dir(SubClass);</span></span><br><span class=\"line\"><span class=\"comment\">// 子类继承父类SuperValue属性，</span></span><br><span class=\"line\"><span class=\"comment\">// 访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找，这就是原型链。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sub = <span class=\"keyword\">new</span> SubClass();</span><br><span class=\"line\"><span class=\"comment\">// sub.getSuperValue();</span></span><br><span class=\"line\"><span class=\"comment\">// sub.getSubValue();</span></span><br><span class=\"line\"><span class=\"comment\">// console.log(sub.SuperValue);</span></span><br><span class=\"line\"><span class=\"comment\">// console.log(sub.subValue);</span></span><br><span class=\"line\"><span class=\"comment\">// console.dir(sub);</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>为什么这样做？？？</p>\n</blockquote>\n<p>类的原型对象的作用就是为类的原型添加共有方法，但是累不能直接访问这些属性和方法，必须通过prototype来访问。</p>\n<p>我们在实例化一个父类的时候，新创建的对象复制了父类的构造函数内的属性和方法并且将隐氏原型<em>proto</em>指向父类的原型对象，这样就拥有了父类的原型对象上的方法和属性。</p>\n<p>如果将新创建的对象赋值给子类的原型，那么子类的原型就可以访问到父类的原型上的属性和方法，同样也可以访问从父类构造函数中复制的属性和方法，同样子类也可以访问父类原型上的属性和方法与父类构造函数中复制的属性和方法。</p>\n<blockquote>\n<p>检测继承关系</p>\n</blockquote>\n<p>instanceof通过判断对象的<em>proto</em>与构造函数的prototype，来确定这个对象是否是某个类的实例，而不关心对象与类的自身结构</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(sub <span class=\"keyword\">instanceof</span> SubClass);         <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sub <span class=\"keyword\">instanceof</span> SuperClass);       <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(SubClass <span class=\"keyword\">instanceof</span> SuperClass);  <span class=\"comment\">//false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// why false??</span></span><br><span class=\"line\"><span class=\"comment\">// instanceof 是判断前面的对象是否是后面类的实例，他并不表示两者的继承，</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(SubClass.prototype <span class=\"keyword\">instanceof</span> SuperClass); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>类式继承的缺点</p>\n</blockquote>\n<ul>\n<li>由于子类通过其原型Prototype对父类实例化，继承了父类，所以说父类中的共有属性要是引用类型，就会在子类中被所有属性共有，因此一个子类的实例更改子类原型从父类构造函数中继承来的共有属性就会直接影响到其他子类</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperClass</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.books = [<span class=\"string\">'javascript'</span>, <span class=\"string\">'html'</span>, <span class=\"string\">'css'</span>]</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = <span class=\"number\">12</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">SubClass.prototype = <span class=\"keyword\">new</span> SuperClass()</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubClass()</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubClass()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.books)</span><br><span class=\"line\">instance1.books.push(<span class=\"string\">'设计模式'</span>)</span><br><span class=\"line\">instance1.a = <span class=\"number\">34</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.books)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.a)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>由于子类实现的继承是靠原型prototype对付类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的，因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化。</li>\n</ul>\n<h3 id=\"创建即继承—构造函数继承\"><a href=\"#创建即继承—构造函数继承\" class=\"headerlink\" title=\"创建即继承—构造函数继承\"></a>创建即继承—构造函数继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造函数继承</span></span><br><span class=\"line\"><span class=\"comment\">// 声明父类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperClass</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.books = [<span class=\"string\">'javascript'</span>, <span class=\"string\">'html'</span>, <span class=\"string\">'css'</span>];</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 父类声明原型</span></span><br><span class=\"line\">SuperClass.prototype.showBooks = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.books);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 声明子类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 继承父类</span></span><br><span class=\"line\">    SuperClass.call(<span class=\"keyword\">this</span>, id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 创建第一个子类的实例</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubClass(<span class=\"number\">11</span>);</span><br><span class=\"line\"><span class=\"comment\">// 创建第二个子类的实例</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubClass(<span class=\"number\">22</span>);</span><br><span class=\"line\"><span class=\"comment\">// 验证</span></span><br><span class=\"line\">instance1.books.push(<span class=\"string\">'设计模式'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.books);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.books);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.id);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.id);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>继承原理</p>\n</blockquote>\n<ul>\n<li><p>由于call这个方法可以更改函数的作用域，因此在子类中，对superClass调用这个方法就是将子类中的变量在父类中执行一遍。</p>\n</li>\n<li><p>由于父类中是=给this绑定属性的，因此子类自然也就继承了父类的共有属性</p>\n</li>\n<li><p>由于这种类型的继承没有涉及原型prototype，所以父类的原型方法自然不会被子类继承</p>\n</li>\n</ul>\n<blockquote>\n<p>每个函数都包含两个非继承而来的方法：call()方法和apply()方法。</p>\n</blockquote>\n<ul>\n<li>相同点：这两个方法的作用是一样的。</li>\n</ul>\n<p>都是在特定的作用域中调用函数，等于设置函数体内this对象的值，以扩充函数赖以运行的作用域。</p>\n<p>一般来说，this总是指向调用某个方法的对象，但是使用call()和apply()方法时，就会改变this的指向。</p>\n<ul>\n<li>不同点：接收参数的方式不同。</li>\n</ul>\n<p>apply()方法 接收两个参数，一个是函数运行的作用域（this），另一个是参数数组。</p>\n<h3 id=\"将有点为我所用—组合继承\"><a href=\"#将有点为我所用—组合继承\" class=\"headerlink\" title=\"将有点为我所用—组合继承\"></a>将有点为我所用—组合继承</h3><h4 id=\"总结前面两种特点\"><a href=\"#总结前面两种特点\" class=\"headerlink\" title=\"总结前面两种特点\"></a>总结前面两种特点</h4><blockquote>\n<p>类式继承式通过子类的原型prototype对父类实例化来实现的。</p>\n<p>构造函数式继承式通过在子类的构造函数作用环境中执行一次父类的构造函数来实现。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组合式继承</span></span><br><span class=\"line\"><span class=\"comment\">// 声明父类</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperClass</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>,boob = [<span class=\"string\">'html'</span>, <span class=\"string\">'css'</span>, <span class=\"string\">'javascript'</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 父类原型共有方法</span></span><br><span class=\"line\">SuperClass.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 声明子类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\">name, time</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数式继承父类name 属性</span></span><br><span class=\"line\">    SuperClass.call(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">    <span class=\"comment\">// 子类中新增共有属性</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.time = time;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 类式继承  子类原型继承父类</span></span><br><span class=\"line\">SubClass.prototype = <span class=\"keyword\">new</span> SuperClass();</span><br><span class=\"line\"><span class=\"comment\">// 子类原型方法</span></span><br><span class=\"line\">SubClass.prototype.getTime = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.time);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubClass(<span class=\"string\">'js book'</span>, <span class=\"number\">2017</span>);</span><br><span class=\"line\">instance1.books.push(<span class=\"string\">'设计模式'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.books);</span><br><span class=\"line\">instance1.getName();</span><br><span class=\"line\">instance1.getTime();</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubClass(<span class=\"string\">'css book'</span>, <span class=\"number\">2018</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.books);</span><br><span class=\"line\">instance2.getName();</span><br><span class=\"line\">instance2.getTime();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>结合了类式继承和构造函数继承两种方式的优点</p>\n<p>不足之处</p>\n</blockquote>\n<p>在使用构造函数继承时执行了一遍父类的构造函数，而在实现子类原型的类式继承式又调用了一遍父类的构造函数。因此父类构造函数调用了两遍。</p>\n<h3 id=\"洁净的继承者—原型式继承\"><a href=\"#洁净的继承者—原型式继承\" class=\"headerlink\" title=\"洁净的继承者—原型式继承\"></a>洁净的继承者—原型式继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritObject</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 声明一个过渡函数对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>和类式继承有点像？？</p>\n</blockquote>\n<p>对，是对类式继承的一个封装，过渡对象相当于类式继承中的子类，只不过在原型式继承中作为一个过渡对象出现的，目的是为了创建要返回的新的实例化对象。</p>\n<blockquote>\n<p>??是不是类式继承中的问题在这里也会出现？？？</p>\n</blockquote>\n<p>是的，！！！，不过这种方式由于F过渡类的构造函数中无内容，所以开销比较小，使用起来也比较方便，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> book = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'js book'</span>,</span><br><span class=\"line\">    alikeBook: [<span class=\"string\">'css book'</span>, <span class=\"string\">'html book'</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newBook = inheritObject(book)</span><br><span class=\"line\">newBook.name = <span class=\"string\">'ajax book'</span></span><br><span class=\"line\">newBook.alikeBook.push(<span class=\"string\">'xml books'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> otherBook = inheritObject(book)</span><br><span class=\"line\">otherBook.name = <span class=\"string\">'flash book'</span></span><br><span class=\"line\">otherBook.alikeBook.push(<span class=\"string\">'as books'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newBook.name)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newBook.alikeBook)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(otherBook.name)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(otherBook.alikeBook)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(book.name)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(book.alikeBook)</span><br></pre></td></tr></table></figure>\n<p>和类式继承一样，父类对象book中的值类型的属性被复制，引用类型的属性被共用。</p>\n<h3 id=\"如虎添翼—寄生式继承\"><a href=\"#如虎添翼—寄生式继承\" class=\"headerlink\" title=\"如虎添翼—寄生式继承\"></a>如虎添翼—寄生式继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 寄生式继承</span></span><br><span class=\"line\"><span class=\"comment\">// 声明基对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> book = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'js book'</span>,</span><br><span class=\"line\">    alikeBook: [<span class=\"string\">'css book'</span>, <span class=\"string\">'html book'</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritObject</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 声明一个过渡函数对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// var c = new inheritObject(book);</span></span><br><span class=\"line\"><span class=\"comment\">// console.log(c)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createBook</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过原型继承方式创建新对象</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> inheritObject(obj)</span><br><span class=\"line\">    <span class=\"comment\">// 拓展新对象</span></span><br><span class=\"line\">    o.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a1  = createBook(book)</span><br><span class=\"line\"><span class=\"keyword\">var</span> a2  = createBook(book)</span><br><span class=\"line\">a1.alikeBook.push(<span class=\"string\">'设计模式'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a1.alikeBook)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a2.alikeBook)</span><br></pre></td></tr></table></figure>\n<p>其实寄生式继承就是对原型继承的第二次封装，并且在第二次封装的过程中对继承的对象进行了扩展，这样新创建的对象不仅仅有父类中的属性和方法而且还添加了新的属性和方法。</p>\n<h3 id=\"终极继承者—寄生组合式继承\"><a href=\"#终极继承者—寄生组合式继承\" class=\"headerlink\" title=\"终极继承者—寄生组合式继承\"></a>终极继承者—寄生组合式继承</h3><blockquote>\n<p>之前学习了组合继承，就是将类式继承通构造函数继承组合，这种方式存在的问题就是子类不是父类的实例，而子类的原型式父类的实例，因此才有了寄生组合式继承。是寄生式继承与构造函数继承的组合，但是这里寄生式继承有点特殊，这里他处理的不是对象，而是类的原型。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritObject</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 声明一个过渡函数对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritPrototype</span>(<span class=\"params\">SubClass, SuperClass</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 复制一份父类的原型副本保存在变量中</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> p = inheritObject(SuperClass.prototype);</span><br><span class=\"line\">    <span class=\"comment\">// 修正因为重写子原型导致子类的constructor属性被修改</span></span><br><span class=\"line\">    p.constructor = SubClass;</span><br><span class=\"line\">    <span class=\"comment\">// 设置子类的原型</span></span><br><span class=\"line\">    SubClass.prototype = p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在寄生组合式继承中，通过构造函数继承的属性和方法是没有问题的吗，这里主要探究通过寄生式继承重新继承父类的原型，我们需要继承的仅仅是父类的原型，不在需要调用父类的构造函数，换句话说，在构造函数继承中，我们已经调用了父类的构造函数，因此我们需要的就是父类的原型对象的一个副本，而这个副本我们我们通过原型继承便可得到，但是直接赋值个子类会有问题，因为对父类原型对象复制得到的复制对象p中的constroctor指向的不是SubClass子类对象，因此在寄生式继承中要对复制对象p做一次增强，修复其constroctor属性指向不正确问题，最后将得到的复制对象p赋值给子类的原型，这样子类的原型就继承了父类的原型并且没有执行父类的构造函数。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 寄生式继承  继承原型</span></span><br><span class=\"line\"><span class=\"comment\">// 传递参数  SuperClass  父了</span></span><br><span class=\"line\"><span class=\"comment\">// 传递参数  SubClass    子类</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritObject</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 声明一个过渡函数对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritPrototype</span>(<span class=\"params\">SubClass, SuperClass</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 复制一份父类的原型副本保存在变量中</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> p = inheritObject(SuperClass.prototype);</span><br><span class=\"line\">    <span class=\"comment\">// 修正因为重写子原型导致子类的constructor属性被修改</span></span><br><span class=\"line\">    p.constructor = SubClass;</span><br><span class=\"line\">    <span class=\"comment\">// 设置子类的原型</span></span><br><span class=\"line\">    SubClass.prototype = p;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperClass</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.colors = [<span class=\"string\">'red'</span>, <span class=\"string\">'blue'</span>, <span class=\"string\">'green'</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperClass.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\">name, time</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数继承</span></span><br><span class=\"line\">    SuperClass.call(<span class=\"keyword\">this</span>, name)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.time = time</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 寄生式继承父类原型</span></span><br><span class=\"line\">inheritPrototype(SubClass, SuperClass)</span><br><span class=\"line\">SubClass.prototype.getTime = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.time)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 创建两个测试方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubClass(<span class=\"string\">'js book'</span>, <span class=\"number\">2017</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubClass(<span class=\"string\">'css book'</span>, <span class=\"number\">2018</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">instance1.colors.push(<span class=\"string\">'black'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.colors)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.colors)</span><br><span class=\"line\">instance2.getName();</span><br><span class=\"line\">instance2.getTime();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这中继承最大的改变就是对子类原型的处理，被赋予父类原型的一个应用，这是一个对象，因此有一点要注意，就是子类在想添加原型方法必须通过prototype对象，通过点语法的形式一个个添加方法了，否则直接赋予对象就会覆盖掉从父类原型继承的对象了。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>每个类都有三个部分组成</p>\n</blockquote>\n<ul>\n<li>构造函数内的，供实例对象复制用的</li>\n<li>构造函数外的，直接通过点语法添加的，这是供类使用的，实例对象访问不到</li>\n<li>类的原型中的，实例化对象可以通过其原型链间接的访问到，也是为供所有实例化对象所共有</li>\n</ul>","more":"<h3 id=\"子类的原型继承—类式继承\"><a href=\"#子类的原型继承—类式继承\" class=\"headerlink\" title=\"子类的原型继承—类式继承\"></a>子类的原型继承—类式继承</h3><blockquote>\n<p>类式继承需要将第一个类的实例赋值给第二个类的原型</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperClass</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.SuperValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 为父类原型添加方法</span></span><br><span class=\"line\">SuperClass.prototype.getSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// alert(1)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.SuperValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// console.dir(SuperClass);</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> supe = <span class=\"keyword\">new</span> SuperClass();</span><br><span class=\"line\"><span class=\"comment\">// console.dir(supe);</span></span><br><span class=\"line\"><span class=\"comment\">// supe.getSuperValue();</span></span><br><span class=\"line\"><span class=\"comment\">// 声明子类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subValue = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 子类继承父类</span></span><br><span class=\"line\">SubClass.prototype = <span class=\"keyword\">new</span> SuperClass();</span><br><span class=\"line\"><span class=\"comment\">// 为子类添加共有方法</span></span><br><span class=\"line\">SubClass.prototype.getSubValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// alert(2);</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.subValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// console.dir(SubClass);</span></span><br><span class=\"line\"><span class=\"comment\">// 子类继承父类SuperValue属性，</span></span><br><span class=\"line\"><span class=\"comment\">// 访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找，这就是原型链。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sub = <span class=\"keyword\">new</span> SubClass();</span><br><span class=\"line\"><span class=\"comment\">// sub.getSuperValue();</span></span><br><span class=\"line\"><span class=\"comment\">// sub.getSubValue();</span></span><br><span class=\"line\"><span class=\"comment\">// console.log(sub.SuperValue);</span></span><br><span class=\"line\"><span class=\"comment\">// console.log(sub.subValue);</span></span><br><span class=\"line\"><span class=\"comment\">// console.dir(sub);</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>为什么这样做？？？</p>\n</blockquote>\n<p>类的原型对象的作用就是为类的原型添加共有方法，但是累不能直接访问这些属性和方法，必须通过prototype来访问。</p>\n<p>我们在实例化一个父类的时候，新创建的对象复制了父类的构造函数内的属性和方法并且将隐氏原型<em>proto</em>指向父类的原型对象，这样就拥有了父类的原型对象上的方法和属性。</p>\n<p>如果将新创建的对象赋值给子类的原型，那么子类的原型就可以访问到父类的原型上的属性和方法，同样也可以访问从父类构造函数中复制的属性和方法，同样子类也可以访问父类原型上的属性和方法与父类构造函数中复制的属性和方法。</p>\n<blockquote>\n<p>检测继承关系</p>\n</blockquote>\n<p>instanceof通过判断对象的<em>proto</em>与构造函数的prototype，来确定这个对象是否是某个类的实例，而不关心对象与类的自身结构</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(sub <span class=\"keyword\">instanceof</span> SubClass);         <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sub <span class=\"keyword\">instanceof</span> SuperClass);       <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(SubClass <span class=\"keyword\">instanceof</span> SuperClass);  <span class=\"comment\">//false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// why false??</span></span><br><span class=\"line\"><span class=\"comment\">// instanceof 是判断前面的对象是否是后面类的实例，他并不表示两者的继承，</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(SubClass.prototype <span class=\"keyword\">instanceof</span> SuperClass); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>类式继承的缺点</p>\n</blockquote>\n<ul>\n<li>由于子类通过其原型Prototype对父类实例化，继承了父类，所以说父类中的共有属性要是引用类型，就会在子类中被所有属性共有，因此一个子类的实例更改子类原型从父类构造函数中继承来的共有属性就会直接影响到其他子类</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperClass</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.books = [<span class=\"string\">'javascript'</span>, <span class=\"string\">'html'</span>, <span class=\"string\">'css'</span>]</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = <span class=\"number\">12</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">SubClass.prototype = <span class=\"keyword\">new</span> SuperClass()</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubClass()</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubClass()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.books)</span><br><span class=\"line\">instance1.books.push(<span class=\"string\">'设计模式'</span>)</span><br><span class=\"line\">instance1.a = <span class=\"number\">34</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.books)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.a)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>由于子类实现的继承是靠原型prototype对付类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的，因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化。</li>\n</ul>\n<h3 id=\"创建即继承—构造函数继承\"><a href=\"#创建即继承—构造函数继承\" class=\"headerlink\" title=\"创建即继承—构造函数继承\"></a>创建即继承—构造函数继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造函数继承</span></span><br><span class=\"line\"><span class=\"comment\">// 声明父类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperClass</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.books = [<span class=\"string\">'javascript'</span>, <span class=\"string\">'html'</span>, <span class=\"string\">'css'</span>];</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 父类声明原型</span></span><br><span class=\"line\">SuperClass.prototype.showBooks = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.books);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 声明子类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 继承父类</span></span><br><span class=\"line\">    SuperClass.call(<span class=\"keyword\">this</span>, id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 创建第一个子类的实例</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubClass(<span class=\"number\">11</span>);</span><br><span class=\"line\"><span class=\"comment\">// 创建第二个子类的实例</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubClass(<span class=\"number\">22</span>);</span><br><span class=\"line\"><span class=\"comment\">// 验证</span></span><br><span class=\"line\">instance1.books.push(<span class=\"string\">'设计模式'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.books);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.books);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.id);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.id);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>继承原理</p>\n</blockquote>\n<ul>\n<li><p>由于call这个方法可以更改函数的作用域，因此在子类中，对superClass调用这个方法就是将子类中的变量在父类中执行一遍。</p>\n</li>\n<li><p>由于父类中是=给this绑定属性的，因此子类自然也就继承了父类的共有属性</p>\n</li>\n<li><p>由于这种类型的继承没有涉及原型prototype，所以父类的原型方法自然不会被子类继承</p>\n</li>\n</ul>\n<blockquote>\n<p>每个函数都包含两个非继承而来的方法：call()方法和apply()方法。</p>\n</blockquote>\n<ul>\n<li>相同点：这两个方法的作用是一样的。</li>\n</ul>\n<p>都是在特定的作用域中调用函数，等于设置函数体内this对象的值，以扩充函数赖以运行的作用域。</p>\n<p>一般来说，this总是指向调用某个方法的对象，但是使用call()和apply()方法时，就会改变this的指向。</p>\n<ul>\n<li>不同点：接收参数的方式不同。</li>\n</ul>\n<p>apply()方法 接收两个参数，一个是函数运行的作用域（this），另一个是参数数组。</p>\n<h3 id=\"将有点为我所用—组合继承\"><a href=\"#将有点为我所用—组合继承\" class=\"headerlink\" title=\"将有点为我所用—组合继承\"></a>将有点为我所用—组合继承</h3><h4 id=\"总结前面两种特点\"><a href=\"#总结前面两种特点\" class=\"headerlink\" title=\"总结前面两种特点\"></a>总结前面两种特点</h4><blockquote>\n<p>类式继承式通过子类的原型prototype对父类实例化来实现的。</p>\n<p>构造函数式继承式通过在子类的构造函数作用环境中执行一次父类的构造函数来实现。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组合式继承</span></span><br><span class=\"line\"><span class=\"comment\">// 声明父类</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperClass</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>,boob = [<span class=\"string\">'html'</span>, <span class=\"string\">'css'</span>, <span class=\"string\">'javascript'</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 父类原型共有方法</span></span><br><span class=\"line\">SuperClass.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 声明子类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\">name, time</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数式继承父类name 属性</span></span><br><span class=\"line\">    SuperClass.call(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">    <span class=\"comment\">// 子类中新增共有属性</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.time = time;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 类式继承  子类原型继承父类</span></span><br><span class=\"line\">SubClass.prototype = <span class=\"keyword\">new</span> SuperClass();</span><br><span class=\"line\"><span class=\"comment\">// 子类原型方法</span></span><br><span class=\"line\">SubClass.prototype.getTime = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.time);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubClass(<span class=\"string\">'js book'</span>, <span class=\"number\">2017</span>);</span><br><span class=\"line\">instance1.books.push(<span class=\"string\">'设计模式'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.books);</span><br><span class=\"line\">instance1.getName();</span><br><span class=\"line\">instance1.getTime();</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubClass(<span class=\"string\">'css book'</span>, <span class=\"number\">2018</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.books);</span><br><span class=\"line\">instance2.getName();</span><br><span class=\"line\">instance2.getTime();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>结合了类式继承和构造函数继承两种方式的优点</p>\n<p>不足之处</p>\n</blockquote>\n<p>在使用构造函数继承时执行了一遍父类的构造函数，而在实现子类原型的类式继承式又调用了一遍父类的构造函数。因此父类构造函数调用了两遍。</p>\n<h3 id=\"洁净的继承者—原型式继承\"><a href=\"#洁净的继承者—原型式继承\" class=\"headerlink\" title=\"洁净的继承者—原型式继承\"></a>洁净的继承者—原型式继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritObject</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 声明一个过渡函数对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>和类式继承有点像？？</p>\n</blockquote>\n<p>对，是对类式继承的一个封装，过渡对象相当于类式继承中的子类，只不过在原型式继承中作为一个过渡对象出现的，目的是为了创建要返回的新的实例化对象。</p>\n<blockquote>\n<p>??是不是类式继承中的问题在这里也会出现？？？</p>\n</blockquote>\n<p>是的，！！！，不过这种方式由于F过渡类的构造函数中无内容，所以开销比较小，使用起来也比较方便，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> book = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'js book'</span>,</span><br><span class=\"line\">    alikeBook: [<span class=\"string\">'css book'</span>, <span class=\"string\">'html book'</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newBook = inheritObject(book)</span><br><span class=\"line\">newBook.name = <span class=\"string\">'ajax book'</span></span><br><span class=\"line\">newBook.alikeBook.push(<span class=\"string\">'xml books'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> otherBook = inheritObject(book)</span><br><span class=\"line\">otherBook.name = <span class=\"string\">'flash book'</span></span><br><span class=\"line\">otherBook.alikeBook.push(<span class=\"string\">'as books'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newBook.name)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newBook.alikeBook)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(otherBook.name)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(otherBook.alikeBook)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(book.name)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(book.alikeBook)</span><br></pre></td></tr></table></figure>\n<p>和类式继承一样，父类对象book中的值类型的属性被复制，引用类型的属性被共用。</p>\n<h3 id=\"如虎添翼—寄生式继承\"><a href=\"#如虎添翼—寄生式继承\" class=\"headerlink\" title=\"如虎添翼—寄生式继承\"></a>如虎添翼—寄生式继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 寄生式继承</span></span><br><span class=\"line\"><span class=\"comment\">// 声明基对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> book = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'js book'</span>,</span><br><span class=\"line\">    alikeBook: [<span class=\"string\">'css book'</span>, <span class=\"string\">'html book'</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritObject</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 声明一个过渡函数对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// var c = new inheritObject(book);</span></span><br><span class=\"line\"><span class=\"comment\">// console.log(c)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createBook</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过原型继承方式创建新对象</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> inheritObject(obj)</span><br><span class=\"line\">    <span class=\"comment\">// 拓展新对象</span></span><br><span class=\"line\">    o.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a1  = createBook(book)</span><br><span class=\"line\"><span class=\"keyword\">var</span> a2  = createBook(book)</span><br><span class=\"line\">a1.alikeBook.push(<span class=\"string\">'设计模式'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a1.alikeBook)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a2.alikeBook)</span><br></pre></td></tr></table></figure>\n<p>其实寄生式继承就是对原型继承的第二次封装，并且在第二次封装的过程中对继承的对象进行了扩展，这样新创建的对象不仅仅有父类中的属性和方法而且还添加了新的属性和方法。</p>\n<h3 id=\"终极继承者—寄生组合式继承\"><a href=\"#终极继承者—寄生组合式继承\" class=\"headerlink\" title=\"终极继承者—寄生组合式继承\"></a>终极继承者—寄生组合式继承</h3><blockquote>\n<p>之前学习了组合继承，就是将类式继承通构造函数继承组合，这种方式存在的问题就是子类不是父类的实例，而子类的原型式父类的实例，因此才有了寄生组合式继承。是寄生式继承与构造函数继承的组合，但是这里寄生式继承有点特殊，这里他处理的不是对象，而是类的原型。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritObject</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 声明一个过渡函数对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritPrototype</span>(<span class=\"params\">SubClass, SuperClass</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 复制一份父类的原型副本保存在变量中</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> p = inheritObject(SuperClass.prototype);</span><br><span class=\"line\">    <span class=\"comment\">// 修正因为重写子原型导致子类的constructor属性被修改</span></span><br><span class=\"line\">    p.constructor = SubClass;</span><br><span class=\"line\">    <span class=\"comment\">// 设置子类的原型</span></span><br><span class=\"line\">    SubClass.prototype = p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在寄生组合式继承中，通过构造函数继承的属性和方法是没有问题的吗，这里主要探究通过寄生式继承重新继承父类的原型，我们需要继承的仅仅是父类的原型，不在需要调用父类的构造函数，换句话说，在构造函数继承中，我们已经调用了父类的构造函数，因此我们需要的就是父类的原型对象的一个副本，而这个副本我们我们通过原型继承便可得到，但是直接赋值个子类会有问题，因为对父类原型对象复制得到的复制对象p中的constroctor指向的不是SubClass子类对象，因此在寄生式继承中要对复制对象p做一次增强，修复其constroctor属性指向不正确问题，最后将得到的复制对象p赋值给子类的原型，这样子类的原型就继承了父类的原型并且没有执行父类的构造函数。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 寄生式继承  继承原型</span></span><br><span class=\"line\"><span class=\"comment\">// 传递参数  SuperClass  父了</span></span><br><span class=\"line\"><span class=\"comment\">// 传递参数  SubClass    子类</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritObject</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 声明一个过渡函数对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritPrototype</span>(<span class=\"params\">SubClass, SuperClass</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 复制一份父类的原型副本保存在变量中</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> p = inheritObject(SuperClass.prototype);</span><br><span class=\"line\">    <span class=\"comment\">// 修正因为重写子原型导致子类的constructor属性被修改</span></span><br><span class=\"line\">    p.constructor = SubClass;</span><br><span class=\"line\">    <span class=\"comment\">// 设置子类的原型</span></span><br><span class=\"line\">    SubClass.prototype = p;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperClass</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.colors = [<span class=\"string\">'red'</span>, <span class=\"string\">'blue'</span>, <span class=\"string\">'green'</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperClass.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\">name, time</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数继承</span></span><br><span class=\"line\">    SuperClass.call(<span class=\"keyword\">this</span>, name)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.time = time</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 寄生式继承父类原型</span></span><br><span class=\"line\">inheritPrototype(SubClass, SuperClass)</span><br><span class=\"line\">SubClass.prototype.getTime = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.time)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 创建两个测试方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubClass(<span class=\"string\">'js book'</span>, <span class=\"number\">2017</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubClass(<span class=\"string\">'css book'</span>, <span class=\"number\">2018</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">instance1.colors.push(<span class=\"string\">'black'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.colors)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.colors)</span><br><span class=\"line\">instance2.getName();</span><br><span class=\"line\">instance2.getTime();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这中继承最大的改变就是对子类原型的处理，被赋予父类原型的一个应用，这是一个对象，因此有一点要注意，就是子类在想添加原型方法必须通过prototype对象，通过点语法的形式一个个添加方法了，否则直接赋予对象就会覆盖掉从父类原型继承的对象了。</p>\n</blockquote>"},{"title":"js正则","date":"2018-04-12T02:03:20.000Z","_content":"> js正则\n\n[菜鸟教程](http://www.runoob.com/regexp/regexp-intro.html)\n\n<!-- more -->\n\n## 限定符\n\n> 限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。\n\n{\t标记限定符表达式的开始。要匹配 {，请使用 \\\\{。\n\n![](/img/js/reg.png \"reg\")\n\n\n\n\n","source":"_posts/javascript/正则.md","raw":"---\ntitle: js正则\ncategories:\n  - 前端技术\ntags:\n  - js\ndate: 2018-04-12 10:03:20\n---\n> js正则\n\n[菜鸟教程](http://www.runoob.com/regexp/regexp-intro.html)\n\n<!-- more -->\n\n## 限定符\n\n> 限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。\n\n{\t标记限定符表达式的开始。要匹配 {，请使用 \\\\{。\n\n![](/img/js/reg.png \"reg\")\n\n\n\n\n","slug":"javascript/正则","published":1,"updated":"2018-05-31T10:27:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3d6000buox1xtauuhan","content":"<blockquote>\n<p>js正则</p>\n</blockquote>\n<p><a href=\"http://www.runoob.com/regexp/regexp-intro.html\" target=\"_blank\" rel=\"noopener\">菜鸟教程</a></p>\n<a id=\"more\"></a>\n<h2 id=\"限定符\"><a href=\"#限定符\" class=\"headerlink\" title=\"限定符\"></a>限定符</h2><blockquote>\n<p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。</p>\n</blockquote>\n<p>{    标记限定符表达式的开始。要匹配 {，请使用 \\{。</p>\n<p><img src=\"/img/js/reg.png\" alt=\"\" title=\"reg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>js正则</p>\n</blockquote>\n<p><a href=\"http://www.runoob.com/regexp/regexp-intro.html\" target=\"_blank\" rel=\"noopener\">菜鸟教程</a></p>","more":"<h2 id=\"限定符\"><a href=\"#限定符\" class=\"headerlink\" title=\"限定符\"></a>限定符</h2><blockquote>\n<p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。</p>\n</blockquote>\n<p>{    标记限定符表达式的开始。要匹配 {，请使用 \\{。</p>\n<p><img src=\"/img/js/reg.png\" alt=\"\" title=\"reg\"></p>"},{"title":"创建型设计模式","date":"2017-11-20T13:03:20.000Z","_content":"\n> 创建型设计模式是一类处理对象创建的设计模式，通过某种方法控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度。\n\n<!-- more -->\n### 神奇的魔术师---简单工厂模式\n\n> 简单工厂模式，有叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例，主要用来创建同一类对象。\n\n```javascript\n//例子  用登录注册提示\nvar LoginAlert = function(text) {\n    this.content = text;\n}\nLoginAlert.prototype.show = function() {\n    alert(this.content)\n}\nvar userNameAlert = new LoginAlert('用户名不能多于16个字母数字')\nuserNameAlert.show()\nvar passWordAlert = new LoginAlert('输入的密码不正确')\npassWordAlert.show()\n\nvar LoginConfirm = function(text) {\n    this.content = text;\n}\nLoginConfirm.prototype.show = function() {\n    alert(this.content)\n}\nvar loginFailConfirm = new LoginConfirm('用户名不能多于16个字母数字')\nloginFailConfirm.show();\n\n\nvar LoginPrompt = function(text) {\n    this.content = text;\n}\nLoginPrompt.prototype.show = function() {\n    alert(this.content)\n}\n// ...................\n```\n\n> 如果类太多，那么提供一个。\n\n别人想借用我的方法，写注册模块，缺点类名太多，其他人每次创建还要找到对应的类，太麻烦，而且是以login开头，最好封装在一个函数里，其他人只需要记住这个函数名，通过这个函数就可以创建我需要的对象为我所用，这个函数通常被称为工厂函数，这种模式叫简单工厂模式。\n\n```javascript\nvar PopFactory= function(name) {\n    switch(name) {\n        case 'alert' :\n            return new LoginAlert()\n        case 'confirm' :\n            return new LoginConfirm()\n        case 'prompt' :\n            return new LoginPrompt()\n    }\n}\n// 这三个类有很多地方是相同的，是可以抽象提取出来共用的，也可用简单工厂方式实现它们。\n```\n\n> 一个对象有时也可代替许多类\n\n简单工厂模式的理念就是创建对象，上面这种方式是对不同的类实例化，除此之外简单工厂模式还可以用来创建相似对象，上面创建的几个类很多地方都比较相似，提取相似，针对不相似处理，\n\n```javascript\nfunction createPop(type, text) {\n    var o = new Object();\n    o.content = text;\n    o.show= function() {\n        // 显示方法\n    };\n    if(type == 'alert') {\n        // 差异部分\n    }\n    if(type == 'prompt') {\n        // 差异部分\n    }\n    if(type == 'confirm') {\n        // 差异部分\n    }\n    return o;\n}\n// 调用，创建提示框\nvar userNameAlert = createPop('alert', '提示文字')\n```\n> 总结：两种创建方式区别，第一种通过实例化对象创建，如果这些类继承同一父类，父类原型上的方法可以共用，第二种通过创建一个新对象然后包装增强其属性和功能来实现，每个对象都是一个新的个体，方法不能共用，选择哪种看实际需求。\n\n### 给我一张名片---工厂方法模式\n\n> 通过对产品类的抽象使其创建业务主要负责用于创建多类产品的实例。\n\n```javascript\n需求，新来一批广告资源需要投资，一批java,一批php等等，不同课程字体颜色和大小不同。\n\n// 简单工厂\nvar Java = function(content) {\n    // .......\n}\nvar Php = function(content) {\n    // .......\n}\nvar Javascript = function(content) {\n    // .......\n}\n// 学科工厂\nfunction JobFactory(type, content) {\n    switch(type) {\n        case 'java' : \n            return new Java(content)\n        case 'php' : \n            return new Php(content)\n        case 'Javascript' : \n            return new Javascript(content)\n    }\n}\n// 测试案例\nJobFactory('Javascript', 'content');\n\n```\n\n问题？又来一批课程，需求各不同，之前的需求一直在变，不仅要添加类，还要修改工厂函数，可能未来的需求还会在变。引申相互工厂方法模式，这样以后每需要一个类，只需要添加这个类。\n\n> 工厂方法模式本意是说将实际创建对象工作推迟到子类当中，这样核心类就成了抽象类，不过对应javascript不必这么深究，javascript没有像传统创建抽象类那样的方式轻易创建抽象了类，所以在javascript中实现工厂方法模式我们只需要参考它的核心思想即可，所以我们可以将工厂方法看做是一个实例化对象的工厂类，安全起见，我们采用安全模式类，而我们将创建对象的基类放在工厂方法类的原型中即可。\n\n#### 安全的工厂方法\n\n```javascript\n// 安全模式创建的工厂类\nvar Factory = function(type, content) {\n    if(this instanceof Factory) {\n        var s = new this[type] (content);\n        return s;\n    } else {\n        return new Factory(type, content);\n    }\n}\n// 工厂原型中设置创建所用类型数据对象的基类\nFactory.prototype = {\n    Java: function(content) {\n        // ....\n    },\n    javascript: function(content) {\n        // ....\n    },\n    UI: function(content) {\n        this.content = content;\n        (function(content)) {\n            var div = documnet.createElement('div');\n            div.innerHTML = content;\n            div.style.border = '1pc solid #ccc';\n            document.getElementById('container').appendChild(div);\n        }\n    }(content)\n}\nvar data = [{type: 'java', content: 'jajaja'},{type: 'php', content: 'phphphp'}]\ndata.map(function(item) {\n    Factory(item.type, item.content);\n})\n```\n> 优点，如果添加类，只需在Factory.prototype中添加，适用于创建多类对象，同时避免使用者与对象之间的耦合，用户不必关心创建该对象的具体类，只需调用工厂方法即可。\n\n### 出现的都是幻觉---抽象工厂模式\n\n> 通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建每一类产品的实例。\n\n抽象工厂模式一般不用来创建具体对象，一般用它作为父类来创建一个子类。\n\n```javascript\n// 抽象工厂方法\nvar VericleFactory = function(subType, superType) {\n    // 判断抽象工厂中是否有该抽象类\n    if(typeof VericleFactory[superType] === 'function') {\n        function F() {}\n        // 继承父类属性方法\n        F.prototype = new VericleFactory[superType]();\n        // 将子类constructor指向子类\n        subType.constructor = superType;\n        // 子类原型继承父类\n        subType.prototype = new F();\n    } else {\n        // 不存在该抽象类抛出错误 \n        return new Error('未创建该抽象类')\n    }   \n}\n// 某一个车的抽象类\nVericleFactory.Truck = function() {\n    this.type = 'truck'\n}\nVericleFactory.Truck.prototype = {\n    getPrice: function() {\n        return new Error('抽象方法不可调用')\n    },\n    getTrainload: function() {\n        return new Error('抽象方法不可调用')\n    }\n}\n// 奔驰汽车子类\nvar BenzTruck = function(price, trainLoad) {\n    this.price = price;\n    this.trainLoad = trainLoad;\n}\n// 抽象方法实现对Truck抽象类的继承\nVericleFactory(BenzTruck, \"Truck\");\nBenzTruck.prototype.getPrice = function() {\n    return this.price;\n}\nBenzTruck.prototype.getTrainload = function() {\n    return this.getTrainload;\n}\n// 测试\nvar truck = new BenzTruck(100, 10000);\nconsole.log(truck.getPrice)   // 100\nconsole.log(truck.type)       // truck\n\n```\n\n> 总结：抽象工厂模式是设计模式中最抽象的一种，也是创建模式中唯一一种抽象化创建模式，该模式创建出的结果不是一个真实的对象实例，而是一个类簇，它制定了类的结构，这也就区别于简单工厂模式创建单一对象，工厂方法模式创建多类对象，当然由于JavaScript中不支持抽象化创建与虚拟方法，所以导致这种模式不能像其他面向对象语言中应用的那么广泛。\n\n### 分即是合---建造者模式\n\n> 将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示。\n\n创建对象的另一种新式：建造者模式\n\n建造者模式更注重的是创建的细节。\n\n### 语言之魂---原型模式\n\n> 用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法。\n\n```javascript\nfunction prototypeExtend() {\n  var F = function() {},\n  args = arguments,\n    i = 0,\n    len = args.length;\n    // console.log(arguments)\n  for (; i < len; i++) {\n    for (var j in args[i]) {\n      F.prototype[j] = args[i][j];\n      console.log(F.prototype)\n    }\n  }\n  return new F();\n}\n\nvar penguin = prototypeExtend(\n  {\n    speed: 20,\n    swim: function() {\n      console.log(\".......1\");\n    }\n  },\n  {\n    sd: 300,\n    run: function(speed) {\n      console.log(\"......2\"+ speed);\n    }\n  },\n  {\n    jump: function() {\n      console.log(\".........3\");\n    }\n  }\n);\npenguin.swim()\npenguin.run(10)\npenguin.jump()\n\n```\n\n> 总结：原型模式可以让多个对象分享同一个原型对象的属性和方法，这也是一种继承方式，不过这种继承的实现是不需要创建的，而是将原型对象分享给那些继承的对象，当然有时需要让每个继承对象独立拥有一份原型对象，此时我们就需要对原型对象进行复制。\n\n由此可以看出，原型对象更适合在创建复杂的对象时，对于那些需求一直在变化而导致对象结构不停的改变时，将那些比较稳定的属性与方法共用而提取的继承的实现。\n\n### 一个人的寂寞---单例模式\n\n> 单例模式：有被称为单体模式，是只允许实例化一次的对象类，有时我们也用一个对象来规划一个命名空间，井井有条地管理对象上的属性个方法。\n\nJavaScript中最常见的一种模式，这种模式经常为我们提供一个命名空间，如我们使用过的jQuery库，单例模式就为它提供利润一个命名空间jQuery。\n\n> 命名空间？？？？\n\n就是nameSpace，解决一类问题：为了让代码更易懂，人们常常用单词或者拼音定义变量或者方法，但由于有限的单词量，所以不同的人定义的变量使用的单词名称很有可能重复，此时就需要用命名空间来约束每个人定义的变量来解决这类问题。\n\n```javascript\nfunction g(id) {\n    return document.getElementById(id)\n}\nfunction css(id, key, value) {\n    g(id).style[key] = value;\n}\nfunction on(id ,type, fn) {\n    g(id)['on' + type] = fn;\n}\n// ................\n\n// 命名空间\nvar My = {\n    g: function() {\n        return document.getElementById(id)\n    },\n    css: function() {\n        this.g(id).style[key] = value;\n    },\n    on: function() {\n        this.g(id)['on' + type] = fn;\n    }\n}\n\n```\n> 单例模式的其他作用：就是通过单例模式来控制自己的每个功能模块。\n\n> 创建一个小型代码库\n\n```javascript\nvar A= {\n    Util: {\n        util_1: function() {},\n         util_2: function() {}\n    },\n    Tool: {\n        tool_1: function() {},\n        tool_2: function() {}\n    },\n    Ajax: function () {\n        ajax_1: function() {},\n        ajax_2: function() {}\n    }\n}\n\nA.Util.util_1();\n// ........\n\n```\n> 无法修改的静态变量\n\n用单例模式管理静态变量\n\n```javascript\nvar Conf = (function() {\n    var conf = {\n        MAX_NUM: 100,\n        MIN_NUM: 1,\n        COUNT: 1000\n    }\n    return {\n        get: function(name) {\n            return conf[name] ? conf[name] : null\n        }\n    }\n})()\nvar COUNT = Conf.get('COUNT')\n\n```\n> 惰性单例\n\n有时候对于单例对象需要延迟创建，所以在单例中还存在一种延迟创建的形式，有人也称之为‘惰性创建’。\n\n```javascript\n// 惰性载入单例\nvar LazySingle = (function() {\n    // 单例实例引用\n    var instance = null;\n    // 单例\n    function Single() {\n        // 这里定义私有属性和方法\n        return {\n            publicMethod: function() {},\n            punlicProperty: '1.0'\n        }\n    }\n    // 获取单例对象接口\n    if(!instance) {\n        instance = Single()\n    }\n    // 返回单例\n    return instance;\n} )()\n\nconsole.log(LazySingle().punlicProperty);  // 1.0\n\n```\n","source":"_posts/javascript/创建型设计模式.md","raw":"---\ntitle: 创建型设计模式\ncategories:\n  - 前端技术\ntags:\n  - js\ndate: 2017-11-20 21:03:20\n---\n\n> 创建型设计模式是一类处理对象创建的设计模式，通过某种方法控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度。\n\n<!-- more -->\n### 神奇的魔术师---简单工厂模式\n\n> 简单工厂模式，有叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例，主要用来创建同一类对象。\n\n```javascript\n//例子  用登录注册提示\nvar LoginAlert = function(text) {\n    this.content = text;\n}\nLoginAlert.prototype.show = function() {\n    alert(this.content)\n}\nvar userNameAlert = new LoginAlert('用户名不能多于16个字母数字')\nuserNameAlert.show()\nvar passWordAlert = new LoginAlert('输入的密码不正确')\npassWordAlert.show()\n\nvar LoginConfirm = function(text) {\n    this.content = text;\n}\nLoginConfirm.prototype.show = function() {\n    alert(this.content)\n}\nvar loginFailConfirm = new LoginConfirm('用户名不能多于16个字母数字')\nloginFailConfirm.show();\n\n\nvar LoginPrompt = function(text) {\n    this.content = text;\n}\nLoginPrompt.prototype.show = function() {\n    alert(this.content)\n}\n// ...................\n```\n\n> 如果类太多，那么提供一个。\n\n别人想借用我的方法，写注册模块，缺点类名太多，其他人每次创建还要找到对应的类，太麻烦，而且是以login开头，最好封装在一个函数里，其他人只需要记住这个函数名，通过这个函数就可以创建我需要的对象为我所用，这个函数通常被称为工厂函数，这种模式叫简单工厂模式。\n\n```javascript\nvar PopFactory= function(name) {\n    switch(name) {\n        case 'alert' :\n            return new LoginAlert()\n        case 'confirm' :\n            return new LoginConfirm()\n        case 'prompt' :\n            return new LoginPrompt()\n    }\n}\n// 这三个类有很多地方是相同的，是可以抽象提取出来共用的，也可用简单工厂方式实现它们。\n```\n\n> 一个对象有时也可代替许多类\n\n简单工厂模式的理念就是创建对象，上面这种方式是对不同的类实例化，除此之外简单工厂模式还可以用来创建相似对象，上面创建的几个类很多地方都比较相似，提取相似，针对不相似处理，\n\n```javascript\nfunction createPop(type, text) {\n    var o = new Object();\n    o.content = text;\n    o.show= function() {\n        // 显示方法\n    };\n    if(type == 'alert') {\n        // 差异部分\n    }\n    if(type == 'prompt') {\n        // 差异部分\n    }\n    if(type == 'confirm') {\n        // 差异部分\n    }\n    return o;\n}\n// 调用，创建提示框\nvar userNameAlert = createPop('alert', '提示文字')\n```\n> 总结：两种创建方式区别，第一种通过实例化对象创建，如果这些类继承同一父类，父类原型上的方法可以共用，第二种通过创建一个新对象然后包装增强其属性和功能来实现，每个对象都是一个新的个体，方法不能共用，选择哪种看实际需求。\n\n### 给我一张名片---工厂方法模式\n\n> 通过对产品类的抽象使其创建业务主要负责用于创建多类产品的实例。\n\n```javascript\n需求，新来一批广告资源需要投资，一批java,一批php等等，不同课程字体颜色和大小不同。\n\n// 简单工厂\nvar Java = function(content) {\n    // .......\n}\nvar Php = function(content) {\n    // .......\n}\nvar Javascript = function(content) {\n    // .......\n}\n// 学科工厂\nfunction JobFactory(type, content) {\n    switch(type) {\n        case 'java' : \n            return new Java(content)\n        case 'php' : \n            return new Php(content)\n        case 'Javascript' : \n            return new Javascript(content)\n    }\n}\n// 测试案例\nJobFactory('Javascript', 'content');\n\n```\n\n问题？又来一批课程，需求各不同，之前的需求一直在变，不仅要添加类，还要修改工厂函数，可能未来的需求还会在变。引申相互工厂方法模式，这样以后每需要一个类，只需要添加这个类。\n\n> 工厂方法模式本意是说将实际创建对象工作推迟到子类当中，这样核心类就成了抽象类，不过对应javascript不必这么深究，javascript没有像传统创建抽象类那样的方式轻易创建抽象了类，所以在javascript中实现工厂方法模式我们只需要参考它的核心思想即可，所以我们可以将工厂方法看做是一个实例化对象的工厂类，安全起见，我们采用安全模式类，而我们将创建对象的基类放在工厂方法类的原型中即可。\n\n#### 安全的工厂方法\n\n```javascript\n// 安全模式创建的工厂类\nvar Factory = function(type, content) {\n    if(this instanceof Factory) {\n        var s = new this[type] (content);\n        return s;\n    } else {\n        return new Factory(type, content);\n    }\n}\n// 工厂原型中设置创建所用类型数据对象的基类\nFactory.prototype = {\n    Java: function(content) {\n        // ....\n    },\n    javascript: function(content) {\n        // ....\n    },\n    UI: function(content) {\n        this.content = content;\n        (function(content)) {\n            var div = documnet.createElement('div');\n            div.innerHTML = content;\n            div.style.border = '1pc solid #ccc';\n            document.getElementById('container').appendChild(div);\n        }\n    }(content)\n}\nvar data = [{type: 'java', content: 'jajaja'},{type: 'php', content: 'phphphp'}]\ndata.map(function(item) {\n    Factory(item.type, item.content);\n})\n```\n> 优点，如果添加类，只需在Factory.prototype中添加，适用于创建多类对象，同时避免使用者与对象之间的耦合，用户不必关心创建该对象的具体类，只需调用工厂方法即可。\n\n### 出现的都是幻觉---抽象工厂模式\n\n> 通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建每一类产品的实例。\n\n抽象工厂模式一般不用来创建具体对象，一般用它作为父类来创建一个子类。\n\n```javascript\n// 抽象工厂方法\nvar VericleFactory = function(subType, superType) {\n    // 判断抽象工厂中是否有该抽象类\n    if(typeof VericleFactory[superType] === 'function') {\n        function F() {}\n        // 继承父类属性方法\n        F.prototype = new VericleFactory[superType]();\n        // 将子类constructor指向子类\n        subType.constructor = superType;\n        // 子类原型继承父类\n        subType.prototype = new F();\n    } else {\n        // 不存在该抽象类抛出错误 \n        return new Error('未创建该抽象类')\n    }   \n}\n// 某一个车的抽象类\nVericleFactory.Truck = function() {\n    this.type = 'truck'\n}\nVericleFactory.Truck.prototype = {\n    getPrice: function() {\n        return new Error('抽象方法不可调用')\n    },\n    getTrainload: function() {\n        return new Error('抽象方法不可调用')\n    }\n}\n// 奔驰汽车子类\nvar BenzTruck = function(price, trainLoad) {\n    this.price = price;\n    this.trainLoad = trainLoad;\n}\n// 抽象方法实现对Truck抽象类的继承\nVericleFactory(BenzTruck, \"Truck\");\nBenzTruck.prototype.getPrice = function() {\n    return this.price;\n}\nBenzTruck.prototype.getTrainload = function() {\n    return this.getTrainload;\n}\n// 测试\nvar truck = new BenzTruck(100, 10000);\nconsole.log(truck.getPrice)   // 100\nconsole.log(truck.type)       // truck\n\n```\n\n> 总结：抽象工厂模式是设计模式中最抽象的一种，也是创建模式中唯一一种抽象化创建模式，该模式创建出的结果不是一个真实的对象实例，而是一个类簇，它制定了类的结构，这也就区别于简单工厂模式创建单一对象，工厂方法模式创建多类对象，当然由于JavaScript中不支持抽象化创建与虚拟方法，所以导致这种模式不能像其他面向对象语言中应用的那么广泛。\n\n### 分即是合---建造者模式\n\n> 将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示。\n\n创建对象的另一种新式：建造者模式\n\n建造者模式更注重的是创建的细节。\n\n### 语言之魂---原型模式\n\n> 用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法。\n\n```javascript\nfunction prototypeExtend() {\n  var F = function() {},\n  args = arguments,\n    i = 0,\n    len = args.length;\n    // console.log(arguments)\n  for (; i < len; i++) {\n    for (var j in args[i]) {\n      F.prototype[j] = args[i][j];\n      console.log(F.prototype)\n    }\n  }\n  return new F();\n}\n\nvar penguin = prototypeExtend(\n  {\n    speed: 20,\n    swim: function() {\n      console.log(\".......1\");\n    }\n  },\n  {\n    sd: 300,\n    run: function(speed) {\n      console.log(\"......2\"+ speed);\n    }\n  },\n  {\n    jump: function() {\n      console.log(\".........3\");\n    }\n  }\n);\npenguin.swim()\npenguin.run(10)\npenguin.jump()\n\n```\n\n> 总结：原型模式可以让多个对象分享同一个原型对象的属性和方法，这也是一种继承方式，不过这种继承的实现是不需要创建的，而是将原型对象分享给那些继承的对象，当然有时需要让每个继承对象独立拥有一份原型对象，此时我们就需要对原型对象进行复制。\n\n由此可以看出，原型对象更适合在创建复杂的对象时，对于那些需求一直在变化而导致对象结构不停的改变时，将那些比较稳定的属性与方法共用而提取的继承的实现。\n\n### 一个人的寂寞---单例模式\n\n> 单例模式：有被称为单体模式，是只允许实例化一次的对象类，有时我们也用一个对象来规划一个命名空间，井井有条地管理对象上的属性个方法。\n\nJavaScript中最常见的一种模式，这种模式经常为我们提供一个命名空间，如我们使用过的jQuery库，单例模式就为它提供利润一个命名空间jQuery。\n\n> 命名空间？？？？\n\n就是nameSpace，解决一类问题：为了让代码更易懂，人们常常用单词或者拼音定义变量或者方法，但由于有限的单词量，所以不同的人定义的变量使用的单词名称很有可能重复，此时就需要用命名空间来约束每个人定义的变量来解决这类问题。\n\n```javascript\nfunction g(id) {\n    return document.getElementById(id)\n}\nfunction css(id, key, value) {\n    g(id).style[key] = value;\n}\nfunction on(id ,type, fn) {\n    g(id)['on' + type] = fn;\n}\n// ................\n\n// 命名空间\nvar My = {\n    g: function() {\n        return document.getElementById(id)\n    },\n    css: function() {\n        this.g(id).style[key] = value;\n    },\n    on: function() {\n        this.g(id)['on' + type] = fn;\n    }\n}\n\n```\n> 单例模式的其他作用：就是通过单例模式来控制自己的每个功能模块。\n\n> 创建一个小型代码库\n\n```javascript\nvar A= {\n    Util: {\n        util_1: function() {},\n         util_2: function() {}\n    },\n    Tool: {\n        tool_1: function() {},\n        tool_2: function() {}\n    },\n    Ajax: function () {\n        ajax_1: function() {},\n        ajax_2: function() {}\n    }\n}\n\nA.Util.util_1();\n// ........\n\n```\n> 无法修改的静态变量\n\n用单例模式管理静态变量\n\n```javascript\nvar Conf = (function() {\n    var conf = {\n        MAX_NUM: 100,\n        MIN_NUM: 1,\n        COUNT: 1000\n    }\n    return {\n        get: function(name) {\n            return conf[name] ? conf[name] : null\n        }\n    }\n})()\nvar COUNT = Conf.get('COUNT')\n\n```\n> 惰性单例\n\n有时候对于单例对象需要延迟创建，所以在单例中还存在一种延迟创建的形式，有人也称之为‘惰性创建’。\n\n```javascript\n// 惰性载入单例\nvar LazySingle = (function() {\n    // 单例实例引用\n    var instance = null;\n    // 单例\n    function Single() {\n        // 这里定义私有属性和方法\n        return {\n            publicMethod: function() {},\n            punlicProperty: '1.0'\n        }\n    }\n    // 获取单例对象接口\n    if(!instance) {\n        instance = Single()\n    }\n    // 返回单例\n    return instance;\n} )()\n\nconsole.log(LazySingle().punlicProperty);  // 1.0\n\n```\n","slug":"javascript/创建型设计模式","published":1,"updated":"2018-05-31T10:27:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3d7000cuox15u3i1hhi","content":"<blockquote>\n<p>创建型设计模式是一类处理对象创建的设计模式，通过某种方法控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"神奇的魔术师—简单工厂模式\"><a href=\"#神奇的魔术师—简单工厂模式\" class=\"headerlink\" title=\"神奇的魔术师—简单工厂模式\"></a>神奇的魔术师—简单工厂模式</h3><blockquote>\n<p>简单工厂模式，有叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例，主要用来创建同一类对象。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//例子  用登录注册提示</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> LoginAlert = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.content = text;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">LoginAlert.prototype.show = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> userNameAlert = <span class=\"keyword\">new</span> LoginAlert(<span class=\"string\">'用户名不能多于16个字母数字'</span>)</span><br><span class=\"line\">userNameAlert.show()</span><br><span class=\"line\"><span class=\"keyword\">var</span> passWordAlert = <span class=\"keyword\">new</span> LoginAlert(<span class=\"string\">'输入的密码不正确'</span>)</span><br><span class=\"line\">passWordAlert.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> LoginConfirm = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.content = text;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">LoginConfirm.prototype.show = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> loginFailConfirm = <span class=\"keyword\">new</span> LoginConfirm(<span class=\"string\">'用户名不能多于16个字母数字'</span>)</span><br><span class=\"line\">loginFailConfirm.show();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> LoginPrompt = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.content = text;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">LoginPrompt.prototype.show = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ...................</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果类太多，那么提供一个。</p>\n</blockquote>\n<p>别人想借用我的方法，写注册模块，缺点类名太多，其他人每次创建还要找到对应的类，太麻烦，而且是以login开头，最好封装在一个函数里，其他人只需要记住这个函数名，通过这个函数就可以创建我需要的对象为我所用，这个函数通常被称为工厂函数，这种模式叫简单工厂模式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> PopFactory= <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'alert'</span> :</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoginAlert()</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'confirm'</span> :</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoginConfirm()</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'prompt'</span> :</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoginPrompt()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这三个类有很多地方是相同的，是可以抽象提取出来共用的，也可用简单工厂方式实现它们。</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>一个对象有时也可代替许多类</p>\n</blockquote>\n<p>简单工厂模式的理念就是创建对象，上面这种方式是对不同的类实例化，除此之外简单工厂模式还可以用来创建相似对象，上面创建的几个类很多地方都比较相似，提取相似，针对不相似处理，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createPop</span>(<span class=\"params\">type, text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">    o.content = text;</span><br><span class=\"line\">    o.show= <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 显示方法</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(type == <span class=\"string\">'alert'</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 差异部分</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(type == <span class=\"string\">'prompt'</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 差异部分</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(type == <span class=\"string\">'confirm'</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 差异部分</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 调用，创建提示框</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> userNameAlert = createPop(<span class=\"string\">'alert'</span>, <span class=\"string\">'提示文字'</span>)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>总结：两种创建方式区别，第一种通过实例化对象创建，如果这些类继承同一父类，父类原型上的方法可以共用，第二种通过创建一个新对象然后包装增强其属性和功能来实现，每个对象都是一个新的个体，方法不能共用，选择哪种看实际需求。</p>\n</blockquote>\n<h3 id=\"给我一张名片—工厂方法模式\"><a href=\"#给我一张名片—工厂方法模式\" class=\"headerlink\" title=\"给我一张名片—工厂方法模式\"></a>给我一张名片—工厂方法模式</h3><blockquote>\n<p>通过对产品类的抽象使其创建业务主要负责用于创建多类产品的实例。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">需求，新来一批广告资源需要投资，一批java,一批php等等，不同课程字体颜色和大小不同。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 简单工厂</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Java = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">content</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// .......</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Php = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">content</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// .......</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Javascript = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">content</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// .......</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 学科工厂</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">JobFactory</span>(<span class=\"params\">type, content</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'java'</span> : </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Java(content)</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'php'</span> : </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Php(content)</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'Javascript'</span> : </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Javascript(content)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 测试案例</span></span><br><span class=\"line\">JobFactory(<span class=\"string\">'Javascript'</span>, <span class=\"string\">'content'</span>);</span><br></pre></td></tr></table></figure>\n<p>问题？又来一批课程，需求各不同，之前的需求一直在变，不仅要添加类，还要修改工厂函数，可能未来的需求还会在变。引申相互工厂方法模式，这样以后每需要一个类，只需要添加这个类。</p>\n<blockquote>\n<p>工厂方法模式本意是说将实际创建对象工作推迟到子类当中，这样核心类就成了抽象类，不过对应javascript不必这么深究，javascript没有像传统创建抽象类那样的方式轻易创建抽象了类，所以在javascript中实现工厂方法模式我们只需要参考它的核心思想即可，所以我们可以将工厂方法看做是一个实例化对象的工厂类，安全起见，我们采用安全模式类，而我们将创建对象的基类放在工厂方法类的原型中即可。</p>\n</blockquote>\n<h4 id=\"安全的工厂方法\"><a href=\"#安全的工厂方法\" class=\"headerlink\" title=\"安全的工厂方法\"></a>安全的工厂方法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 安全模式创建的工厂类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Factory = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, content</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> Factory) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> <span class=\"keyword\">this</span>[type] (content);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Factory(type, content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 工厂原型中设置创建所用类型数据对象的基类</span></span><br><span class=\"line\">Factory.prototype = &#123;</span><br><span class=\"line\">    Java: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">content</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ....</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    javascript: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">content</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ....</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    UI: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">content</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.content = content;</span><br><span class=\"line\">        (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">content</span>)) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> div = documnet.createElement(<span class=\"string\">'div'</span>);</span><br><span class=\"line\">            div.innerHTML = content;</span><br><span class=\"line\">            div.style.border = <span class=\"string\">'1pc solid #ccc'</span>;</span><br><span class=\"line\">            <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'container'</span>).appendChild(div);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;(content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = [&#123;<span class=\"attr\">type</span>: <span class=\"string\">'java'</span>, <span class=\"attr\">content</span>: <span class=\"string\">'jajaja'</span>&#125;,&#123;<span class=\"attr\">type</span>: <span class=\"string\">'php'</span>, <span class=\"attr\">content</span>: <span class=\"string\">'phphphp'</span>&#125;]</span><br><span class=\"line\">data.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">    Factory(item.type, item.content);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>优点，如果添加类，只需在Factory.prototype中添加，适用于创建多类对象，同时避免使用者与对象之间的耦合，用户不必关心创建该对象的具体类，只需调用工厂方法即可。</p>\n</blockquote>\n<h3 id=\"出现的都是幻觉—抽象工厂模式\"><a href=\"#出现的都是幻觉—抽象工厂模式\" class=\"headerlink\" title=\"出现的都是幻觉—抽象工厂模式\"></a>出现的都是幻觉—抽象工厂模式</h3><blockquote>\n<p>通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建每一类产品的实例。</p>\n</blockquote>\n<p>抽象工厂模式一般不用来创建具体对象，一般用它作为父类来创建一个子类。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 抽象工厂方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> VericleFactory = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">subType, superType</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断抽象工厂中是否有该抽象类</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> VericleFactory[superType] === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">        <span class=\"comment\">// 继承父类属性方法</span></span><br><span class=\"line\">        F.prototype = <span class=\"keyword\">new</span> VericleFactory[superType]();</span><br><span class=\"line\">        <span class=\"comment\">// 将子类constructor指向子类</span></span><br><span class=\"line\">        subType.constructor = superType;</span><br><span class=\"line\">        <span class=\"comment\">// 子类原型继承父类</span></span><br><span class=\"line\">        subType.prototype = <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不存在该抽象类抛出错误 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'未创建该抽象类'</span>)</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 某一个车的抽象类</span></span><br><span class=\"line\">VericleFactory.Truck = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.type = <span class=\"string\">'truck'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">VericleFactory.Truck.prototype = &#123;</span><br><span class=\"line\">    getPrice: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'抽象方法不可调用'</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getTrainload: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'抽象方法不可调用'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 奔驰汽车子类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> BenzTruck = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">price, trainLoad</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.price = price;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.trainLoad = trainLoad;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 抽象方法实现对Truck抽象类的继承</span></span><br><span class=\"line\">VericleFactory(BenzTruck, <span class=\"string\">\"Truck\"</span>);</span><br><span class=\"line\">BenzTruck.prototype.getPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.price;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">BenzTruck.prototype.getTrainload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getTrainload;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> truck = <span class=\"keyword\">new</span> BenzTruck(<span class=\"number\">100</span>, <span class=\"number\">10000</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(truck.getPrice)   <span class=\"comment\">// 100</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(truck.type)       <span class=\"comment\">// truck</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>总结：抽象工厂模式是设计模式中最抽象的一种，也是创建模式中唯一一种抽象化创建模式，该模式创建出的结果不是一个真实的对象实例，而是一个类簇，它制定了类的结构，这也就区别于简单工厂模式创建单一对象，工厂方法模式创建多类对象，当然由于JavaScript中不支持抽象化创建与虚拟方法，所以导致这种模式不能像其他面向对象语言中应用的那么广泛。</p>\n</blockquote>\n<h3 id=\"分即是合—建造者模式\"><a href=\"#分即是合—建造者模式\" class=\"headerlink\" title=\"分即是合—建造者模式\"></a>分即是合—建造者模式</h3><blockquote>\n<p>将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示。</p>\n</blockquote>\n<p>创建对象的另一种新式：建造者模式</p>\n<p>建造者模式更注重的是创建的细节。</p>\n<h3 id=\"语言之魂—原型模式\"><a href=\"#语言之魂—原型模式\" class=\"headerlink\" title=\"语言之魂—原型模式\"></a>语言之魂—原型模式</h3><blockquote>\n<p>用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">prototypeExtend</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">  args = <span class=\"built_in\">arguments</span>,</span><br><span class=\"line\">    i = <span class=\"number\">0</span>,</span><br><span class=\"line\">    len = args.length;</span><br><span class=\"line\">    <span class=\"comment\">// console.log(arguments)</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j <span class=\"keyword\">in</span> args[i]) &#123;</span><br><span class=\"line\">      F.prototype[j] = args[i][j];</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(F.prototype)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> penguin = prototypeExtend(</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    speed: <span class=\"number\">20</span>,</span><br><span class=\"line\">    swim: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\".......1\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    sd: <span class=\"number\">300</span>,</span><br><span class=\"line\">    run: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">speed</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"......2\"</span>+ speed);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    jump: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\".........3\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\">penguin.swim()</span><br><span class=\"line\">penguin.run(<span class=\"number\">10</span>)</span><br><span class=\"line\">penguin.jump()</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>总结：原型模式可以让多个对象分享同一个原型对象的属性和方法，这也是一种继承方式，不过这种继承的实现是不需要创建的，而是将原型对象分享给那些继承的对象，当然有时需要让每个继承对象独立拥有一份原型对象，此时我们就需要对原型对象进行复制。</p>\n</blockquote>\n<p>由此可以看出，原型对象更适合在创建复杂的对象时，对于那些需求一直在变化而导致对象结构不停的改变时，将那些比较稳定的属性与方法共用而提取的继承的实现。</p>\n<h3 id=\"一个人的寂寞—单例模式\"><a href=\"#一个人的寂寞—单例模式\" class=\"headerlink\" title=\"一个人的寂寞—单例模式\"></a>一个人的寂寞—单例模式</h3><blockquote>\n<p>单例模式：有被称为单体模式，是只允许实例化一次的对象类，有时我们也用一个对象来规划一个命名空间，井井有条地管理对象上的属性个方法。</p>\n</blockquote>\n<p>JavaScript中最常见的一种模式，这种模式经常为我们提供一个命名空间，如我们使用过的jQuery库，单例模式就为它提供利润一个命名空间jQuery。</p>\n<blockquote>\n<p>命名空间？？？？</p>\n</blockquote>\n<p>就是nameSpace，解决一类问题：为了让代码更易懂，人们常常用单词或者拼音定义变量或者方法，但由于有限的单词量，所以不同的人定义的变量使用的单词名称很有可能重复，此时就需要用命名空间来约束每个人定义的变量来解决这类问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">document</span>.getElementById(id)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">css</span>(<span class=\"params\">id, key, value</span>) </span>&#123;</span><br><span class=\"line\">    g(id).style[key] = value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">on</span>(<span class=\"params\">id ,type, fn</span>) </span>&#123;</span><br><span class=\"line\">    g(id)[<span class=\"string\">'on'</span> + type] = fn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ................</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 命名空间</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> My = &#123;</span><br><span class=\"line\">    g: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">document</span>.getElementById(id)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    css: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.g(id).style[key] = value;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    on: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.g(id)[<span class=\"string\">'on'</span> + type] = fn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>单例模式的其他作用：就是通过单例模式来控制自己的每个功能模块。</p>\n<p>创建一个小型代码库</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> A= &#123;</span><br><span class=\"line\">    Util: &#123;</span><br><span class=\"line\">        util_1: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">         util_2: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    Tool: &#123;</span><br><span class=\"line\">        tool_1: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">        tool_2: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    Ajax: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        ajax_1: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">        ajax_2: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">A.Util.util_1();</span><br><span class=\"line\"><span class=\"comment\">// ........</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>无法修改的静态变量</p>\n</blockquote>\n<p>用单例模式管理静态变量</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Conf = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> conf = &#123;</span><br><span class=\"line\">        MAX_NUM: <span class=\"number\">100</span>,</span><br><span class=\"line\">        MIN_NUM: <span class=\"number\">1</span>,</span><br><span class=\"line\">        COUNT: <span class=\"number\">1000</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> conf[name] ? conf[name] : <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"><span class=\"keyword\">var</span> COUNT = Conf.get(<span class=\"string\">'COUNT'</span>)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>惰性单例</p>\n</blockquote>\n<p>有时候对于单例对象需要延迟创建，所以在单例中还存在一种延迟创建的形式，有人也称之为‘惰性创建’。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 惰性载入单例</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> LazySingle = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 单例实例引用</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> instance = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 单例</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Single</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里定义私有属性和方法</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            publicMethod: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">            punlicProperty: <span class=\"string\">'1.0'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 获取单例对象接口</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!instance) &#123;</span><br><span class=\"line\">        instance = Single()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回单例</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125; )()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(LazySingle().punlicProperty);  <span class=\"comment\">// 1.0</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>创建型设计模式是一类处理对象创建的设计模式，通过某种方法控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度。</p>\n</blockquote>","more":"<h3 id=\"神奇的魔术师—简单工厂模式\"><a href=\"#神奇的魔术师—简单工厂模式\" class=\"headerlink\" title=\"神奇的魔术师—简单工厂模式\"></a>神奇的魔术师—简单工厂模式</h3><blockquote>\n<p>简单工厂模式，有叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例，主要用来创建同一类对象。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//例子  用登录注册提示</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> LoginAlert = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.content = text;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">LoginAlert.prototype.show = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> userNameAlert = <span class=\"keyword\">new</span> LoginAlert(<span class=\"string\">'用户名不能多于16个字母数字'</span>)</span><br><span class=\"line\">userNameAlert.show()</span><br><span class=\"line\"><span class=\"keyword\">var</span> passWordAlert = <span class=\"keyword\">new</span> LoginAlert(<span class=\"string\">'输入的密码不正确'</span>)</span><br><span class=\"line\">passWordAlert.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> LoginConfirm = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.content = text;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">LoginConfirm.prototype.show = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> loginFailConfirm = <span class=\"keyword\">new</span> LoginConfirm(<span class=\"string\">'用户名不能多于16个字母数字'</span>)</span><br><span class=\"line\">loginFailConfirm.show();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> LoginPrompt = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.content = text;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">LoginPrompt.prototype.show = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ...................</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果类太多，那么提供一个。</p>\n</blockquote>\n<p>别人想借用我的方法，写注册模块，缺点类名太多，其他人每次创建还要找到对应的类，太麻烦，而且是以login开头，最好封装在一个函数里，其他人只需要记住这个函数名，通过这个函数就可以创建我需要的对象为我所用，这个函数通常被称为工厂函数，这种模式叫简单工厂模式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> PopFactory= <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'alert'</span> :</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoginAlert()</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'confirm'</span> :</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoginConfirm()</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'prompt'</span> :</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoginPrompt()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这三个类有很多地方是相同的，是可以抽象提取出来共用的，也可用简单工厂方式实现它们。</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>一个对象有时也可代替许多类</p>\n</blockquote>\n<p>简单工厂模式的理念就是创建对象，上面这种方式是对不同的类实例化，除此之外简单工厂模式还可以用来创建相似对象，上面创建的几个类很多地方都比较相似，提取相似，针对不相似处理，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createPop</span>(<span class=\"params\">type, text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">    o.content = text;</span><br><span class=\"line\">    o.show= <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 显示方法</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(type == <span class=\"string\">'alert'</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 差异部分</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(type == <span class=\"string\">'prompt'</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 差异部分</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(type == <span class=\"string\">'confirm'</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 差异部分</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 调用，创建提示框</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> userNameAlert = createPop(<span class=\"string\">'alert'</span>, <span class=\"string\">'提示文字'</span>)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>总结：两种创建方式区别，第一种通过实例化对象创建，如果这些类继承同一父类，父类原型上的方法可以共用，第二种通过创建一个新对象然后包装增强其属性和功能来实现，每个对象都是一个新的个体，方法不能共用，选择哪种看实际需求。</p>\n</blockquote>\n<h3 id=\"给我一张名片—工厂方法模式\"><a href=\"#给我一张名片—工厂方法模式\" class=\"headerlink\" title=\"给我一张名片—工厂方法模式\"></a>给我一张名片—工厂方法模式</h3><blockquote>\n<p>通过对产品类的抽象使其创建业务主要负责用于创建多类产品的实例。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">需求，新来一批广告资源需要投资，一批java,一批php等等，不同课程字体颜色和大小不同。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 简单工厂</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Java = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">content</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// .......</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Php = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">content</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// .......</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Javascript = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">content</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// .......</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 学科工厂</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">JobFactory</span>(<span class=\"params\">type, content</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'java'</span> : </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Java(content)</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'php'</span> : </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Php(content)</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'Javascript'</span> : </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Javascript(content)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 测试案例</span></span><br><span class=\"line\">JobFactory(<span class=\"string\">'Javascript'</span>, <span class=\"string\">'content'</span>);</span><br></pre></td></tr></table></figure>\n<p>问题？又来一批课程，需求各不同，之前的需求一直在变，不仅要添加类，还要修改工厂函数，可能未来的需求还会在变。引申相互工厂方法模式，这样以后每需要一个类，只需要添加这个类。</p>\n<blockquote>\n<p>工厂方法模式本意是说将实际创建对象工作推迟到子类当中，这样核心类就成了抽象类，不过对应javascript不必这么深究，javascript没有像传统创建抽象类那样的方式轻易创建抽象了类，所以在javascript中实现工厂方法模式我们只需要参考它的核心思想即可，所以我们可以将工厂方法看做是一个实例化对象的工厂类，安全起见，我们采用安全模式类，而我们将创建对象的基类放在工厂方法类的原型中即可。</p>\n</blockquote>\n<h4 id=\"安全的工厂方法\"><a href=\"#安全的工厂方法\" class=\"headerlink\" title=\"安全的工厂方法\"></a>安全的工厂方法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 安全模式创建的工厂类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Factory = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, content</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> Factory) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> <span class=\"keyword\">this</span>[type] (content);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Factory(type, content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 工厂原型中设置创建所用类型数据对象的基类</span></span><br><span class=\"line\">Factory.prototype = &#123;</span><br><span class=\"line\">    Java: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">content</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ....</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    javascript: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">content</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ....</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    UI: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">content</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.content = content;</span><br><span class=\"line\">        (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">content</span>)) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> div = documnet.createElement(<span class=\"string\">'div'</span>);</span><br><span class=\"line\">            div.innerHTML = content;</span><br><span class=\"line\">            div.style.border = <span class=\"string\">'1pc solid #ccc'</span>;</span><br><span class=\"line\">            <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'container'</span>).appendChild(div);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;(content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = [&#123;<span class=\"attr\">type</span>: <span class=\"string\">'java'</span>, <span class=\"attr\">content</span>: <span class=\"string\">'jajaja'</span>&#125;,&#123;<span class=\"attr\">type</span>: <span class=\"string\">'php'</span>, <span class=\"attr\">content</span>: <span class=\"string\">'phphphp'</span>&#125;]</span><br><span class=\"line\">data.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">    Factory(item.type, item.content);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>优点，如果添加类，只需在Factory.prototype中添加，适用于创建多类对象，同时避免使用者与对象之间的耦合，用户不必关心创建该对象的具体类，只需调用工厂方法即可。</p>\n</blockquote>\n<h3 id=\"出现的都是幻觉—抽象工厂模式\"><a href=\"#出现的都是幻觉—抽象工厂模式\" class=\"headerlink\" title=\"出现的都是幻觉—抽象工厂模式\"></a>出现的都是幻觉—抽象工厂模式</h3><blockquote>\n<p>通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建每一类产品的实例。</p>\n</blockquote>\n<p>抽象工厂模式一般不用来创建具体对象，一般用它作为父类来创建一个子类。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 抽象工厂方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> VericleFactory = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">subType, superType</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断抽象工厂中是否有该抽象类</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> VericleFactory[superType] === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">        <span class=\"comment\">// 继承父类属性方法</span></span><br><span class=\"line\">        F.prototype = <span class=\"keyword\">new</span> VericleFactory[superType]();</span><br><span class=\"line\">        <span class=\"comment\">// 将子类constructor指向子类</span></span><br><span class=\"line\">        subType.constructor = superType;</span><br><span class=\"line\">        <span class=\"comment\">// 子类原型继承父类</span></span><br><span class=\"line\">        subType.prototype = <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不存在该抽象类抛出错误 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'未创建该抽象类'</span>)</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 某一个车的抽象类</span></span><br><span class=\"line\">VericleFactory.Truck = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.type = <span class=\"string\">'truck'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">VericleFactory.Truck.prototype = &#123;</span><br><span class=\"line\">    getPrice: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'抽象方法不可调用'</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getTrainload: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'抽象方法不可调用'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 奔驰汽车子类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> BenzTruck = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">price, trainLoad</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.price = price;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.trainLoad = trainLoad;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 抽象方法实现对Truck抽象类的继承</span></span><br><span class=\"line\">VericleFactory(BenzTruck, <span class=\"string\">\"Truck\"</span>);</span><br><span class=\"line\">BenzTruck.prototype.getPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.price;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">BenzTruck.prototype.getTrainload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getTrainload;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> truck = <span class=\"keyword\">new</span> BenzTruck(<span class=\"number\">100</span>, <span class=\"number\">10000</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(truck.getPrice)   <span class=\"comment\">// 100</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(truck.type)       <span class=\"comment\">// truck</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>总结：抽象工厂模式是设计模式中最抽象的一种，也是创建模式中唯一一种抽象化创建模式，该模式创建出的结果不是一个真实的对象实例，而是一个类簇，它制定了类的结构，这也就区别于简单工厂模式创建单一对象，工厂方法模式创建多类对象，当然由于JavaScript中不支持抽象化创建与虚拟方法，所以导致这种模式不能像其他面向对象语言中应用的那么广泛。</p>\n</blockquote>\n<h3 id=\"分即是合—建造者模式\"><a href=\"#分即是合—建造者模式\" class=\"headerlink\" title=\"分即是合—建造者模式\"></a>分即是合—建造者模式</h3><blockquote>\n<p>将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示。</p>\n</blockquote>\n<p>创建对象的另一种新式：建造者模式</p>\n<p>建造者模式更注重的是创建的细节。</p>\n<h3 id=\"语言之魂—原型模式\"><a href=\"#语言之魂—原型模式\" class=\"headerlink\" title=\"语言之魂—原型模式\"></a>语言之魂—原型模式</h3><blockquote>\n<p>用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">prototypeExtend</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">  args = <span class=\"built_in\">arguments</span>,</span><br><span class=\"line\">    i = <span class=\"number\">0</span>,</span><br><span class=\"line\">    len = args.length;</span><br><span class=\"line\">    <span class=\"comment\">// console.log(arguments)</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j <span class=\"keyword\">in</span> args[i]) &#123;</span><br><span class=\"line\">      F.prototype[j] = args[i][j];</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(F.prototype)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> penguin = prototypeExtend(</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    speed: <span class=\"number\">20</span>,</span><br><span class=\"line\">    swim: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\".......1\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    sd: <span class=\"number\">300</span>,</span><br><span class=\"line\">    run: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">speed</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"......2\"</span>+ speed);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    jump: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\".........3\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\">penguin.swim()</span><br><span class=\"line\">penguin.run(<span class=\"number\">10</span>)</span><br><span class=\"line\">penguin.jump()</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>总结：原型模式可以让多个对象分享同一个原型对象的属性和方法，这也是一种继承方式，不过这种继承的实现是不需要创建的，而是将原型对象分享给那些继承的对象，当然有时需要让每个继承对象独立拥有一份原型对象，此时我们就需要对原型对象进行复制。</p>\n</blockquote>\n<p>由此可以看出，原型对象更适合在创建复杂的对象时，对于那些需求一直在变化而导致对象结构不停的改变时，将那些比较稳定的属性与方法共用而提取的继承的实现。</p>\n<h3 id=\"一个人的寂寞—单例模式\"><a href=\"#一个人的寂寞—单例模式\" class=\"headerlink\" title=\"一个人的寂寞—单例模式\"></a>一个人的寂寞—单例模式</h3><blockquote>\n<p>单例模式：有被称为单体模式，是只允许实例化一次的对象类，有时我们也用一个对象来规划一个命名空间，井井有条地管理对象上的属性个方法。</p>\n</blockquote>\n<p>JavaScript中最常见的一种模式，这种模式经常为我们提供一个命名空间，如我们使用过的jQuery库，单例模式就为它提供利润一个命名空间jQuery。</p>\n<blockquote>\n<p>命名空间？？？？</p>\n</blockquote>\n<p>就是nameSpace，解决一类问题：为了让代码更易懂，人们常常用单词或者拼音定义变量或者方法，但由于有限的单词量，所以不同的人定义的变量使用的单词名称很有可能重复，此时就需要用命名空间来约束每个人定义的变量来解决这类问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">document</span>.getElementById(id)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">css</span>(<span class=\"params\">id, key, value</span>) </span>&#123;</span><br><span class=\"line\">    g(id).style[key] = value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">on</span>(<span class=\"params\">id ,type, fn</span>) </span>&#123;</span><br><span class=\"line\">    g(id)[<span class=\"string\">'on'</span> + type] = fn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ................</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 命名空间</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> My = &#123;</span><br><span class=\"line\">    g: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">document</span>.getElementById(id)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    css: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.g(id).style[key] = value;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    on: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.g(id)[<span class=\"string\">'on'</span> + type] = fn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>单例模式的其他作用：就是通过单例模式来控制自己的每个功能模块。</p>\n<p>创建一个小型代码库</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> A= &#123;</span><br><span class=\"line\">    Util: &#123;</span><br><span class=\"line\">        util_1: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">         util_2: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    Tool: &#123;</span><br><span class=\"line\">        tool_1: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">        tool_2: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    Ajax: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        ajax_1: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">        ajax_2: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">A.Util.util_1();</span><br><span class=\"line\"><span class=\"comment\">// ........</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>无法修改的静态变量</p>\n</blockquote>\n<p>用单例模式管理静态变量</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Conf = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> conf = &#123;</span><br><span class=\"line\">        MAX_NUM: <span class=\"number\">100</span>,</span><br><span class=\"line\">        MIN_NUM: <span class=\"number\">1</span>,</span><br><span class=\"line\">        COUNT: <span class=\"number\">1000</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> conf[name] ? conf[name] : <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"><span class=\"keyword\">var</span> COUNT = Conf.get(<span class=\"string\">'COUNT'</span>)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>惰性单例</p>\n</blockquote>\n<p>有时候对于单例对象需要延迟创建，所以在单例中还存在一种延迟创建的形式，有人也称之为‘惰性创建’。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 惰性载入单例</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> LazySingle = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 单例实例引用</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> instance = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 单例</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Single</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里定义私有属性和方法</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            publicMethod: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">            punlicProperty: <span class=\"string\">'1.0'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 获取单例对象接口</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!instance) &#123;</span><br><span class=\"line\">        instance = Single()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回单例</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125; )()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(LazySingle().punlicProperty);  <span class=\"comment\">// 1.0</span></span><br></pre></td></tr></table></figure>"},{"title":"行为型设计模式","date":"2017-12-05T02:41:20.000Z","_content":"\n> 行为型设计模式用于不同对象之间职责划分或算法抽象，行为型设计模式不仅仅涉及类和对象，还涉及类或对象之间的交流模式并加以实现。\n\n<!-- more -->\n\n### 通信卫星---观察者模式\n\n> 观察者模式(Observer)：\b又被称作发布-订阅模式或消息机制，定义了一种依赖关系，解决了主体对象与观察者之间功能的耦合。\n\n想实现自己的需求而添加一些功能代码，但有不想新添加的代码影响到他人实现的代码，也就是不想让自己的模块与他人开发的模块严重耦合在一起，观察者模式是比较理想的解决方案。\n\n```javascript\n// 以卫星监控飞机为例，创建一个观察者，他有一个消息容器，订阅消息方法，取消订阅消息方法，发送订阅的消息方法。\n// 将观察者放在闭包中，当页面加载时就立即执行\nvar Observer = (function() {\n  // 防止消息队列暴露而被篡改故将消息容器作为静态私有变量保存\n  var _message = {}\n  return {\n    regist: function(type, fn) {\n      // 注册\n      if(typeof _message[type] === 'undefined') {\n        // 如果此消息不存在则应该创建一个改消息类型\n        // 将动作推入到改消息对应的动作执行队列中\n        _message[type] = [fn];\n      } else {\n        // 如果此消息不存在\n        // 将动作方法推入该消息对应的动作执行队列中\n        _message[type].push(fn);\n      }\n    },\n    fire: function(type, agrs) {\n      // 发布\n      // 当观察者发布一个消息时，将所有的订阅者订阅的消息一次执行\n      if(!_message[type]) {\n        return;\n      }\n      // 定义消息信息\n      var events = {\n        type: type,\n        agrs: agrs || {}\n      },\n      i = 0,\n      len = _message[type].length;\n      // 遍历消息动作\n      for(; i< len; i++) {\n        // 依次执行注册的消息对应的动作序列\n        _message[type][i].call(this, events);\n      }\n    },\n    remove: function() {\n      // 移除\n      // 如果消息动作队列存在\n      if(_message[type] instanceof Array) {\n        // 从最后一个消息动作遍历\n        var i= _message[type].length - 1;\n        for(; i>0; i--) {\n          // 如果存在该动作则在消息动作序列中移除相应动作\n          _message[type][i] === fn && _message[type].splice(i, 1);\n        }\n      }\n    }\n  }\n})()\nObserve.regist('test', function(e) {\n  console.log(e.type, e.agrs.msg);\n})\nObserve.fire('test', {msg: '传递参数'});\n```\n\n```javascript\nfunction $(id) {\n  return document.getElementById(id);\n}\n// 甲\n(function() {\n  function addMsgItem(e) {\n    var text = e.args.text,\n    ul = $('msg'),\n    li = document.createElement('span');\n    li.innerHTML = text;\n    span.onclick = function() {\n      ul.removeChild(li);\n      Observer.fire('removeCommentMessage', {num: -1});\n    }\n    li.appendChild(span);\n    ul.appendChild(li);\n  } \n  Observer.regist('addCommentMessage', addMsgItem)\n})()\n// 乙\n(function() {\n  function changeMsgNum(e) {\n    var num = e.args.num;\n    $('msg_num').innerHTML - parseInt($('msg_num').innerHTML) + num;\n  }\n  Observer\n    .regist('addCommentMessage', changeMsgNum)\n    .regist('removeCommentMessage', changeMsgNum)\n})();\n// 丙\n(function() {\n  $('user_submit').onclick = function() {\n    var text = $('user_input');\n    if(text.value === '') {\n      return;\n    }\n    Observer.fire('addCommentMessage', {\n      text: text.value,\n      num: 1\n    });\n    text.value = '';\n  }\n})();\n```\n> 总结：观察者模式最主要的作用是解决类或对象之间的耦合，解耦两个相互依赖的对象，使其依赖于观察者的消息机制，这样对于任意一个订阅者对象来说，其他订阅者对象的改变不会影响到自身。\n\n### 超级玛丽---状态模式\n\n> 状态模式（State）:当一个对象的内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对象。\n\n> 总结：状态模式既是解决程序中臃肿的分支判断语句问题，将每个分支转化为一种状态独立出来，方便每种状态的管理又不至于每次执行时遍历所有分支。在程序中到底产出哪种行为结果，决定于选择哪种状态，而选择何种状态又是在程序运行时决定的。当然状态模式最终的目的即是简化分支判断流程。\n\n### 活诸葛---策略模式\n\n> 策略模式（Strategy）：将定义的一组算法封装起来，使其相互之间可以替换，封装的算法具有一定的独立性，不会随客户端变化而变化。\n\n\n\n\n\n\n\n","source":"_posts/javascript/行为型设计模式.md","raw":"---\ntitle: 行为型设计模式\ncategories:\n  - 前端技术\ntags:\n  - js\ndate: 2017-12-05 10:41:20\n---\n\n> 行为型设计模式用于不同对象之间职责划分或算法抽象，行为型设计模式不仅仅涉及类和对象，还涉及类或对象之间的交流模式并加以实现。\n\n<!-- more -->\n\n### 通信卫星---观察者模式\n\n> 观察者模式(Observer)：\b又被称作发布-订阅模式或消息机制，定义了一种依赖关系，解决了主体对象与观察者之间功能的耦合。\n\n想实现自己的需求而添加一些功能代码，但有不想新添加的代码影响到他人实现的代码，也就是不想让自己的模块与他人开发的模块严重耦合在一起，观察者模式是比较理想的解决方案。\n\n```javascript\n// 以卫星监控飞机为例，创建一个观察者，他有一个消息容器，订阅消息方法，取消订阅消息方法，发送订阅的消息方法。\n// 将观察者放在闭包中，当页面加载时就立即执行\nvar Observer = (function() {\n  // 防止消息队列暴露而被篡改故将消息容器作为静态私有变量保存\n  var _message = {}\n  return {\n    regist: function(type, fn) {\n      // 注册\n      if(typeof _message[type] === 'undefined') {\n        // 如果此消息不存在则应该创建一个改消息类型\n        // 将动作推入到改消息对应的动作执行队列中\n        _message[type] = [fn];\n      } else {\n        // 如果此消息不存在\n        // 将动作方法推入该消息对应的动作执行队列中\n        _message[type].push(fn);\n      }\n    },\n    fire: function(type, agrs) {\n      // 发布\n      // 当观察者发布一个消息时，将所有的订阅者订阅的消息一次执行\n      if(!_message[type]) {\n        return;\n      }\n      // 定义消息信息\n      var events = {\n        type: type,\n        agrs: agrs || {}\n      },\n      i = 0,\n      len = _message[type].length;\n      // 遍历消息动作\n      for(; i< len; i++) {\n        // 依次执行注册的消息对应的动作序列\n        _message[type][i].call(this, events);\n      }\n    },\n    remove: function() {\n      // 移除\n      // 如果消息动作队列存在\n      if(_message[type] instanceof Array) {\n        // 从最后一个消息动作遍历\n        var i= _message[type].length - 1;\n        for(; i>0; i--) {\n          // 如果存在该动作则在消息动作序列中移除相应动作\n          _message[type][i] === fn && _message[type].splice(i, 1);\n        }\n      }\n    }\n  }\n})()\nObserve.regist('test', function(e) {\n  console.log(e.type, e.agrs.msg);\n})\nObserve.fire('test', {msg: '传递参数'});\n```\n\n```javascript\nfunction $(id) {\n  return document.getElementById(id);\n}\n// 甲\n(function() {\n  function addMsgItem(e) {\n    var text = e.args.text,\n    ul = $('msg'),\n    li = document.createElement('span');\n    li.innerHTML = text;\n    span.onclick = function() {\n      ul.removeChild(li);\n      Observer.fire('removeCommentMessage', {num: -1});\n    }\n    li.appendChild(span);\n    ul.appendChild(li);\n  } \n  Observer.regist('addCommentMessage', addMsgItem)\n})()\n// 乙\n(function() {\n  function changeMsgNum(e) {\n    var num = e.args.num;\n    $('msg_num').innerHTML - parseInt($('msg_num').innerHTML) + num;\n  }\n  Observer\n    .regist('addCommentMessage', changeMsgNum)\n    .regist('removeCommentMessage', changeMsgNum)\n})();\n// 丙\n(function() {\n  $('user_submit').onclick = function() {\n    var text = $('user_input');\n    if(text.value === '') {\n      return;\n    }\n    Observer.fire('addCommentMessage', {\n      text: text.value,\n      num: 1\n    });\n    text.value = '';\n  }\n})();\n```\n> 总结：观察者模式最主要的作用是解决类或对象之间的耦合，解耦两个相互依赖的对象，使其依赖于观察者的消息机制，这样对于任意一个订阅者对象来说，其他订阅者对象的改变不会影响到自身。\n\n### 超级玛丽---状态模式\n\n> 状态模式（State）:当一个对象的内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对象。\n\n> 总结：状态模式既是解决程序中臃肿的分支判断语句问题，将每个分支转化为一种状态独立出来，方便每种状态的管理又不至于每次执行时遍历所有分支。在程序中到底产出哪种行为结果，决定于选择哪种状态，而选择何种状态又是在程序运行时决定的。当然状态模式最终的目的即是简化分支判断流程。\n\n### 活诸葛---策略模式\n\n> 策略模式（Strategy）：将定义的一组算法封装起来，使其相互之间可以替换，封装的算法具有一定的独立性，不会随客户端变化而变化。\n\n\n\n\n\n\n\n","slug":"javascript/行为型设计模式","published":1,"updated":"2018-05-31T10:27:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3d9000duox19a3swhyh","content":"<blockquote>\n<p>行为型设计模式用于不同对象之间职责划分或算法抽象，行为型设计模式不仅仅涉及类和对象，还涉及类或对象之间的交流模式并加以实现。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"通信卫星—观察者模式\"><a href=\"#通信卫星—观察者模式\" class=\"headerlink\" title=\"通信卫星—观察者模式\"></a>通信卫星—观察者模式</h3><blockquote>\n<p>观察者模式(Observer)：\b又被称作发布-订阅模式或消息机制，定义了一种依赖关系，解决了主体对象与观察者之间功能的耦合。</p>\n</blockquote>\n<p>想实现自己的需求而添加一些功能代码，但有不想新添加的代码影响到他人实现的代码，也就是不想让自己的模块与他人开发的模块严重耦合在一起，观察者模式是比较理想的解决方案。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 以卫星监控飞机为例，创建一个观察者，他有一个消息容器，订阅消息方法，取消订阅消息方法，发送订阅的消息方法。</span></span><br><span class=\"line\"><span class=\"comment\">// 将观察者放在闭包中，当页面加载时就立即执行</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Observer = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 防止消息队列暴露而被篡改故将消息容器作为静态私有变量保存</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> _message = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    regist: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, fn</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 注册</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> _message[type] === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果此消息不存在则应该创建一个改消息类型</span></span><br><span class=\"line\">        <span class=\"comment\">// 将动作推入到改消息对应的动作执行队列中</span></span><br><span class=\"line\">        _message[type] = [fn];</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果此消息不存在</span></span><br><span class=\"line\">        <span class=\"comment\">// 将动作方法推入该消息对应的动作执行队列中</span></span><br><span class=\"line\">        _message[type].push(fn);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    fire: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, agrs</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 发布</span></span><br><span class=\"line\">      <span class=\"comment\">// 当观察者发布一个消息时，将所有的订阅者订阅的消息一次执行</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(!_message[type]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 定义消息信息</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> events = &#123;</span><br><span class=\"line\">        type: type,</span><br><span class=\"line\">        agrs: agrs || &#123;&#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      i = <span class=\"number\">0</span>,</span><br><span class=\"line\">      len = _message[type].length;</span><br><span class=\"line\">      <span class=\"comment\">// 遍历消息动作</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(; i&lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 依次执行注册的消息对应的动作序列</span></span><br><span class=\"line\">        _message[type][i].call(<span class=\"keyword\">this</span>, events);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    remove: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 移除</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果消息动作队列存在</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(_message[type] <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从最后一个消息动作遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> i= _message[type].length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(; i&gt;<span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 如果存在该动作则在消息动作序列中移除相应动作</span></span><br><span class=\"line\">          _message[type][i] === fn &amp;&amp; _message[type].splice(i, <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\">Observe.regist(<span class=\"string\">'test'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e.type, e.agrs.msg);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Observe.fire(<span class=\"string\">'test'</span>, &#123;<span class=\"attr\">msg</span>: <span class=\"string\">'传递参数'</span>&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">$</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">document</span>.getElementById(id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 甲</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addMsgItem</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> text = e.args.text,</span><br><span class=\"line\">    ul = $(<span class=\"string\">'msg'</span>),</span><br><span class=\"line\">    li = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'span'</span>);</span><br><span class=\"line\">    li.innerHTML = text;</span><br><span class=\"line\">    span.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      ul.removeChild(li);</span><br><span class=\"line\">      Observer.fire(<span class=\"string\">'removeCommentMessage'</span>, &#123;<span class=\"attr\">num</span>: <span class=\"number\">-1</span>&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    li.appendChild(span);</span><br><span class=\"line\">    ul.appendChild(li);</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  Observer.regist(<span class=\"string\">'addCommentMessage'</span>, addMsgItem)</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"><span class=\"comment\">// 乙</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeMsgNum</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> num = e.args.num;</span><br><span class=\"line\">    $(<span class=\"string\">'msg_num'</span>).innerHTML - <span class=\"built_in\">parseInt</span>($(<span class=\"string\">'msg_num'</span>).innerHTML) + num;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Observer</span><br><span class=\"line\">    .regist(<span class=\"string\">'addCommentMessage'</span>, changeMsgNum)</span><br><span class=\"line\">    .regist(<span class=\"string\">'removeCommentMessage'</span>, changeMsgNum)</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"comment\">// 丙</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  $(<span class=\"string\">'user_submit'</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> text = $(<span class=\"string\">'user_input'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(text.value === <span class=\"string\">''</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Observer.fire(<span class=\"string\">'addCommentMessage'</span>, &#123;</span><br><span class=\"line\">      text: text.value,</span><br><span class=\"line\">      num: <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    text.value = <span class=\"string\">''</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>总结：观察者模式最主要的作用是解决类或对象之间的耦合，解耦两个相互依赖的对象，使其依赖于观察者的消息机制，这样对于任意一个订阅者对象来说，其他订阅者对象的改变不会影响到自身。</p>\n</blockquote>\n<h3 id=\"超级玛丽—状态模式\"><a href=\"#超级玛丽—状态模式\" class=\"headerlink\" title=\"超级玛丽—状态模式\"></a>超级玛丽—状态模式</h3><blockquote>\n<p>状态模式（State）:当一个对象的内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对象。</p>\n<p>总结：状态模式既是解决程序中臃肿的分支判断语句问题，将每个分支转化为一种状态独立出来，方便每种状态的管理又不至于每次执行时遍历所有分支。在程序中到底产出哪种行为结果，决定于选择哪种状态，而选择何种状态又是在程序运行时决定的。当然状态模式最终的目的即是简化分支判断流程。</p>\n</blockquote>\n<h3 id=\"活诸葛—策略模式\"><a href=\"#活诸葛—策略模式\" class=\"headerlink\" title=\"活诸葛—策略模式\"></a>活诸葛—策略模式</h3><blockquote>\n<p>策略模式（Strategy）：将定义的一组算法封装起来，使其相互之间可以替换，封装的算法具有一定的独立性，不会随客户端变化而变化。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>行为型设计模式用于不同对象之间职责划分或算法抽象，行为型设计模式不仅仅涉及类和对象，还涉及类或对象之间的交流模式并加以实现。</p>\n</blockquote>","more":"<h3 id=\"通信卫星—观察者模式\"><a href=\"#通信卫星—观察者模式\" class=\"headerlink\" title=\"通信卫星—观察者模式\"></a>通信卫星—观察者模式</h3><blockquote>\n<p>观察者模式(Observer)：\b又被称作发布-订阅模式或消息机制，定义了一种依赖关系，解决了主体对象与观察者之间功能的耦合。</p>\n</blockquote>\n<p>想实现自己的需求而添加一些功能代码，但有不想新添加的代码影响到他人实现的代码，也就是不想让自己的模块与他人开发的模块严重耦合在一起，观察者模式是比较理想的解决方案。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 以卫星监控飞机为例，创建一个观察者，他有一个消息容器，订阅消息方法，取消订阅消息方法，发送订阅的消息方法。</span></span><br><span class=\"line\"><span class=\"comment\">// 将观察者放在闭包中，当页面加载时就立即执行</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Observer = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 防止消息队列暴露而被篡改故将消息容器作为静态私有变量保存</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> _message = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    regist: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, fn</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 注册</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> _message[type] === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果此消息不存在则应该创建一个改消息类型</span></span><br><span class=\"line\">        <span class=\"comment\">// 将动作推入到改消息对应的动作执行队列中</span></span><br><span class=\"line\">        _message[type] = [fn];</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果此消息不存在</span></span><br><span class=\"line\">        <span class=\"comment\">// 将动作方法推入该消息对应的动作执行队列中</span></span><br><span class=\"line\">        _message[type].push(fn);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    fire: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, agrs</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 发布</span></span><br><span class=\"line\">      <span class=\"comment\">// 当观察者发布一个消息时，将所有的订阅者订阅的消息一次执行</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(!_message[type]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 定义消息信息</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> events = &#123;</span><br><span class=\"line\">        type: type,</span><br><span class=\"line\">        agrs: agrs || &#123;&#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      i = <span class=\"number\">0</span>,</span><br><span class=\"line\">      len = _message[type].length;</span><br><span class=\"line\">      <span class=\"comment\">// 遍历消息动作</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(; i&lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 依次执行注册的消息对应的动作序列</span></span><br><span class=\"line\">        _message[type][i].call(<span class=\"keyword\">this</span>, events);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    remove: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 移除</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果消息动作队列存在</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(_message[type] <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从最后一个消息动作遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> i= _message[type].length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(; i&gt;<span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 如果存在该动作则在消息动作序列中移除相应动作</span></span><br><span class=\"line\">          _message[type][i] === fn &amp;&amp; _message[type].splice(i, <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\">Observe.regist(<span class=\"string\">'test'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e.type, e.agrs.msg);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Observe.fire(<span class=\"string\">'test'</span>, &#123;<span class=\"attr\">msg</span>: <span class=\"string\">'传递参数'</span>&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">$</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">document</span>.getElementById(id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 甲</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addMsgItem</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> text = e.args.text,</span><br><span class=\"line\">    ul = $(<span class=\"string\">'msg'</span>),</span><br><span class=\"line\">    li = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'span'</span>);</span><br><span class=\"line\">    li.innerHTML = text;</span><br><span class=\"line\">    span.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      ul.removeChild(li);</span><br><span class=\"line\">      Observer.fire(<span class=\"string\">'removeCommentMessage'</span>, &#123;<span class=\"attr\">num</span>: <span class=\"number\">-1</span>&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    li.appendChild(span);</span><br><span class=\"line\">    ul.appendChild(li);</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  Observer.regist(<span class=\"string\">'addCommentMessage'</span>, addMsgItem)</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"><span class=\"comment\">// 乙</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeMsgNum</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> num = e.args.num;</span><br><span class=\"line\">    $(<span class=\"string\">'msg_num'</span>).innerHTML - <span class=\"built_in\">parseInt</span>($(<span class=\"string\">'msg_num'</span>).innerHTML) + num;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Observer</span><br><span class=\"line\">    .regist(<span class=\"string\">'addCommentMessage'</span>, changeMsgNum)</span><br><span class=\"line\">    .regist(<span class=\"string\">'removeCommentMessage'</span>, changeMsgNum)</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"comment\">// 丙</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  $(<span class=\"string\">'user_submit'</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> text = $(<span class=\"string\">'user_input'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(text.value === <span class=\"string\">''</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Observer.fire(<span class=\"string\">'addCommentMessage'</span>, &#123;</span><br><span class=\"line\">      text: text.value,</span><br><span class=\"line\">      num: <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    text.value = <span class=\"string\">''</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>总结：观察者模式最主要的作用是解决类或对象之间的耦合，解耦两个相互依赖的对象，使其依赖于观察者的消息机制，这样对于任意一个订阅者对象来说，其他订阅者对象的改变不会影响到自身。</p>\n</blockquote>\n<h3 id=\"超级玛丽—状态模式\"><a href=\"#超级玛丽—状态模式\" class=\"headerlink\" title=\"超级玛丽—状态模式\"></a>超级玛丽—状态模式</h3><blockquote>\n<p>状态模式（State）:当一个对象的内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对象。</p>\n<p>总结：状态模式既是解决程序中臃肿的分支判断语句问题，将每个分支转化为一种状态独立出来，方便每种状态的管理又不至于每次执行时遍历所有分支。在程序中到底产出哪种行为结果，决定于选择哪种状态，而选择何种状态又是在程序运行时决定的。当然状态模式最终的目的即是简化分支判断流程。</p>\n</blockquote>\n<h3 id=\"活诸葛—策略模式\"><a href=\"#活诸葛—策略模式\" class=\"headerlink\" title=\"活诸葛—策略模式\"></a>活诸葛—策略模式</h3><blockquote>\n<p>策略模式（Strategy）：将定义的一组算法封装起来，使其相互之间可以替换，封装的算法具有一定的独立性，不会随客户端变化而变化。</p>\n</blockquote>"},{"title":"Git","date":"2017-10-24T12:06:50.000Z","_content":"> 零基础浅显易懂的Git教程,一步步从创建本地到远程仓库, git指令清晰明了\n\n####  安装\n\n* [官网下载](https://git-scm.com/downloads)\n<!--more-->\n#### 创建版本库\n\n```\n  mkdir learngit\n  cd learngit\n\n```\n\n#### 将目录变成Git可以管理的仓库\n\n```\ngit init\nls -ah                //查看.git文件, 看仓库是否建成功\n\n```\n\n#### 新建分支\n\n```\ngit checkout -b dev   //创建dev分支兵切换到dev 等价于\n\ngit branch dev        //创建dev分支\ngit checkout dev      //切换到dev分支\n\ngit branch            //查看当前分支\ngit branch -d dev     //删除dev分支\ngit merge master      //合并分支到当前分支, 在当前分支\n```\n#### 提交文件到暂存区\n\n```\ngit add readme.txt    //提交指定文件\ngit add .             //提交所有文件\ngit status            //查看发生了哪些变化\n\n```\n\n#### 暂存区内容提交到当前分支\n\n```\ngit commit -m   '提交的提示语'\ngit status           //  查看发生了哪些变化\n\n```\n\n#### 创建远程仓库\n\n```\nssh-keygen -t rsa -C \"youremail@example.com\"  //获取秘钥\n\n用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人\n\n登陆GitHub，打开“Account settings”，“SSH Keys”页面：\n\n点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容\n\n```\n\n#### 本地与远程库关联\n\n```\ngit remote add origin git@github.com:myname/learngit.git\n\n```\n\n#### 将本地仓库推送到远程\n\n```\ngit push -u origin master    \n//远程仓库默叫origin, 第一个推送加-u, Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的//master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令\n```\n\n#### 从远程仓库克隆\n\n```\ngit clone '远程仓库地址'\n\n```\n\n#### 推荐可视化工具(TortoiseGit、SourceTree、GitGUI等等)\n\n\n\n","source":"_posts/工具/Git.md","raw":"---\ntitle: Git\ncategories:\n  - 前端技术\ntags:\n  - Git\ndate: 2017-10-24 20:06:50\n---\n> 零基础浅显易懂的Git教程,一步步从创建本地到远程仓库, git指令清晰明了\n\n####  安装\n\n* [官网下载](https://git-scm.com/downloads)\n<!--more-->\n#### 创建版本库\n\n```\n  mkdir learngit\n  cd learngit\n\n```\n\n#### 将目录变成Git可以管理的仓库\n\n```\ngit init\nls -ah                //查看.git文件, 看仓库是否建成功\n\n```\n\n#### 新建分支\n\n```\ngit checkout -b dev   //创建dev分支兵切换到dev 等价于\n\ngit branch dev        //创建dev分支\ngit checkout dev      //切换到dev分支\n\ngit branch            //查看当前分支\ngit branch -d dev     //删除dev分支\ngit merge master      //合并分支到当前分支, 在当前分支\n```\n#### 提交文件到暂存区\n\n```\ngit add readme.txt    //提交指定文件\ngit add .             //提交所有文件\ngit status            //查看发生了哪些变化\n\n```\n\n#### 暂存区内容提交到当前分支\n\n```\ngit commit -m   '提交的提示语'\ngit status           //  查看发生了哪些变化\n\n```\n\n#### 创建远程仓库\n\n```\nssh-keygen -t rsa -C \"youremail@example.com\"  //获取秘钥\n\n用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人\n\n登陆GitHub，打开“Account settings”，“SSH Keys”页面：\n\n点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容\n\n```\n\n#### 本地与远程库关联\n\n```\ngit remote add origin git@github.com:myname/learngit.git\n\n```\n\n#### 将本地仓库推送到远程\n\n```\ngit push -u origin master    \n//远程仓库默叫origin, 第一个推送加-u, Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的//master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令\n```\n\n#### 从远程仓库克隆\n\n```\ngit clone '远程仓库地址'\n\n```\n\n#### 推荐可视化工具(TortoiseGit、SourceTree、GitGUI等等)\n\n\n\n","slug":"工具/Git","published":1,"updated":"2018-04-12T02:24:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3d9000euox1rwagd37v","content":"<blockquote>\n<p>零基础浅显易懂的Git教程,一步步从创建本地到远程仓库, git指令清晰明了</p>\n</blockquote>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><ul>\n<li><a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"noopener\">官网下载</a><a id=\"more\"></a>\n<h4 id=\"创建版本库\"><a href=\"#创建版本库\" class=\"headerlink\" title=\"创建版本库\"></a>创建版本库</h4></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir learngit</span><br><span class=\"line\">cd learngit</span><br></pre></td></tr></table></figure>\n<h4 id=\"将目录变成Git可以管理的仓库\"><a href=\"#将目录变成Git可以管理的仓库\" class=\"headerlink\" title=\"将目录变成Git可以管理的仓库\"></a>将目录变成Git可以管理的仓库</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">ls -ah                //查看.git文件, 看仓库是否建成功</span><br></pre></td></tr></table></figure>\n<h4 id=\"新建分支\"><a href=\"#新建分支\" class=\"headerlink\" title=\"新建分支\"></a>新建分支</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b dev   //创建dev分支兵切换到dev 等价于</span><br><span class=\"line\"></span><br><span class=\"line\">git branch dev        //创建dev分支</span><br><span class=\"line\">git checkout dev      //切换到dev分支</span><br><span class=\"line\"></span><br><span class=\"line\">git branch            //查看当前分支</span><br><span class=\"line\">git branch -d dev     //删除dev分支</span><br><span class=\"line\">git merge master      //合并分支到当前分支, 在当前分支</span><br></pre></td></tr></table></figure>\n<h4 id=\"提交文件到暂存区\"><a href=\"#提交文件到暂存区\" class=\"headerlink\" title=\"提交文件到暂存区\"></a>提交文件到暂存区</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add readme.txt    //提交指定文件</span><br><span class=\"line\">git add .             //提交所有文件</span><br><span class=\"line\">git status            //查看发生了哪些变化</span><br></pre></td></tr></table></figure>\n<h4 id=\"暂存区内容提交到当前分支\"><a href=\"#暂存区内容提交到当前分支\" class=\"headerlink\" title=\"暂存区内容提交到当前分支\"></a>暂存区内容提交到当前分支</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m   &apos;提交的提示语&apos;</span><br><span class=\"line\">git status           //  查看发生了哪些变化</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建远程仓库\"><a href=\"#创建远程仓库\" class=\"headerlink\" title=\"创建远程仓库\"></a>创建远程仓库</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;  //获取秘钥</span><br><span class=\"line\"></span><br><span class=\"line\">用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人</span><br><span class=\"line\"></span><br><span class=\"line\">登陆GitHub，打开“Account settings”，“SSH Keys”页面：</span><br><span class=\"line\"></span><br><span class=\"line\">点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容</span><br></pre></td></tr></table></figure>\n<h4 id=\"本地与远程库关联\"><a href=\"#本地与远程库关联\" class=\"headerlink\" title=\"本地与远程库关联\"></a>本地与远程库关联</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin git@github.com:myname/learngit.git</span><br></pre></td></tr></table></figure>\n<h4 id=\"将本地仓库推送到远程\"><a href=\"#将本地仓库推送到远程\" class=\"headerlink\" title=\"将本地仓库推送到远程\"></a>将本地仓库推送到远程</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master    </span><br><span class=\"line\">//远程仓库默叫origin, 第一个推送加-u, Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的//master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令</span><br></pre></td></tr></table></figure>\n<h4 id=\"从远程仓库克隆\"><a href=\"#从远程仓库克隆\" class=\"headerlink\" title=\"从远程仓库克隆\"></a>从远程仓库克隆</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone &apos;远程仓库地址&apos;</span><br></pre></td></tr></table></figure>\n<h4 id=\"推荐可视化工具-TortoiseGit、SourceTree、GitGUI等等\"><a href=\"#推荐可视化工具-TortoiseGit、SourceTree、GitGUI等等\" class=\"headerlink\" title=\"推荐可视化工具(TortoiseGit、SourceTree、GitGUI等等)\"></a>推荐可视化工具(TortoiseGit、SourceTree、GitGUI等等)</h4>","site":{"data":{}},"excerpt":"<blockquote>\n<p>零基础浅显易懂的Git教程,一步步从创建本地到远程仓库, git指令清晰明了</p>\n</blockquote>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><ul>\n<li><a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"noopener\">官网下载</a>","more":"<h4 id=\"创建版本库\"><a href=\"#创建版本库\" class=\"headerlink\" title=\"创建版本库\"></a>创建版本库</h4></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir learngit</span><br><span class=\"line\">cd learngit</span><br></pre></td></tr></table></figure>\n<h4 id=\"将目录变成Git可以管理的仓库\"><a href=\"#将目录变成Git可以管理的仓库\" class=\"headerlink\" title=\"将目录变成Git可以管理的仓库\"></a>将目录变成Git可以管理的仓库</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">ls -ah                //查看.git文件, 看仓库是否建成功</span><br></pre></td></tr></table></figure>\n<h4 id=\"新建分支\"><a href=\"#新建分支\" class=\"headerlink\" title=\"新建分支\"></a>新建分支</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b dev   //创建dev分支兵切换到dev 等价于</span><br><span class=\"line\"></span><br><span class=\"line\">git branch dev        //创建dev分支</span><br><span class=\"line\">git checkout dev      //切换到dev分支</span><br><span class=\"line\"></span><br><span class=\"line\">git branch            //查看当前分支</span><br><span class=\"line\">git branch -d dev     //删除dev分支</span><br><span class=\"line\">git merge master      //合并分支到当前分支, 在当前分支</span><br></pre></td></tr></table></figure>\n<h4 id=\"提交文件到暂存区\"><a href=\"#提交文件到暂存区\" class=\"headerlink\" title=\"提交文件到暂存区\"></a>提交文件到暂存区</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add readme.txt    //提交指定文件</span><br><span class=\"line\">git add .             //提交所有文件</span><br><span class=\"line\">git status            //查看发生了哪些变化</span><br></pre></td></tr></table></figure>\n<h4 id=\"暂存区内容提交到当前分支\"><a href=\"#暂存区内容提交到当前分支\" class=\"headerlink\" title=\"暂存区内容提交到当前分支\"></a>暂存区内容提交到当前分支</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m   &apos;提交的提示语&apos;</span><br><span class=\"line\">git status           //  查看发生了哪些变化</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建远程仓库\"><a href=\"#创建远程仓库\" class=\"headerlink\" title=\"创建远程仓库\"></a>创建远程仓库</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;  //获取秘钥</span><br><span class=\"line\"></span><br><span class=\"line\">用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人</span><br><span class=\"line\"></span><br><span class=\"line\">登陆GitHub，打开“Account settings”，“SSH Keys”页面：</span><br><span class=\"line\"></span><br><span class=\"line\">点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容</span><br></pre></td></tr></table></figure>\n<h4 id=\"本地与远程库关联\"><a href=\"#本地与远程库关联\" class=\"headerlink\" title=\"本地与远程库关联\"></a>本地与远程库关联</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin git@github.com:myname/learngit.git</span><br></pre></td></tr></table></figure>\n<h4 id=\"将本地仓库推送到远程\"><a href=\"#将本地仓库推送到远程\" class=\"headerlink\" title=\"将本地仓库推送到远程\"></a>将本地仓库推送到远程</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master    </span><br><span class=\"line\">//远程仓库默叫origin, 第一个推送加-u, Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的//master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令</span><br></pre></td></tr></table></figure>\n<h4 id=\"从远程仓库克隆\"><a href=\"#从远程仓库克隆\" class=\"headerlink\" title=\"从远程仓库克隆\"></a>从远程仓库克隆</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone &apos;远程仓库地址&apos;</span><br></pre></td></tr></table></figure>\n<h4 id=\"推荐可视化工具-TortoiseGit、SourceTree、GitGUI等等\"><a href=\"#推荐可视化工具-TortoiseGit、SourceTree、GitGUI等等\" class=\"headerlink\" title=\"推荐可视化工具(TortoiseGit、SourceTree、GitGUI等等)\"></a>推荐可视化工具(TortoiseGit、SourceTree、GitGUI等等)</h4>"},{"title":"名人名言","date":"2017-12-20T01:10:55.000Z","_content":"\n> 对于那些说什么为时尚早的人而言，就算再过100年也为时尚早。对于那些说没有先例的人而言，就算再过200年也不会出现先例。 ——川渊三郎\n\n> 很多人有类似的问题，每天都挺忙碌的，从起床那刻开始，就陷入许多事情中，但一星期过去，闭上眼睛躺在床上，想想过去的那些天，却不知道自己忙了些什么。\n\n> 有一句话说得很对：“其实让人焦虑的，不是忙也不是累。而是没有什么特别感兴趣的东西，也没有什么特别想爱的人，明知道自己该努力了，却又不知道该往哪里用力。”\n","source":"_posts/小领悟/名人名言.md","raw":"---\ntitle: 名人名言\ndate: 2017-12-20 09:10:55\ncategories:\n- 小领悟\ntags: \n- 领悟\n---\n\n> 对于那些说什么为时尚早的人而言，就算再过100年也为时尚早。对于那些说没有先例的人而言，就算再过200年也不会出现先例。 ——川渊三郎\n\n> 很多人有类似的问题，每天都挺忙碌的，从起床那刻开始，就陷入许多事情中，但一星期过去，闭上眼睛躺在床上，想想过去的那些天，却不知道自己忙了些什么。\n\n> 有一句话说得很对：“其实让人焦虑的，不是忙也不是累。而是没有什么特别感兴趣的东西，也没有什么特别想爱的人，明知道自己该努力了，却又不知道该往哪里用力。”\n","slug":"小领悟/名人名言","published":1,"updated":"2018-05-31T10:27:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3db000fuox11oszdev9","content":"<blockquote>\n<p>对于那些说什么为时尚早的人而言，就算再过100年也为时尚早。对于那些说没有先例的人而言，就算再过200年也不会出现先例。 ——川渊三郎</p>\n<p>很多人有类似的问题，每天都挺忙碌的，从起床那刻开始，就陷入许多事情中，但一星期过去，闭上眼睛躺在床上，想想过去的那些天，却不知道自己忙了些什么。</p>\n<p>有一句话说得很对：“其实让人焦虑的，不是忙也不是累。而是没有什么特别感兴趣的东西，也没有什么特别想爱的人，明知道自己该努力了，却又不知道该往哪里用力。”</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>对于那些说什么为时尚早的人而言，就算再过100年也为时尚早。对于那些说没有先例的人而言，就算再过200年也不会出现先例。 ——川渊三郎</p>\n<p>很多人有类似的问题，每天都挺忙碌的，从起床那刻开始，就陷入许多事情中，但一星期过去，闭上眼睛躺在床上，想想过去的那些天，却不知道自己忙了些什么。</p>\n<p>有一句话说得很对：“其实让人焦虑的，不是忙也不是累。而是没有什么特别感兴趣的东西，也没有什么特别想爱的人，明知道自己该努力了，却又不知道该往哪里用力。”</p>\n</blockquote>\n"},{"title":"小领悟","date":"2017-12-20T01:10:55.000Z","_content":"\n> 每一个根源的烦恼都在自己这里\n\n生气，是因为不够大度；郁闷，是因为不够豁达；焦虑，是因为不够从容；悲伤，是因为不够坚强；惆怅，是因为不够阳光；嫉妒，是因为不够优秀。每一个根源的烦恼都在自己这里，每一次烦恼的出现，都是一个让我们改正自己缺点的机会。\n\n<!-- more -->\n\n> 生活原本的样子\n\n为自己的目标努力着，全身心投入一件事情的时候，就不在整天想睡懒觉，不在熬夜看偶像，也不用刻意去想怎样好好生活，删掉那些原以为离不开的东西，然后觉得，这才是生活原本的样子啊。\n\n\n\n\n\n\n\n","source":"_posts/小领悟/领悟.md","raw":"---\ntitle: 小领悟\ndate: 2017-12-20 09:10:55\ncategories:\n- 小领悟\ntags: \n- 领悟\n---\n\n> 每一个根源的烦恼都在自己这里\n\n生气，是因为不够大度；郁闷，是因为不够豁达；焦虑，是因为不够从容；悲伤，是因为不够坚强；惆怅，是因为不够阳光；嫉妒，是因为不够优秀。每一个根源的烦恼都在自己这里，每一次烦恼的出现，都是一个让我们改正自己缺点的机会。\n\n<!-- more -->\n\n> 生活原本的样子\n\n为自己的目标努力着，全身心投入一件事情的时候，就不在整天想睡懒觉，不在熬夜看偶像，也不用刻意去想怎样好好生活，删掉那些原以为离不开的东西，然后觉得，这才是生活原本的样子啊。\n\n\n\n\n\n\n\n","slug":"小领悟/领悟","published":1,"updated":"2018-05-07T02:41:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3dc000guox1ow532hwf","content":"<blockquote>\n<p>每一个根源的烦恼都在自己这里</p>\n</blockquote>\n<p>生气，是因为不够大度；郁闷，是因为不够豁达；焦虑，是因为不够从容；悲伤，是因为不够坚强；惆怅，是因为不够阳光；嫉妒，是因为不够优秀。每一个根源的烦恼都在自己这里，每一次烦恼的出现，都是一个让我们改正自己缺点的机会。</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>生活原本的样子</p>\n</blockquote>\n<p>为自己的目标努力着，全身心投入一件事情的时候，就不在整天想睡懒觉，不在熬夜看偶像，也不用刻意去想怎样好好生活，删掉那些原以为离不开的东西，然后觉得，这才是生活原本的样子啊。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>每一个根源的烦恼都在自己这里</p>\n</blockquote>\n<p>生气，是因为不够大度；郁闷，是因为不够豁达；焦虑，是因为不够从容；悲伤，是因为不够坚强；惆怅，是因为不够阳光；嫉妒，是因为不够优秀。每一个根源的烦恼都在自己这里，每一次烦恼的出现，都是一个让我们改正自己缺点的机会。</p>","more":"<blockquote>\n<p>生活原本的样子</p>\n</blockquote>\n<p>为自己的目标努力着，全身心投入一件事情的时候，就不在整天想睡懒觉，不在熬夜看偶像，也不用刻意去想怎样好好生活，删掉那些原以为离不开的东西，然后觉得，这才是生活原本的样子啊。</p>"},{"title":"结构型设计模式","date":"2017-11-27T10:56:20.000Z","_content":"> 结构型设计模式关注于如何将类或者对象组合成更大，更复杂的结构，以简化设计。\n\n<!-- more -->\n\n### 套餐服务---外观模式\n\n> 外观模式（Facade）：为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口，使得对子系统接口的访问更容易，在Javascript中有时也会用于对底层结构兼容性做统一封装来简化用户使用。\n\n```javascript\n// 外观模式实现\n//提供一个更简单的高级接口，简化了我们对复杂的底层接口不统一的使用要求\nfunction addEvent(dom, type, fn) {\n    if(dom.addEventListener) {\n        dom.addEventListener(type, fn, false)\n    } else if(dom.attachEvent){\n        dom.attachEvent('on'+type, fn)\n    } else {\n        dom['on'+type] = fn;\n    }\n}\n\n// 使用\nvar DOM = document.getElementById('dom');\naddEvent(Dom, 'click', function() {\n    // 绑定的第一个事件\n    console.log('绑定的第一个事件')\n})\naddEvent(Dom, 'click', function() {\n    // 绑定的第一个事件\n    console.log('绑定的第二个事件')\n})\n\n// 获取事件对象\nvar getEvent = function (event) {\n    // 标准浏览器返回event  IE window.event\n    return event || window.event;\n}\n// 获取元素\nvar getTarget = function(event) {\n    var event = getEvent(event);\n    // 标准浏览器下event.target  IE下event.srcElement\n    return event.target || event.srcElement;\n}\n// 阻止默认行为\nvar preventDefault = function (event) {\n    var event = getEvent(event);\n    // 标准浏览器\n    if(event.preventDefault) {\n        event.preventDefault\n    } else {\n        // IE\n        event.returnValue = false;\n    }\n}\n//使用\ndocument.onclick = function (e) {\n    preventDefault(e);\n    if(getTarget(e) === Dom) {\n        // do somethihng\n    }\n}\n```\n> 总结：外观模式是对接口方法的外层包装，以供上层代码调用以供上层代码使用，因此有时外观模式封装的接口方法不需要接口的具体实现，只需要按照接口使用规则使用即可，这也是对系统与使用者之间的一种松散耦合，使得系统与使用者之间不会因结构的变化而相互影响。\n\n### 水管弯弯---适配器模式\n\n> 适配器模式(Adapter): 将一个类（对象）的接口（方法或属性）转化成另外一个接口，以满足用户需求，使类（对象）之间接口的不兼容问题通过适配器得以解决。\n\n> 生活中的适配器两根垂直相交的水管连接处的的直角弯管，使得两个不同方向的水管可以疏通流水，三角插头手机充电器对于两项插头是不可用的，此时需要一个三项转两项插头电源适配器等等，这些都是适配器。代码写适配器，其实就是为两个代码库所写的代码兼容运行而书写的额外代码，有了这样的适配器，你就不需要特意地重写以前的功能代码了。\n\n> jQuery适配器\n\n某框架A和jQuery代码书写风格很像，加载完jQuery框架后写一个适配器，将我们已有的功能适配到jQuery，假如代码中有两个事件\n，一个加载，一个点击，不过这两个事件与jQuery中的写法很像，所以做的改动不会太大，我们的适配器的主要任务是适配两种代码库中不兼容的代码，那么首当其冲的就是全局对象A与jQuery了，\n\n```javascript\nwindow.A = A = jQuery;\n```\n> 适配异类框架\n\n如果两个框架直接相差太大，对于这种异类框架适配情况就复杂多了，\n\n```javascript\n// 定义框架\nvar A = A|| {}\nA.g = function(id) {\n    return document.getElementById(id)\n}\n// 为元素绑定事件\nA.on= function(id, type, fn) {\n    // 如果传递参数是字符串则以id处理，负责以元素对象处理，\n    var dom = typeof id === 'string' ? this.g(id) : id;\n    // 标准dom2级添加事件方式\n    if(dom.addEventListener) {\n        dom.addEventListener(type, fn, false)\n    } else if(dom.attachEvent){\n        dom.attachEvent('on'+type, fn)\n    } else {\n        dom['on'+type] = fn;\n    }\n}\n// 使用\nA.on(window, 'load', function() {\n    A.on('dom', 'click', function() {\n        // do something\n    })\n})\n// 引入jQuery来换A库\nA.g = function(id) {\n    // 通过jQuery获取jQuery对象，然后返回第一个成员\n    return $(id).get(0)\n}\nA.on = function(id, type, fn) {\n    // 如果传递参数是字符串则以id处理，否则以元素对象处理，\n    var dom = typeof id === 'string' ? $('#' + id) : $(id);\n    dom.on(type, fn);\n}\n// 通过适配器发现如果两种框架的比较相似，适配比较容易，否则写起来复杂很多，因此尽量引入相似框架。\n```\n\n> 参数适配器\n\n适配器还有很多用途，比如方法需要传递多个参数\n```javascript\nfunction dosomething(name, title, age, color, size, prize) {\n    // 记住参数顺序是很困难的，因此我们经常以一个参数对象方式传入\n}\nvar obj = {\n    name: name,\n    title: title\n    ...\n}\nfunction dosomething(obj) {}\n// 然而调用的时候不知道传递的参数是否完整，如有一些必须参数没有传入，一些参数是有默认值得等等，此时我们通常的做法是用适配器来适配传入的这个参数对象\n\nfunction doSomething(obj) {\n    var _adapter = {\n        name: 'me',\n        title: '设计模式'，\n        age: 24,\n        ...\n    }\n    for(var i in _adapter) {\n        _adapter[i] = obj[i] || _adapter[i];\n        // 或者 extend(_adapter, obj)   //  此时可能会多添加属性\n        // do something\n    }\n} \n```\n> 数据适配\n\n```javascript\nvar arr = ['javascript',20,'时间'， ‘日期’]\n// 我们发现数组中的每个成员代表的意义不同，这种数据结构语义不好，我们通常会将其适配成对象形式，\nvar obj = {\n    name: '',\n    age: '',\n    time: '',\n    data: ''\n}\nfunction arrToObjAdapter() {\n    return {\n        name: arr[0],\n        age: arr[1]\n        ...\n    }\n}\n// 使用\nvar adapterData = arrToObjAdapter(arr);\nconsole.log(adapterData)  // {name: 'javascript', age: 20, ...}\n\n```\n> 服务器端数据适配\n\n它解决了前后端的数据依赖，前端程序不在为后端传递的数据所束缚，如果后端因为架构改变导致传递的数据结构发生变化，我们只需要写个适配器就可以放心了，如果后端的数据经常变化，无法控制数据的格式，那么我们在dosomething时最好不要直接调用，最好先将传递过来的数据适配成对我们可用的数据在使用。\n\n```javascript\n// 为简化模型这里使用jQuery的ajax方法，理想数据是一个一维数组\nfunction ajaxAdapter(data) {\n    // 处理数据并返回新数据\n    return [data['key1'], data['key2'], ...]\n}\n$.ajax({\n    url: '...',\n    // ...\n    success: function(data) {\n        if(data) {\n            doSomethin(ajaxAdapter(data))\n        }\n    }\n})\n// 如果以后后端数据有任何变化我们只需相应的更改ajaxAdapter适配器转换格式\n```\n> 总结：传统设计模式中，适配器模式往往是适配两个类接口不兼容的问题，然而在JavaScript中，适配器的应用范围更广，比如适配两个代码库，适配前后端数据等等。JavaScript中的适配器的应用，更多应用在对象之间，为了使对象可用，通常我们会将对象拆分并重新包装，这样我们就要了解适配对象的内部结构，这也是与外观模式的区别所在，当然适配器模式同样解决了对象之间的耦合度。包装的适配器代码增加了一些资源开销，当然这是微乎其微的。\n\n### 牛郎织女---代理模式\n\n> 代理模式（Proxy）:由于一个对象不能直接应用另一个对象，所以需要通过代理对象在这两个对象之间起到代理作用。\n\n由于用户相册模块上传的照片量越来越大，导致服务器端需要将图片上传模块重新部署到另外一个域，这样对于前端来说，用户上传图片的请求路径发生变化，指向其他服务器，这就导致了跨域问题。\n\n> 跨域\n\n> 站长统计\n\n> JSONP\n\n> 代理模板\n\n### 房子装饰---装饰者模式\n\n> 装饰者模式（Decorator）:在不改变原对象的基础上，通过对其进行包装扩展（添加属性或者方法）使原有对象可以满足用户的更复杂需求。\n\n静止是相对的，运动是绝对的，所以没有一成不变的需求。\n\n？？ 情景：给页面所以input添加一个点击隐藏文案提示，注意不要覆盖原有的事件。\n\n```javascript\nvar input1 = doucument.getElementById('input1')\ninput1.onclick = function() {\n    // do something\n}\nvar input2 = doucument.getElementById('input2')\ninput2.onclick = function() {\n    // do something\n}\n...很多的input\n```\n\n以上这种解决方法，由于输入框太多，寻找与修改麻烦,所以试试装饰者模式吧！\n\n> 装饰已有的功能对象\n\n```javascript\nvar decorator = function(input, fn) {\n    // 获取事件源\n    var input = doucument.getElementById(input);\n    // 若事件源已经绑定事件\n    if(typeof input.onclick === 'function') {\n        // 缓存事件源原有事件函数\n        var oldClickFn = input.onclick;\n        input.onclick = function() {\n            // 事件源原有回调函数\n            oldClickFn();\n            // 执行事件源添加新增回调函数\n            fn();\n        }\n    } else {\n        input.onclick = fn;\n    }\n    // do something\n}\n// 使用\ndecorator（‘input1’, function() {\n    // do something\n}）\ndecorator（‘input2’, function() {\n    // do something\n}）\n\n```\n> 装饰者模式和适配器模式都是对一个对象的修饰来适配其他对象，二者不同，适配器模式是对原有对象适配，添加的方法与原有方法功能上大致相似，装饰者模式提供的方法与原来的方法是有一定区别的，还有最重要的一点是适配器模式新增的方法要调用原来的方法，要了解原有方法具体的细节，而装饰者模式不需要了解对象原有的功能，原方法原封不动的使用。\n\n> 总结：装饰模式是一种可以在不了解原有功能的基础上对功能拓展，装饰者模式对对象的拓展是一种良性拓展，不用了解其具体实现，只是在外部进行了一次封装拓展，是对原有功能完整性的一种保护。\n\n### 城市间的道路---桥接模式\n\n> 桥接模式（Bridge）：在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦。\n\n有时候页面中的一些小小细节改变常常因逻辑相似导致大片臃肿的代码，让页面苦涩不堪。\n\n问题：给页面导航栏添加鼠标滑过特效，区别：每个鼠标滑过的效果不一样。。。\n\n```javascript\nvar nav = document.getElementByTagName('span');\n// 不同的绑定不同效果\nnav[0].onmouserover = function() {\n    this.style.color = 'red';\n    this.style.background = 'green';\n}\nnav[0].onmouserout = function() {\n    this.style.color = '#fff';\n    this.style.background = '#ccc';\n}\n\nnav[1].onmouseover = function() {\n    this.getElementsByTagName('strong')[0]style.color = '#fff';\n    this.getElementsByTagName('strong')[0]style.background = '#ccc';\n}\nnav[1].onmouseout = function() {\n    this.getElementsByTagName('strong')[0]style.color = 'red';\n    this.getElementsByTagName('strong')[0]style.background = 'blue';\n}\n\n```\n缺点：功能能实现，但是代码冗余。\n解决方法：提取共同点，，对相同的逻辑做抽象提取处理，解除与事件中this的耦合。\n\n```javascript\nfunction changeColor(dom, color, bg) {\n    dom.style.color = color;\n    dom.style.background = bg;\n}\n\n```\n\n下一步：事件与业务逻辑之间的桥梁---桥接模式\n\n对于事件桥接方法，可以用一个匿名函数来代替，否则直接将changeColor作为事件的回调函数，解除this耦合。\n\n```javascript\nnav[0].onmouserover = function() {\n    changeColor(this, 'red', '#fff');\n}\n```\n\n这种方法是以新增一个桥接函数为代价实现的。\n\n> 多元化对象\n\n桥接模式对于多维的变化也同样适用，\n\n```javascript\nfunction Speed(x, y) {\n    this.x = x;\n    this.y = y;\n}\nSpeed.prototype.run = function() {\n    // do something\n}\n\nfunction Color(cl) {\n    this.cl = cl;\n}\nColor.prtotype.draw = function() {\n    // do something\n}\n...\n\nfunction Ball(x, y ,c) {\n    this.speed = new Speed(x, y);\n    this.color = new Color(c);\n}\nBall.prototype = function() {\n    this.speed.run();\n    this.color.draw();\n}\n```\n总结：桥接模式主要特点：将实现层（如元素绑定的事件）与抽象层（如修饰页面UI逻辑）解耦分离，使两部分可以独立变化，由此可以看出桥接模式主要是对结构之间的结构，而抽象工厂模式与创建者模式主要业务在于创建，通过桥接模式实现的解耦，使实现层与抽象层分开处理，避免需求的改变造成对象内部的修改，体现了面向对象对扩展的开放及对修改的关闭原则。当然由于桥接的添加，有时也造成开发成本的增加，有时性能上也会受到影响。\n\n### 超值午餐---组合模式\n\n> 组合模式（Composite）:又称部分-整体模式，将对象组合成树形结构以表示‘整体部分’的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。\n\n### 城市公交车---享元模式\n\n> 享元模式（Flyweight）运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多于的开销。\n\n总结：享元模式的应用目的是为了提高程序的执行效率与系统的性能，因此在大型系统开发中应用是比较广泛的，百分之一的效率提成有时可以发生质的改变，它可以避免程序中的数据重复，\n\n\n\n\n\n\n\n\n","source":"_posts/javascript/结构型设计模式.md","raw":"---\ntitle: 结构型设计模式\ncategories:\n  - 前端技术\ntags:\n  - js\ndate: 2017-11-27 18:56:20\n---\n> 结构型设计模式关注于如何将类或者对象组合成更大，更复杂的结构，以简化设计。\n\n<!-- more -->\n\n### 套餐服务---外观模式\n\n> 外观模式（Facade）：为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口，使得对子系统接口的访问更容易，在Javascript中有时也会用于对底层结构兼容性做统一封装来简化用户使用。\n\n```javascript\n// 外观模式实现\n//提供一个更简单的高级接口，简化了我们对复杂的底层接口不统一的使用要求\nfunction addEvent(dom, type, fn) {\n    if(dom.addEventListener) {\n        dom.addEventListener(type, fn, false)\n    } else if(dom.attachEvent){\n        dom.attachEvent('on'+type, fn)\n    } else {\n        dom['on'+type] = fn;\n    }\n}\n\n// 使用\nvar DOM = document.getElementById('dom');\naddEvent(Dom, 'click', function() {\n    // 绑定的第一个事件\n    console.log('绑定的第一个事件')\n})\naddEvent(Dom, 'click', function() {\n    // 绑定的第一个事件\n    console.log('绑定的第二个事件')\n})\n\n// 获取事件对象\nvar getEvent = function (event) {\n    // 标准浏览器返回event  IE window.event\n    return event || window.event;\n}\n// 获取元素\nvar getTarget = function(event) {\n    var event = getEvent(event);\n    // 标准浏览器下event.target  IE下event.srcElement\n    return event.target || event.srcElement;\n}\n// 阻止默认行为\nvar preventDefault = function (event) {\n    var event = getEvent(event);\n    // 标准浏览器\n    if(event.preventDefault) {\n        event.preventDefault\n    } else {\n        // IE\n        event.returnValue = false;\n    }\n}\n//使用\ndocument.onclick = function (e) {\n    preventDefault(e);\n    if(getTarget(e) === Dom) {\n        // do somethihng\n    }\n}\n```\n> 总结：外观模式是对接口方法的外层包装，以供上层代码调用以供上层代码使用，因此有时外观模式封装的接口方法不需要接口的具体实现，只需要按照接口使用规则使用即可，这也是对系统与使用者之间的一种松散耦合，使得系统与使用者之间不会因结构的变化而相互影响。\n\n### 水管弯弯---适配器模式\n\n> 适配器模式(Adapter): 将一个类（对象）的接口（方法或属性）转化成另外一个接口，以满足用户需求，使类（对象）之间接口的不兼容问题通过适配器得以解决。\n\n> 生活中的适配器两根垂直相交的水管连接处的的直角弯管，使得两个不同方向的水管可以疏通流水，三角插头手机充电器对于两项插头是不可用的，此时需要一个三项转两项插头电源适配器等等，这些都是适配器。代码写适配器，其实就是为两个代码库所写的代码兼容运行而书写的额外代码，有了这样的适配器，你就不需要特意地重写以前的功能代码了。\n\n> jQuery适配器\n\n某框架A和jQuery代码书写风格很像，加载完jQuery框架后写一个适配器，将我们已有的功能适配到jQuery，假如代码中有两个事件\n，一个加载，一个点击，不过这两个事件与jQuery中的写法很像，所以做的改动不会太大，我们的适配器的主要任务是适配两种代码库中不兼容的代码，那么首当其冲的就是全局对象A与jQuery了，\n\n```javascript\nwindow.A = A = jQuery;\n```\n> 适配异类框架\n\n如果两个框架直接相差太大，对于这种异类框架适配情况就复杂多了，\n\n```javascript\n// 定义框架\nvar A = A|| {}\nA.g = function(id) {\n    return document.getElementById(id)\n}\n// 为元素绑定事件\nA.on= function(id, type, fn) {\n    // 如果传递参数是字符串则以id处理，负责以元素对象处理，\n    var dom = typeof id === 'string' ? this.g(id) : id;\n    // 标准dom2级添加事件方式\n    if(dom.addEventListener) {\n        dom.addEventListener(type, fn, false)\n    } else if(dom.attachEvent){\n        dom.attachEvent('on'+type, fn)\n    } else {\n        dom['on'+type] = fn;\n    }\n}\n// 使用\nA.on(window, 'load', function() {\n    A.on('dom', 'click', function() {\n        // do something\n    })\n})\n// 引入jQuery来换A库\nA.g = function(id) {\n    // 通过jQuery获取jQuery对象，然后返回第一个成员\n    return $(id).get(0)\n}\nA.on = function(id, type, fn) {\n    // 如果传递参数是字符串则以id处理，否则以元素对象处理，\n    var dom = typeof id === 'string' ? $('#' + id) : $(id);\n    dom.on(type, fn);\n}\n// 通过适配器发现如果两种框架的比较相似，适配比较容易，否则写起来复杂很多，因此尽量引入相似框架。\n```\n\n> 参数适配器\n\n适配器还有很多用途，比如方法需要传递多个参数\n```javascript\nfunction dosomething(name, title, age, color, size, prize) {\n    // 记住参数顺序是很困难的，因此我们经常以一个参数对象方式传入\n}\nvar obj = {\n    name: name,\n    title: title\n    ...\n}\nfunction dosomething(obj) {}\n// 然而调用的时候不知道传递的参数是否完整，如有一些必须参数没有传入，一些参数是有默认值得等等，此时我们通常的做法是用适配器来适配传入的这个参数对象\n\nfunction doSomething(obj) {\n    var _adapter = {\n        name: 'me',\n        title: '设计模式'，\n        age: 24,\n        ...\n    }\n    for(var i in _adapter) {\n        _adapter[i] = obj[i] || _adapter[i];\n        // 或者 extend(_adapter, obj)   //  此时可能会多添加属性\n        // do something\n    }\n} \n```\n> 数据适配\n\n```javascript\nvar arr = ['javascript',20,'时间'， ‘日期’]\n// 我们发现数组中的每个成员代表的意义不同，这种数据结构语义不好，我们通常会将其适配成对象形式，\nvar obj = {\n    name: '',\n    age: '',\n    time: '',\n    data: ''\n}\nfunction arrToObjAdapter() {\n    return {\n        name: arr[0],\n        age: arr[1]\n        ...\n    }\n}\n// 使用\nvar adapterData = arrToObjAdapter(arr);\nconsole.log(adapterData)  // {name: 'javascript', age: 20, ...}\n\n```\n> 服务器端数据适配\n\n它解决了前后端的数据依赖，前端程序不在为后端传递的数据所束缚，如果后端因为架构改变导致传递的数据结构发生变化，我们只需要写个适配器就可以放心了，如果后端的数据经常变化，无法控制数据的格式，那么我们在dosomething时最好不要直接调用，最好先将传递过来的数据适配成对我们可用的数据在使用。\n\n```javascript\n// 为简化模型这里使用jQuery的ajax方法，理想数据是一个一维数组\nfunction ajaxAdapter(data) {\n    // 处理数据并返回新数据\n    return [data['key1'], data['key2'], ...]\n}\n$.ajax({\n    url: '...',\n    // ...\n    success: function(data) {\n        if(data) {\n            doSomethin(ajaxAdapter(data))\n        }\n    }\n})\n// 如果以后后端数据有任何变化我们只需相应的更改ajaxAdapter适配器转换格式\n```\n> 总结：传统设计模式中，适配器模式往往是适配两个类接口不兼容的问题，然而在JavaScript中，适配器的应用范围更广，比如适配两个代码库，适配前后端数据等等。JavaScript中的适配器的应用，更多应用在对象之间，为了使对象可用，通常我们会将对象拆分并重新包装，这样我们就要了解适配对象的内部结构，这也是与外观模式的区别所在，当然适配器模式同样解决了对象之间的耦合度。包装的适配器代码增加了一些资源开销，当然这是微乎其微的。\n\n### 牛郎织女---代理模式\n\n> 代理模式（Proxy）:由于一个对象不能直接应用另一个对象，所以需要通过代理对象在这两个对象之间起到代理作用。\n\n由于用户相册模块上传的照片量越来越大，导致服务器端需要将图片上传模块重新部署到另外一个域，这样对于前端来说，用户上传图片的请求路径发生变化，指向其他服务器，这就导致了跨域问题。\n\n> 跨域\n\n> 站长统计\n\n> JSONP\n\n> 代理模板\n\n### 房子装饰---装饰者模式\n\n> 装饰者模式（Decorator）:在不改变原对象的基础上，通过对其进行包装扩展（添加属性或者方法）使原有对象可以满足用户的更复杂需求。\n\n静止是相对的，运动是绝对的，所以没有一成不变的需求。\n\n？？ 情景：给页面所以input添加一个点击隐藏文案提示，注意不要覆盖原有的事件。\n\n```javascript\nvar input1 = doucument.getElementById('input1')\ninput1.onclick = function() {\n    // do something\n}\nvar input2 = doucument.getElementById('input2')\ninput2.onclick = function() {\n    // do something\n}\n...很多的input\n```\n\n以上这种解决方法，由于输入框太多，寻找与修改麻烦,所以试试装饰者模式吧！\n\n> 装饰已有的功能对象\n\n```javascript\nvar decorator = function(input, fn) {\n    // 获取事件源\n    var input = doucument.getElementById(input);\n    // 若事件源已经绑定事件\n    if(typeof input.onclick === 'function') {\n        // 缓存事件源原有事件函数\n        var oldClickFn = input.onclick;\n        input.onclick = function() {\n            // 事件源原有回调函数\n            oldClickFn();\n            // 执行事件源添加新增回调函数\n            fn();\n        }\n    } else {\n        input.onclick = fn;\n    }\n    // do something\n}\n// 使用\ndecorator（‘input1’, function() {\n    // do something\n}）\ndecorator（‘input2’, function() {\n    // do something\n}）\n\n```\n> 装饰者模式和适配器模式都是对一个对象的修饰来适配其他对象，二者不同，适配器模式是对原有对象适配，添加的方法与原有方法功能上大致相似，装饰者模式提供的方法与原来的方法是有一定区别的，还有最重要的一点是适配器模式新增的方法要调用原来的方法，要了解原有方法具体的细节，而装饰者模式不需要了解对象原有的功能，原方法原封不动的使用。\n\n> 总结：装饰模式是一种可以在不了解原有功能的基础上对功能拓展，装饰者模式对对象的拓展是一种良性拓展，不用了解其具体实现，只是在外部进行了一次封装拓展，是对原有功能完整性的一种保护。\n\n### 城市间的道路---桥接模式\n\n> 桥接模式（Bridge）：在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦。\n\n有时候页面中的一些小小细节改变常常因逻辑相似导致大片臃肿的代码，让页面苦涩不堪。\n\n问题：给页面导航栏添加鼠标滑过特效，区别：每个鼠标滑过的效果不一样。。。\n\n```javascript\nvar nav = document.getElementByTagName('span');\n// 不同的绑定不同效果\nnav[0].onmouserover = function() {\n    this.style.color = 'red';\n    this.style.background = 'green';\n}\nnav[0].onmouserout = function() {\n    this.style.color = '#fff';\n    this.style.background = '#ccc';\n}\n\nnav[1].onmouseover = function() {\n    this.getElementsByTagName('strong')[0]style.color = '#fff';\n    this.getElementsByTagName('strong')[0]style.background = '#ccc';\n}\nnav[1].onmouseout = function() {\n    this.getElementsByTagName('strong')[0]style.color = 'red';\n    this.getElementsByTagName('strong')[0]style.background = 'blue';\n}\n\n```\n缺点：功能能实现，但是代码冗余。\n解决方法：提取共同点，，对相同的逻辑做抽象提取处理，解除与事件中this的耦合。\n\n```javascript\nfunction changeColor(dom, color, bg) {\n    dom.style.color = color;\n    dom.style.background = bg;\n}\n\n```\n\n下一步：事件与业务逻辑之间的桥梁---桥接模式\n\n对于事件桥接方法，可以用一个匿名函数来代替，否则直接将changeColor作为事件的回调函数，解除this耦合。\n\n```javascript\nnav[0].onmouserover = function() {\n    changeColor(this, 'red', '#fff');\n}\n```\n\n这种方法是以新增一个桥接函数为代价实现的。\n\n> 多元化对象\n\n桥接模式对于多维的变化也同样适用，\n\n```javascript\nfunction Speed(x, y) {\n    this.x = x;\n    this.y = y;\n}\nSpeed.prototype.run = function() {\n    // do something\n}\n\nfunction Color(cl) {\n    this.cl = cl;\n}\nColor.prtotype.draw = function() {\n    // do something\n}\n...\n\nfunction Ball(x, y ,c) {\n    this.speed = new Speed(x, y);\n    this.color = new Color(c);\n}\nBall.prototype = function() {\n    this.speed.run();\n    this.color.draw();\n}\n```\n总结：桥接模式主要特点：将实现层（如元素绑定的事件）与抽象层（如修饰页面UI逻辑）解耦分离，使两部分可以独立变化，由此可以看出桥接模式主要是对结构之间的结构，而抽象工厂模式与创建者模式主要业务在于创建，通过桥接模式实现的解耦，使实现层与抽象层分开处理，避免需求的改变造成对象内部的修改，体现了面向对象对扩展的开放及对修改的关闭原则。当然由于桥接的添加，有时也造成开发成本的增加，有时性能上也会受到影响。\n\n### 超值午餐---组合模式\n\n> 组合模式（Composite）:又称部分-整体模式，将对象组合成树形结构以表示‘整体部分’的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。\n\n### 城市公交车---享元模式\n\n> 享元模式（Flyweight）运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多于的开销。\n\n总结：享元模式的应用目的是为了提高程序的执行效率与系统的性能，因此在大型系统开发中应用是比较广泛的，百分之一的效率提成有时可以发生质的改变，它可以避免程序中的数据重复，\n\n\n\n\n\n\n\n\n","slug":"javascript/结构型设计模式","published":1,"updated":"2018-05-31T10:27:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3dc000huox1jeobix48","content":"<blockquote>\n<p>结构型设计模式关注于如何将类或者对象组合成更大，更复杂的结构，以简化设计。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"套餐服务—外观模式\"><a href=\"#套餐服务—外观模式\" class=\"headerlink\" title=\"套餐服务—外观模式\"></a>套餐服务—外观模式</h3><blockquote>\n<p>外观模式（Facade）：为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口，使得对子系统接口的访问更容易，在Javascript中有时也会用于对底层结构兼容性做统一封装来简化用户使用。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 外观模式实现</span></span><br><span class=\"line\"><span class=\"comment\">//提供一个更简单的高级接口，简化了我们对复杂的底层接口不统一的使用要求</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addEvent</span>(<span class=\"params\">dom, type, fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dom.addEventListener) &#123;</span><br><span class=\"line\">        dom.addEventListener(type, fn, <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(dom.attachEvent)&#123;</span><br><span class=\"line\">        dom.attachEvent(<span class=\"string\">'on'</span>+type, fn)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        dom[<span class=\"string\">'on'</span>+type] = fn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> DOM = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'dom'</span>);</span><br><span class=\"line\">addEvent(Dom, <span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 绑定的第一个事件</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'绑定的第一个事件'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">addEvent(Dom, <span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 绑定的第一个事件</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'绑定的第二个事件'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取事件对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> getEvent = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 标准浏览器返回event  IE window.event</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> event || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 获取元素</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> getTarget = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> event = getEvent(event);</span><br><span class=\"line\">    <span class=\"comment\">// 标准浏览器下event.target  IE下event.srcElement</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> event.target || event.srcElement;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 阻止默认行为</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> preventDefault = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> event = getEvent(event);</span><br><span class=\"line\">    <span class=\"comment\">// 标准浏览器</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(event.preventDefault) &#123;</span><br><span class=\"line\">        event.preventDefault</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// IE</span></span><br><span class=\"line\">        event.returnValue = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    preventDefault(e);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(getTarget(e) === Dom) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do somethihng</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>总结：外观模式是对接口方法的外层包装，以供上层代码调用以供上层代码使用，因此有时外观模式封装的接口方法不需要接口的具体实现，只需要按照接口使用规则使用即可，这也是对系统与使用者之间的一种松散耦合，使得系统与使用者之间不会因结构的变化而相互影响。</p>\n</blockquote>\n<h3 id=\"水管弯弯—适配器模式\"><a href=\"#水管弯弯—适配器模式\" class=\"headerlink\" title=\"水管弯弯—适配器模式\"></a>水管弯弯—适配器模式</h3><blockquote>\n<p>适配器模式(Adapter): 将一个类（对象）的接口（方法或属性）转化成另外一个接口，以满足用户需求，使类（对象）之间接口的不兼容问题通过适配器得以解决。</p>\n<p>生活中的适配器两根垂直相交的水管连接处的的直角弯管，使得两个不同方向的水管可以疏通流水，三角插头手机充电器对于两项插头是不可用的，此时需要一个三项转两项插头电源适配器等等，这些都是适配器。代码写适配器，其实就是为两个代码库所写的代码兼容运行而书写的额外代码，有了这样的适配器，你就不需要特意地重写以前的功能代码了。</p>\n<p>jQuery适配器</p>\n</blockquote>\n<p>某框架A和jQuery代码书写风格很像，加载完jQuery框架后写一个适配器，将我们已有的功能适配到jQuery，假如代码中有两个事件<br>，一个加载，一个点击，不过这两个事件与jQuery中的写法很像，所以做的改动不会太大，我们的适配器的主要任务是适配两种代码库中不兼容的代码，那么首当其冲的就是全局对象A与jQuery了，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.A = A = jQuery;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>适配异类框架</p>\n</blockquote>\n<p>如果两个框架直接相差太大，对于这种异类框架适配情况就复杂多了，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义框架</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> A = A|| &#123;&#125;</span><br><span class=\"line\">A.g = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">document</span>.getElementById(id)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 为元素绑定事件</span></span><br><span class=\"line\">A.on= <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id, type, fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果传递参数是字符串则以id处理，负责以元素对象处理，</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> dom = <span class=\"keyword\">typeof</span> id === <span class=\"string\">'string'</span> ? <span class=\"keyword\">this</span>.g(id) : id;</span><br><span class=\"line\">    <span class=\"comment\">// 标准dom2级添加事件方式</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dom.addEventListener) &#123;</span><br><span class=\"line\">        dom.addEventListener(type, fn, <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(dom.attachEvent)&#123;</span><br><span class=\"line\">        dom.attachEvent(<span class=\"string\">'on'</span>+type, fn)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        dom[<span class=\"string\">'on'</span>+type] = fn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\">A.on(<span class=\"built_in\">window</span>, <span class=\"string\">'load'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    A.on(<span class=\"string\">'dom'</span>, <span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 引入jQuery来换A库</span></span><br><span class=\"line\">A.g = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过jQuery获取jQuery对象，然后返回第一个成员</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> $(id).get(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A.on = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id, type, fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果传递参数是字符串则以id处理，否则以元素对象处理，</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> dom = <span class=\"keyword\">typeof</span> id === <span class=\"string\">'string'</span> ? $(<span class=\"string\">'#'</span> + id) : $(id);</span><br><span class=\"line\">    dom.on(type, fn);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 通过适配器发现如果两种框架的比较相似，适配比较容易，否则写起来复杂很多，因此尽量引入相似框架。</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>参数适配器</p>\n</blockquote>\n<p>适配器还有很多用途，比如方法需要传递多个参数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dosomething</span>(<span class=\"params\">name, title, age, color, size, prize</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 记住参数顺序是很困难的，因此我们经常以一个参数对象方式传入</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    name: name,</span><br><span class=\"line\">    title: title</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dosomething</span>(<span class=\"params\">obj</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 然而调用的时候不知道传递的参数是否完整，如有一些必须参数没有传入，一些参数是有默认值得等等，此时我们通常的做法是用适配器来适配传入的这个参数对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _adapter = &#123;</span><br><span class=\"line\">        name: <span class=\"string\">'me'</span>,</span><br><span class=\"line\">        title: <span class=\"string\">'设计模式'</span>，</span><br><span class=\"line\">        age: <span class=\"number\">24</span>,</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> _adapter) &#123;</span><br><span class=\"line\">        _adapter[i] = obj[i] || _adapter[i];</span><br><span class=\"line\">        <span class=\"comment\">// 或者 extend(_adapter, obj)   //  此时可能会多添加属性</span></span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>数据适配</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'javascript'</span>,<span class=\"number\">20</span>,<span class=\"string\">'时间'</span>， ‘日期’]</span><br><span class=\"line\"><span class=\"comment\">// 我们发现数组中的每个成员代表的意义不同，这种数据结构语义不好，我们通常会将其适配成对象形式，</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">''</span>,</span><br><span class=\"line\">    age: <span class=\"string\">''</span>,</span><br><span class=\"line\">    time: <span class=\"string\">''</span>,</span><br><span class=\"line\">    data: <span class=\"string\">''</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">arrToObjAdapter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        name: arr[<span class=\"number\">0</span>],</span><br><span class=\"line\">        age: arr[<span class=\"number\">1</span>]</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> adapterData = arrToObjAdapter(arr);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(adapterData)  <span class=\"comment\">// &#123;name: 'javascript', age: 20, ...&#125;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>服务器端数据适配</p>\n</blockquote>\n<p>它解决了前后端的数据依赖，前端程序不在为后端传递的数据所束缚，如果后端因为架构改变导致传递的数据结构发生变化，我们只需要写个适配器就可以放心了，如果后端的数据经常变化，无法控制数据的格式，那么我们在dosomething时最好不要直接调用，最好先将传递过来的数据适配成对我们可用的数据在使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为简化模型这里使用jQuery的ajax方法，理想数据是一个一维数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajaxAdapter</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理数据并返回新数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [data[<span class=\"string\">'key1'</span>], data[<span class=\"string\">'key2'</span>], ...]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    url: <span class=\"string\">'...'</span>,</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(data) &#123;</span><br><span class=\"line\">            doSomethin(ajaxAdapter(data))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 如果以后后端数据有任何变化我们只需相应的更改ajaxAdapter适配器转换格式</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>总结：传统设计模式中，适配器模式往往是适配两个类接口不兼容的问题，然而在JavaScript中，适配器的应用范围更广，比如适配两个代码库，适配前后端数据等等。JavaScript中的适配器的应用，更多应用在对象之间，为了使对象可用，通常我们会将对象拆分并重新包装，这样我们就要了解适配对象的内部结构，这也是与外观模式的区别所在，当然适配器模式同样解决了对象之间的耦合度。包装的适配器代码增加了一些资源开销，当然这是微乎其微的。</p>\n</blockquote>\n<h3 id=\"牛郎织女—代理模式\"><a href=\"#牛郎织女—代理模式\" class=\"headerlink\" title=\"牛郎织女—代理模式\"></a>牛郎织女—代理模式</h3><blockquote>\n<p>代理模式（Proxy）:由于一个对象不能直接应用另一个对象，所以需要通过代理对象在这两个对象之间起到代理作用。</p>\n</blockquote>\n<p>由于用户相册模块上传的照片量越来越大，导致服务器端需要将图片上传模块重新部署到另外一个域，这样对于前端来说，用户上传图片的请求路径发生变化，指向其他服务器，这就导致了跨域问题。</p>\n<blockquote>\n<p>跨域</p>\n<p>站长统计</p>\n<p>JSONP</p>\n<p>代理模板</p>\n</blockquote>\n<h3 id=\"房子装饰—装饰者模式\"><a href=\"#房子装饰—装饰者模式\" class=\"headerlink\" title=\"房子装饰—装饰者模式\"></a>房子装饰—装饰者模式</h3><blockquote>\n<p>装饰者模式（Decorator）:在不改变原对象的基础上，通过对其进行包装扩展（添加属性或者方法）使原有对象可以满足用户的更复杂需求。</p>\n</blockquote>\n<p>静止是相对的，运动是绝对的，所以没有一成不变的需求。</p>\n<p>？？ 情景：给页面所以input添加一个点击隐藏文案提示，注意不要覆盖原有的事件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> input1 = doucument.getElementById(<span class=\"string\">'input1'</span>)</span><br><span class=\"line\">input1.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> input2 = doucument.getElementById(<span class=\"string\">'input2'</span>)</span><br><span class=\"line\">input2.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...很多的input</span><br></pre></td></tr></table></figure>\n<p>以上这种解决方法，由于输入框太多，寻找与修改麻烦,所以试试装饰者模式吧！</p>\n<blockquote>\n<p>装饰已有的功能对象</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> decorator = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">input, fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取事件源</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> input = doucument.getElementById(input);</span><br><span class=\"line\">    <span class=\"comment\">// 若事件源已经绑定事件</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> input.onclick === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 缓存事件源原有事件函数</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> oldClickFn = input.onclick;</span><br><span class=\"line\">        input.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 事件源原有回调函数</span></span><br><span class=\"line\">            oldClickFn();</span><br><span class=\"line\">            <span class=\"comment\">// 执行事件源添加新增回调函数</span></span><br><span class=\"line\">            fn();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        input.onclick = fn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\">decorator（‘input1’, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;）</span><br><span class=\"line\">decorator（‘input2’, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;）</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>装饰者模式和适配器模式都是对一个对象的修饰来适配其他对象，二者不同，适配器模式是对原有对象适配，添加的方法与原有方法功能上大致相似，装饰者模式提供的方法与原来的方法是有一定区别的，还有最重要的一点是适配器模式新增的方法要调用原来的方法，要了解原有方法具体的细节，而装饰者模式不需要了解对象原有的功能，原方法原封不动的使用。</p>\n<p>总结：装饰模式是一种可以在不了解原有功能的基础上对功能拓展，装饰者模式对对象的拓展是一种良性拓展，不用了解其具体实现，只是在外部进行了一次封装拓展，是对原有功能完整性的一种保护。</p>\n</blockquote>\n<h3 id=\"城市间的道路—桥接模式\"><a href=\"#城市间的道路—桥接模式\" class=\"headerlink\" title=\"城市间的道路—桥接模式\"></a>城市间的道路—桥接模式</h3><blockquote>\n<p>桥接模式（Bridge）：在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦。</p>\n</blockquote>\n<p>有时候页面中的一些小小细节改变常常因逻辑相似导致大片臃肿的代码，让页面苦涩不堪。</p>\n<p>问题：给页面导航栏添加鼠标滑过特效，区别：每个鼠标滑过的效果不一样。。。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nav = <span class=\"built_in\">document</span>.getElementByTagName(<span class=\"string\">'span'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 不同的绑定不同效果</span></span><br><span class=\"line\">nav[<span class=\"number\">0</span>].onmouserover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.style.color = <span class=\"string\">'red'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.style.background = <span class=\"string\">'green'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">nav[<span class=\"number\">0</span>].onmouserout = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.style.color = <span class=\"string\">'#fff'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.style.background = <span class=\"string\">'#ccc'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">nav[<span class=\"number\">1</span>].onmouseover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getElementsByTagName(<span class=\"string\">'strong'</span>)[<span class=\"number\">0</span>]style.color = <span class=\"string\">'#fff'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getElementsByTagName(<span class=\"string\">'strong'</span>)[<span class=\"number\">0</span>]style.background = <span class=\"string\">'#ccc'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">nav[<span class=\"number\">1</span>].onmouseout = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getElementsByTagName(<span class=\"string\">'strong'</span>)[<span class=\"number\">0</span>]style.color = <span class=\"string\">'red'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getElementsByTagName(<span class=\"string\">'strong'</span>)[<span class=\"number\">0</span>]style.background = <span class=\"string\">'blue'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缺点：功能能实现，但是代码冗余。<br>解决方法：提取共同点，，对相同的逻辑做抽象提取处理，解除与事件中this的耦合。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeColor</span>(<span class=\"params\">dom, color, bg</span>) </span>&#123;</span><br><span class=\"line\">    dom.style.color = color;</span><br><span class=\"line\">    dom.style.background = bg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下一步：事件与业务逻辑之间的桥梁—桥接模式</p>\n<p>对于事件桥接方法，可以用一个匿名函数来代替，否则直接将changeColor作为事件的回调函数，解除this耦合。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nav[<span class=\"number\">0</span>].onmouserover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    changeColor(<span class=\"keyword\">this</span>, <span class=\"string\">'red'</span>, <span class=\"string\">'#fff'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方法是以新增一个桥接函数为代价实现的。</p>\n<blockquote>\n<p>多元化对象</p>\n</blockquote>\n<p>桥接模式对于多维的变化也同样适用，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Speed</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Speed.prototype.run = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Color</span>(<span class=\"params\">cl</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.cl = cl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Color.prtotype.draw = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Ball</span>(<span class=\"params\">x, y ,c</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.speed = <span class=\"keyword\">new</span> Speed(x, y);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.color = <span class=\"keyword\">new</span> Color(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Ball.prototype = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.speed.run();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.color.draw();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结：桥接模式主要特点：将实现层（如元素绑定的事件）与抽象层（如修饰页面UI逻辑）解耦分离，使两部分可以独立变化，由此可以看出桥接模式主要是对结构之间的结构，而抽象工厂模式与创建者模式主要业务在于创建，通过桥接模式实现的解耦，使实现层与抽象层分开处理，避免需求的改变造成对象内部的修改，体现了面向对象对扩展的开放及对修改的关闭原则。当然由于桥接的添加，有时也造成开发成本的增加，有时性能上也会受到影响。</p>\n<h3 id=\"超值午餐—组合模式\"><a href=\"#超值午餐—组合模式\" class=\"headerlink\" title=\"超值午餐—组合模式\"></a>超值午餐—组合模式</h3><blockquote>\n<p>组合模式（Composite）:又称部分-整体模式，将对象组合成树形结构以表示‘整体部分’的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>\n</blockquote>\n<h3 id=\"城市公交车—享元模式\"><a href=\"#城市公交车—享元模式\" class=\"headerlink\" title=\"城市公交车—享元模式\"></a>城市公交车—享元模式</h3><blockquote>\n<p>享元模式（Flyweight）运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多于的开销。</p>\n</blockquote>\n<p>总结：享元模式的应用目的是为了提高程序的执行效率与系统的性能，因此在大型系统开发中应用是比较广泛的，百分之一的效率提成有时可以发生质的改变，它可以避免程序中的数据重复，</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>结构型设计模式关注于如何将类或者对象组合成更大，更复杂的结构，以简化设计。</p>\n</blockquote>","more":"<h3 id=\"套餐服务—外观模式\"><a href=\"#套餐服务—外观模式\" class=\"headerlink\" title=\"套餐服务—外观模式\"></a>套餐服务—外观模式</h3><blockquote>\n<p>外观模式（Facade）：为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口，使得对子系统接口的访问更容易，在Javascript中有时也会用于对底层结构兼容性做统一封装来简化用户使用。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 外观模式实现</span></span><br><span class=\"line\"><span class=\"comment\">//提供一个更简单的高级接口，简化了我们对复杂的底层接口不统一的使用要求</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addEvent</span>(<span class=\"params\">dom, type, fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dom.addEventListener) &#123;</span><br><span class=\"line\">        dom.addEventListener(type, fn, <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(dom.attachEvent)&#123;</span><br><span class=\"line\">        dom.attachEvent(<span class=\"string\">'on'</span>+type, fn)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        dom[<span class=\"string\">'on'</span>+type] = fn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> DOM = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'dom'</span>);</span><br><span class=\"line\">addEvent(Dom, <span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 绑定的第一个事件</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'绑定的第一个事件'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">addEvent(Dom, <span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 绑定的第一个事件</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'绑定的第二个事件'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取事件对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> getEvent = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 标准浏览器返回event  IE window.event</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> event || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 获取元素</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> getTarget = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> event = getEvent(event);</span><br><span class=\"line\">    <span class=\"comment\">// 标准浏览器下event.target  IE下event.srcElement</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> event.target || event.srcElement;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 阻止默认行为</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> preventDefault = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> event = getEvent(event);</span><br><span class=\"line\">    <span class=\"comment\">// 标准浏览器</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(event.preventDefault) &#123;</span><br><span class=\"line\">        event.preventDefault</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// IE</span></span><br><span class=\"line\">        event.returnValue = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    preventDefault(e);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(getTarget(e) === Dom) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do somethihng</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>总结：外观模式是对接口方法的外层包装，以供上层代码调用以供上层代码使用，因此有时外观模式封装的接口方法不需要接口的具体实现，只需要按照接口使用规则使用即可，这也是对系统与使用者之间的一种松散耦合，使得系统与使用者之间不会因结构的变化而相互影响。</p>\n</blockquote>\n<h3 id=\"水管弯弯—适配器模式\"><a href=\"#水管弯弯—适配器模式\" class=\"headerlink\" title=\"水管弯弯—适配器模式\"></a>水管弯弯—适配器模式</h3><blockquote>\n<p>适配器模式(Adapter): 将一个类（对象）的接口（方法或属性）转化成另外一个接口，以满足用户需求，使类（对象）之间接口的不兼容问题通过适配器得以解决。</p>\n<p>生活中的适配器两根垂直相交的水管连接处的的直角弯管，使得两个不同方向的水管可以疏通流水，三角插头手机充电器对于两项插头是不可用的，此时需要一个三项转两项插头电源适配器等等，这些都是适配器。代码写适配器，其实就是为两个代码库所写的代码兼容运行而书写的额外代码，有了这样的适配器，你就不需要特意地重写以前的功能代码了。</p>\n<p>jQuery适配器</p>\n</blockquote>\n<p>某框架A和jQuery代码书写风格很像，加载完jQuery框架后写一个适配器，将我们已有的功能适配到jQuery，假如代码中有两个事件<br>，一个加载，一个点击，不过这两个事件与jQuery中的写法很像，所以做的改动不会太大，我们的适配器的主要任务是适配两种代码库中不兼容的代码，那么首当其冲的就是全局对象A与jQuery了，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.A = A = jQuery;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>适配异类框架</p>\n</blockquote>\n<p>如果两个框架直接相差太大，对于这种异类框架适配情况就复杂多了，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义框架</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> A = A|| &#123;&#125;</span><br><span class=\"line\">A.g = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">document</span>.getElementById(id)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 为元素绑定事件</span></span><br><span class=\"line\">A.on= <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id, type, fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果传递参数是字符串则以id处理，负责以元素对象处理，</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> dom = <span class=\"keyword\">typeof</span> id === <span class=\"string\">'string'</span> ? <span class=\"keyword\">this</span>.g(id) : id;</span><br><span class=\"line\">    <span class=\"comment\">// 标准dom2级添加事件方式</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dom.addEventListener) &#123;</span><br><span class=\"line\">        dom.addEventListener(type, fn, <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(dom.attachEvent)&#123;</span><br><span class=\"line\">        dom.attachEvent(<span class=\"string\">'on'</span>+type, fn)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        dom[<span class=\"string\">'on'</span>+type] = fn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\">A.on(<span class=\"built_in\">window</span>, <span class=\"string\">'load'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    A.on(<span class=\"string\">'dom'</span>, <span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 引入jQuery来换A库</span></span><br><span class=\"line\">A.g = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过jQuery获取jQuery对象，然后返回第一个成员</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> $(id).get(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A.on = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id, type, fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果传递参数是字符串则以id处理，否则以元素对象处理，</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> dom = <span class=\"keyword\">typeof</span> id === <span class=\"string\">'string'</span> ? $(<span class=\"string\">'#'</span> + id) : $(id);</span><br><span class=\"line\">    dom.on(type, fn);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 通过适配器发现如果两种框架的比较相似，适配比较容易，否则写起来复杂很多，因此尽量引入相似框架。</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>参数适配器</p>\n</blockquote>\n<p>适配器还有很多用途，比如方法需要传递多个参数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dosomething</span>(<span class=\"params\">name, title, age, color, size, prize</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 记住参数顺序是很困难的，因此我们经常以一个参数对象方式传入</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    name: name,</span><br><span class=\"line\">    title: title</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dosomething</span>(<span class=\"params\">obj</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 然而调用的时候不知道传递的参数是否完整，如有一些必须参数没有传入，一些参数是有默认值得等等，此时我们通常的做法是用适配器来适配传入的这个参数对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _adapter = &#123;</span><br><span class=\"line\">        name: <span class=\"string\">'me'</span>,</span><br><span class=\"line\">        title: <span class=\"string\">'设计模式'</span>，</span><br><span class=\"line\">        age: <span class=\"number\">24</span>,</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> _adapter) &#123;</span><br><span class=\"line\">        _adapter[i] = obj[i] || _adapter[i];</span><br><span class=\"line\">        <span class=\"comment\">// 或者 extend(_adapter, obj)   //  此时可能会多添加属性</span></span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>数据适配</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'javascript'</span>,<span class=\"number\">20</span>,<span class=\"string\">'时间'</span>， ‘日期’]</span><br><span class=\"line\"><span class=\"comment\">// 我们发现数组中的每个成员代表的意义不同，这种数据结构语义不好，我们通常会将其适配成对象形式，</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">''</span>,</span><br><span class=\"line\">    age: <span class=\"string\">''</span>,</span><br><span class=\"line\">    time: <span class=\"string\">''</span>,</span><br><span class=\"line\">    data: <span class=\"string\">''</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">arrToObjAdapter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        name: arr[<span class=\"number\">0</span>],</span><br><span class=\"line\">        age: arr[<span class=\"number\">1</span>]</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> adapterData = arrToObjAdapter(arr);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(adapterData)  <span class=\"comment\">// &#123;name: 'javascript', age: 20, ...&#125;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>服务器端数据适配</p>\n</blockquote>\n<p>它解决了前后端的数据依赖，前端程序不在为后端传递的数据所束缚，如果后端因为架构改变导致传递的数据结构发生变化，我们只需要写个适配器就可以放心了，如果后端的数据经常变化，无法控制数据的格式，那么我们在dosomething时最好不要直接调用，最好先将传递过来的数据适配成对我们可用的数据在使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为简化模型这里使用jQuery的ajax方法，理想数据是一个一维数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajaxAdapter</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理数据并返回新数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [data[<span class=\"string\">'key1'</span>], data[<span class=\"string\">'key2'</span>], ...]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    url: <span class=\"string\">'...'</span>,</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(data) &#123;</span><br><span class=\"line\">            doSomethin(ajaxAdapter(data))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 如果以后后端数据有任何变化我们只需相应的更改ajaxAdapter适配器转换格式</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>总结：传统设计模式中，适配器模式往往是适配两个类接口不兼容的问题，然而在JavaScript中，适配器的应用范围更广，比如适配两个代码库，适配前后端数据等等。JavaScript中的适配器的应用，更多应用在对象之间，为了使对象可用，通常我们会将对象拆分并重新包装，这样我们就要了解适配对象的内部结构，这也是与外观模式的区别所在，当然适配器模式同样解决了对象之间的耦合度。包装的适配器代码增加了一些资源开销，当然这是微乎其微的。</p>\n</blockquote>\n<h3 id=\"牛郎织女—代理模式\"><a href=\"#牛郎织女—代理模式\" class=\"headerlink\" title=\"牛郎织女—代理模式\"></a>牛郎织女—代理模式</h3><blockquote>\n<p>代理模式（Proxy）:由于一个对象不能直接应用另一个对象，所以需要通过代理对象在这两个对象之间起到代理作用。</p>\n</blockquote>\n<p>由于用户相册模块上传的照片量越来越大，导致服务器端需要将图片上传模块重新部署到另外一个域，这样对于前端来说，用户上传图片的请求路径发生变化，指向其他服务器，这就导致了跨域问题。</p>\n<blockquote>\n<p>跨域</p>\n<p>站长统计</p>\n<p>JSONP</p>\n<p>代理模板</p>\n</blockquote>\n<h3 id=\"房子装饰—装饰者模式\"><a href=\"#房子装饰—装饰者模式\" class=\"headerlink\" title=\"房子装饰—装饰者模式\"></a>房子装饰—装饰者模式</h3><blockquote>\n<p>装饰者模式（Decorator）:在不改变原对象的基础上，通过对其进行包装扩展（添加属性或者方法）使原有对象可以满足用户的更复杂需求。</p>\n</blockquote>\n<p>静止是相对的，运动是绝对的，所以没有一成不变的需求。</p>\n<p>？？ 情景：给页面所以input添加一个点击隐藏文案提示，注意不要覆盖原有的事件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> input1 = doucument.getElementById(<span class=\"string\">'input1'</span>)</span><br><span class=\"line\">input1.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> input2 = doucument.getElementById(<span class=\"string\">'input2'</span>)</span><br><span class=\"line\">input2.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...很多的input</span><br></pre></td></tr></table></figure>\n<p>以上这种解决方法，由于输入框太多，寻找与修改麻烦,所以试试装饰者模式吧！</p>\n<blockquote>\n<p>装饰已有的功能对象</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> decorator = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">input, fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取事件源</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> input = doucument.getElementById(input);</span><br><span class=\"line\">    <span class=\"comment\">// 若事件源已经绑定事件</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> input.onclick === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 缓存事件源原有事件函数</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> oldClickFn = input.onclick;</span><br><span class=\"line\">        input.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 事件源原有回调函数</span></span><br><span class=\"line\">            oldClickFn();</span><br><span class=\"line\">            <span class=\"comment\">// 执行事件源添加新增回调函数</span></span><br><span class=\"line\">            fn();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        input.onclick = fn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\">decorator（‘input1’, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;）</span><br><span class=\"line\">decorator（‘input2’, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;）</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>装饰者模式和适配器模式都是对一个对象的修饰来适配其他对象，二者不同，适配器模式是对原有对象适配，添加的方法与原有方法功能上大致相似，装饰者模式提供的方法与原来的方法是有一定区别的，还有最重要的一点是适配器模式新增的方法要调用原来的方法，要了解原有方法具体的细节，而装饰者模式不需要了解对象原有的功能，原方法原封不动的使用。</p>\n<p>总结：装饰模式是一种可以在不了解原有功能的基础上对功能拓展，装饰者模式对对象的拓展是一种良性拓展，不用了解其具体实现，只是在外部进行了一次封装拓展，是对原有功能完整性的一种保护。</p>\n</blockquote>\n<h3 id=\"城市间的道路—桥接模式\"><a href=\"#城市间的道路—桥接模式\" class=\"headerlink\" title=\"城市间的道路—桥接模式\"></a>城市间的道路—桥接模式</h3><blockquote>\n<p>桥接模式（Bridge）：在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦。</p>\n</blockquote>\n<p>有时候页面中的一些小小细节改变常常因逻辑相似导致大片臃肿的代码，让页面苦涩不堪。</p>\n<p>问题：给页面导航栏添加鼠标滑过特效，区别：每个鼠标滑过的效果不一样。。。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nav = <span class=\"built_in\">document</span>.getElementByTagName(<span class=\"string\">'span'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 不同的绑定不同效果</span></span><br><span class=\"line\">nav[<span class=\"number\">0</span>].onmouserover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.style.color = <span class=\"string\">'red'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.style.background = <span class=\"string\">'green'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">nav[<span class=\"number\">0</span>].onmouserout = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.style.color = <span class=\"string\">'#fff'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.style.background = <span class=\"string\">'#ccc'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">nav[<span class=\"number\">1</span>].onmouseover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getElementsByTagName(<span class=\"string\">'strong'</span>)[<span class=\"number\">0</span>]style.color = <span class=\"string\">'#fff'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getElementsByTagName(<span class=\"string\">'strong'</span>)[<span class=\"number\">0</span>]style.background = <span class=\"string\">'#ccc'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">nav[<span class=\"number\">1</span>].onmouseout = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getElementsByTagName(<span class=\"string\">'strong'</span>)[<span class=\"number\">0</span>]style.color = <span class=\"string\">'red'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getElementsByTagName(<span class=\"string\">'strong'</span>)[<span class=\"number\">0</span>]style.background = <span class=\"string\">'blue'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缺点：功能能实现，但是代码冗余。<br>解决方法：提取共同点，，对相同的逻辑做抽象提取处理，解除与事件中this的耦合。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeColor</span>(<span class=\"params\">dom, color, bg</span>) </span>&#123;</span><br><span class=\"line\">    dom.style.color = color;</span><br><span class=\"line\">    dom.style.background = bg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下一步：事件与业务逻辑之间的桥梁—桥接模式</p>\n<p>对于事件桥接方法，可以用一个匿名函数来代替，否则直接将changeColor作为事件的回调函数，解除this耦合。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nav[<span class=\"number\">0</span>].onmouserover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    changeColor(<span class=\"keyword\">this</span>, <span class=\"string\">'red'</span>, <span class=\"string\">'#fff'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方法是以新增一个桥接函数为代价实现的。</p>\n<blockquote>\n<p>多元化对象</p>\n</blockquote>\n<p>桥接模式对于多维的变化也同样适用，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Speed</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Speed.prototype.run = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Color</span>(<span class=\"params\">cl</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.cl = cl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Color.prtotype.draw = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Ball</span>(<span class=\"params\">x, y ,c</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.speed = <span class=\"keyword\">new</span> Speed(x, y);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.color = <span class=\"keyword\">new</span> Color(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Ball.prototype = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.speed.run();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.color.draw();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结：桥接模式主要特点：将实现层（如元素绑定的事件）与抽象层（如修饰页面UI逻辑）解耦分离，使两部分可以独立变化，由此可以看出桥接模式主要是对结构之间的结构，而抽象工厂模式与创建者模式主要业务在于创建，通过桥接模式实现的解耦，使实现层与抽象层分开处理，避免需求的改变造成对象内部的修改，体现了面向对象对扩展的开放及对修改的关闭原则。当然由于桥接的添加，有时也造成开发成本的增加，有时性能上也会受到影响。</p>\n<h3 id=\"超值午餐—组合模式\"><a href=\"#超值午餐—组合模式\" class=\"headerlink\" title=\"超值午餐—组合模式\"></a>超值午餐—组合模式</h3><blockquote>\n<p>组合模式（Composite）:又称部分-整体模式，将对象组合成树形结构以表示‘整体部分’的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>\n</blockquote>\n<h3 id=\"城市公交车—享元模式\"><a href=\"#城市公交车—享元模式\" class=\"headerlink\" title=\"城市公交车—享元模式\"></a>城市公交车—享元模式</h3><blockquote>\n<p>享元模式（Flyweight）运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多于的开销。</p>\n</blockquote>\n<p>总结：享元模式的应用目的是为了提高程序的执行效率与系统的性能，因此在大型系统开发中应用是比较广泛的，百分之一的效率提成有时可以发生质的改变，它可以避免程序中的数据重复，</p>"},{"title":"科学上网","date":"2017-10-23T00:49:27.000Z","_content":"\n>  科学上网，指通过一些方法越过 GFW 的封锁，让我们能够访问 Google，YouTube，wikipedia，Facebook 等网站，目前所有VPN都已经关闭或者只维护现有用户，如果大家有浏览外网的需求，建议使用ECS进行自建，本篇文章将教会你如何自建VPN\n\n<!-- more -->\n\n## 步骤\n1. 购买阿里云ECS实例\n2. 远程连接\n3. 在ECS上安装shadowsocks&启动\n4. 安装客户端&配置\n\n## 相关资料\n* [shadowsocks github地址](https://github.com/shadowsocks/shadowsocks/tree/master)\n\n## 购买阿里云ECS实例\n1.[阿里云ECS购买地址](https://ecs-buy.aliyun.com/#/prepay)\n\n## 连接ECS实例\n1. mac直接用terminal连接。window可以用[xshell,点击去下载](http://rj.baidu.com/soft/detail/15201.html?ald)\n2. `ssh root@ipAddress`，root是用户名，[ipAddress是购买的ECS IP，点击去查看](https://ecs.console.aliyun.com/#/home)\n\n## 在ECS上安装shadowsocks&启动\n1. 安装shadowsocks，[Github详细文档](https://github.com/shadowsocks/shadowsocks/wiki)\n```\nyum install python-setuptools && easy_install pip\npip install shadowsocks\n```\n\n2. 启动shadowsocks，配置文件[Github](https://github.com/shadowsocks/shadowsocks/wiki/Configuration-via-Config-File) \n```js\n// 直接启动\nssserver -p 443 -k password -m rc4-md5\n// 后台运行\nsudo ssserver -p 443 -k password -m rc4-md5 --user nobody -d start\n// 停止\nsudo ssserver -d stop\n```\n\n## 安装客户端&配置\n1. 安装客户端 [Github Ports and Clients](https://github.com/shadowsocks/shadowsocks/wiki/Ports-and-Clients)\n","source":"_posts/工具/科学上网.md","raw":"---\ntitle: 科学上网\ncategories:\n  - 前端技术\ntags:\n  - VPN\ndate: 2017-10-23 08:49:27\n---\n\n>  科学上网，指通过一些方法越过 GFW 的封锁，让我们能够访问 Google，YouTube，wikipedia，Facebook 等网站，目前所有VPN都已经关闭或者只维护现有用户，如果大家有浏览外网的需求，建议使用ECS进行自建，本篇文章将教会你如何自建VPN\n\n<!-- more -->\n\n## 步骤\n1. 购买阿里云ECS实例\n2. 远程连接\n3. 在ECS上安装shadowsocks&启动\n4. 安装客户端&配置\n\n## 相关资料\n* [shadowsocks github地址](https://github.com/shadowsocks/shadowsocks/tree/master)\n\n## 购买阿里云ECS实例\n1.[阿里云ECS购买地址](https://ecs-buy.aliyun.com/#/prepay)\n\n## 连接ECS实例\n1. mac直接用terminal连接。window可以用[xshell,点击去下载](http://rj.baidu.com/soft/detail/15201.html?ald)\n2. `ssh root@ipAddress`，root是用户名，[ipAddress是购买的ECS IP，点击去查看](https://ecs.console.aliyun.com/#/home)\n\n## 在ECS上安装shadowsocks&启动\n1. 安装shadowsocks，[Github详细文档](https://github.com/shadowsocks/shadowsocks/wiki)\n```\nyum install python-setuptools && easy_install pip\npip install shadowsocks\n```\n\n2. 启动shadowsocks，配置文件[Github](https://github.com/shadowsocks/shadowsocks/wiki/Configuration-via-Config-File) \n```js\n// 直接启动\nssserver -p 443 -k password -m rc4-md5\n// 后台运行\nsudo ssserver -p 443 -k password -m rc4-md5 --user nobody -d start\n// 停止\nsudo ssserver -d stop\n```\n\n## 安装客户端&配置\n1. 安装客户端 [Github Ports and Clients](https://github.com/shadowsocks/shadowsocks/wiki/Ports-and-Clients)\n","slug":"工具/科学上网","published":1,"updated":"2018-04-12T02:24:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3dd000iuox1lleer6vy","content":"<blockquote>\n<p> 科学上网，指通过一些方法越过 GFW 的封锁，让我们能够访问 Google，YouTube，wikipedia，Facebook 等网站，目前所有VPN都已经关闭或者只维护现有用户，如果大家有浏览外网的需求，建议使用ECS进行自建，本篇文章将教会你如何自建VPN</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><ol>\n<li>购买阿里云ECS实例</li>\n<li>远程连接</li>\n<li>在ECS上安装shadowsocks&amp;启动</li>\n<li>安装客户端&amp;配置</li>\n</ol>\n<h2 id=\"相关资料\"><a href=\"#相关资料\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h2><ul>\n<li><a href=\"https://github.com/shadowsocks/shadowsocks/tree/master\" target=\"_blank\" rel=\"noopener\">shadowsocks github地址</a></li>\n</ul>\n<h2 id=\"购买阿里云ECS实例\"><a href=\"#购买阿里云ECS实例\" class=\"headerlink\" title=\"购买阿里云ECS实例\"></a>购买阿里云ECS实例</h2><p>1.<a href=\"https://ecs-buy.aliyun.com/#/prepay\" target=\"_blank\" rel=\"noopener\">阿里云ECS购买地址</a></p>\n<h2 id=\"连接ECS实例\"><a href=\"#连接ECS实例\" class=\"headerlink\" title=\"连接ECS实例\"></a>连接ECS实例</h2><ol>\n<li>mac直接用terminal连接。window可以用<a href=\"http://rj.baidu.com/soft/detail/15201.html?ald\" target=\"_blank\" rel=\"noopener\">xshell,点击去下载</a></li>\n<li><code>ssh root@ipAddress</code>，root是用户名，<a href=\"https://ecs.console.aliyun.com/#/home\" target=\"_blank\" rel=\"noopener\">ipAddress是购买的ECS IP，点击去查看</a></li>\n</ol>\n<h2 id=\"在ECS上安装shadowsocks-amp-启动\"><a href=\"#在ECS上安装shadowsocks-amp-启动\" class=\"headerlink\" title=\"在ECS上安装shadowsocks&amp;启动\"></a>在ECS上安装shadowsocks&amp;启动</h2><ol>\n<li><p>安装shadowsocks，<a href=\"https://github.com/shadowsocks/shadowsocks/wiki\" target=\"_blank\" rel=\"noopener\">Github详细文档</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install python-setuptools &amp;&amp; easy_install pip</span><br><span class=\"line\">pip install shadowsocks</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动shadowsocks，配置文件<a href=\"https://github.com/shadowsocks/shadowsocks/wiki/Configuration-via-Config-File\" target=\"_blank\" rel=\"noopener\">Github</a> </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 直接启动</span></span><br><span class=\"line\">ssserver -p <span class=\"number\">443</span> -k password -m rc4-md5</span><br><span class=\"line\"><span class=\"comment\">// 后台运行</span></span><br><span class=\"line\">sudo ssserver -p <span class=\"number\">443</span> -k password -m rc4-md5 --user nobody -d start</span><br><span class=\"line\"><span class=\"comment\">// 停止</span></span><br><span class=\"line\">sudo ssserver -d stop</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"安装客户端-amp-配置\"><a href=\"#安装客户端-amp-配置\" class=\"headerlink\" title=\"安装客户端&amp;配置\"></a>安装客户端&amp;配置</h2><ol>\n<li>安装客户端 <a href=\"https://github.com/shadowsocks/shadowsocks/wiki/Ports-and-Clients\" target=\"_blank\" rel=\"noopener\">Github Ports and Clients</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p> 科学上网，指通过一些方法越过 GFW 的封锁，让我们能够访问 Google，YouTube，wikipedia，Facebook 等网站，目前所有VPN都已经关闭或者只维护现有用户，如果大家有浏览外网的需求，建议使用ECS进行自建，本篇文章将教会你如何自建VPN</p>\n</blockquote>","more":"<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><ol>\n<li>购买阿里云ECS实例</li>\n<li>远程连接</li>\n<li>在ECS上安装shadowsocks&amp;启动</li>\n<li>安装客户端&amp;配置</li>\n</ol>\n<h2 id=\"相关资料\"><a href=\"#相关资料\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h2><ul>\n<li><a href=\"https://github.com/shadowsocks/shadowsocks/tree/master\" target=\"_blank\" rel=\"noopener\">shadowsocks github地址</a></li>\n</ul>\n<h2 id=\"购买阿里云ECS实例\"><a href=\"#购买阿里云ECS实例\" class=\"headerlink\" title=\"购买阿里云ECS实例\"></a>购买阿里云ECS实例</h2><p>1.<a href=\"https://ecs-buy.aliyun.com/#/prepay\" target=\"_blank\" rel=\"noopener\">阿里云ECS购买地址</a></p>\n<h2 id=\"连接ECS实例\"><a href=\"#连接ECS实例\" class=\"headerlink\" title=\"连接ECS实例\"></a>连接ECS实例</h2><ol>\n<li>mac直接用terminal连接。window可以用<a href=\"http://rj.baidu.com/soft/detail/15201.html?ald\" target=\"_blank\" rel=\"noopener\">xshell,点击去下载</a></li>\n<li><code>ssh root@ipAddress</code>，root是用户名，<a href=\"https://ecs.console.aliyun.com/#/home\" target=\"_blank\" rel=\"noopener\">ipAddress是购买的ECS IP，点击去查看</a></li>\n</ol>\n<h2 id=\"在ECS上安装shadowsocks-amp-启动\"><a href=\"#在ECS上安装shadowsocks-amp-启动\" class=\"headerlink\" title=\"在ECS上安装shadowsocks&amp;启动\"></a>在ECS上安装shadowsocks&amp;启动</h2><ol>\n<li><p>安装shadowsocks，<a href=\"https://github.com/shadowsocks/shadowsocks/wiki\" target=\"_blank\" rel=\"noopener\">Github详细文档</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install python-setuptools &amp;&amp; easy_install pip</span><br><span class=\"line\">pip install shadowsocks</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动shadowsocks，配置文件<a href=\"https://github.com/shadowsocks/shadowsocks/wiki/Configuration-via-Config-File\" target=\"_blank\" rel=\"noopener\">Github</a> </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 直接启动</span></span><br><span class=\"line\">ssserver -p <span class=\"number\">443</span> -k password -m rc4-md5</span><br><span class=\"line\"><span class=\"comment\">// 后台运行</span></span><br><span class=\"line\">sudo ssserver -p <span class=\"number\">443</span> -k password -m rc4-md5 --user nobody -d start</span><br><span class=\"line\"><span class=\"comment\">// 停止</span></span><br><span class=\"line\">sudo ssserver -d stop</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"安装客户端-amp-配置\"><a href=\"#安装客户端-amp-配置\" class=\"headerlink\" title=\"安装客户端&amp;配置\"></a>安装客户端&amp;配置</h2><ol>\n<li>安装客户端 <a href=\"https://github.com/shadowsocks/shadowsocks/wiki/Ports-and-Clients\" target=\"_blank\" rel=\"noopener\">Github Ports and Clients</a></li>\n</ol>"},{"title":"vsCode插件","date":"2017-12-03T05:38:50.000Z","_content":"\n> Microsoft在2015年4月30日Build 开发者大会上正式宣布了 Visual Studio Code 项目：一个运行于 Mac OS X、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器,一款轻量，采取了和VS相同的UI界面，搭配合适的插件可以优化前端开发的体验\n\n<!-- more -->\n\n### 安装\n\n[vscode官网](https://code.visualstudio.com/Download)\n\nVScode 中文设置\n\n1. 快捷键F1\n2. 输入Configure Language 回车\n3. “locale”:  \"zh-CN\"，locale设置为zh-CNK\n4. 保存, 重启vscode\n\n### 布局\n\n* 左侧是用于展示所要编辑的所有文件和文件夹的文件管理器，依次是`资源管理器`，`搜索`，`GIT`，`调试`，`插件`，\n\n* 右侧是打开文件的编辑区域，最多可同时打开三个编辑区域到侧边。\n\n* 底栏：依次是`Git Branch`，`error&warning`，`编码格式`等。\n\n### 插件\n\n* vscode-icon\n\nF1->icon-->icon Theme-->选择(安装自己喜欢的主题)\n\n> 这款必须要推荐，明显提升效率的小插件，在项目文件多类型多的情况下，找到制定文件会大大缩短时间；\n\n* fileheader\n\n修改作者 文件--->首选项--->设置--->fileheader--->修改\n\n> 顶部注释模板，可定义作者、时间等信息，并会自动更新最后修改时间, 快捷键 Ctrl+Alt+i\n\n* HTML Snippets \n\nCtrl+Shift+P-->输入snippets-->选择语言-->打开.json文件-->配置-->使用\n\n> 超级实用且初级的 H5代码片段以及提示\n\n* JavaScript Snippet Pack\n\n> 针对js的插件，包含了js的常用语法关键字，很实用, 代码片段(Tab或者Enter补全)\n\n* JavaScript Snippets\n\n> 此扩展包含Visual Studio代码编辑器（支持JavaScript和TypeScript）的ES6语法中的JavaScript代码片段。\n\n* HTML CSS Support\n\n> 在编写样式表的时候，自动补全功能大大缩减了编写时间，推荐！让 html 标签上写class 智能提示当前项目所支持的样式新版已经支持scss文件检索   (提示已有的class名)\n\n* Auto Close Tag\n\n> 编写html代码的时候，写完开始标签，这款插件会自动补全结束标签，其实上面所说的html自动补全插件一个Tab就搞定了，不过有时也需要这款插件；\n\n* Auto Rename Tag\n\n> 非常实用！要修改标签名称的时候自动修改结束标签，节省一半时间，提升效率，非常棒！\n\n* Document this\n\n> js 的注释模板 （注意：新版的vscode已经原生支持,在function上输入/** tab） Ctrl+Alt+D 快捷键, 光标放在关键字上\n\n* Change Case\n\n下划线命名  <-->   驼峰命名    大小写转换   \n\n> 虽然 VSCode 内置了开箱即用的文本转换选项，但其只能进行文本大小写的转换。而此插件则添加了用于修改文本的更多命名格式，包括驼峰命名、下划线分隔命名，snake_case 命名以及 CONST_CAS 命名等\n\n* jQuery Code Snippets\n\n> jquery提示插件\n\n* Path Intellisense\n\n> 自动路劲补全，默认不带这个功能的，赶紧装\n\n* Emoji  \n\nF1-->emo-->选择插入\n\n> 很好玩的一款插件，可以在代码中插入emoji了，也许是程序猿的娱乐方式吧；\n\n* Open-In-Browser\n\n> 由于 VSCode 没有提供直接在浏览器中打开文件的内置界面，所以此插件在快捷菜单中添加了在默认浏览器查看文件选项，以及在客户端（Firefox，Chrome，IE）中打开命令面板选项\n\n* Code Runner\n\n> 非常强大的一款插件，能够运行多种语言的代码片段或代码文件：C，C ++，Java，JavaScript，PHP，Python，Perl，Ruby，Go等等，安装完成后，右上角出现一个三角形，点击这个按钮就可以运行你的文件了（必备）。\n\n* Dash\n\n> 查文档必备，搭配 dash（不过似乎只有 mac 版）,快捷键 ctrl + h 它根据你当前选中的语言查找 dash 里面的文档\n\n* Debugger for Chrome\n\n> 让 vscode 映射 chrome 的 debug功能，使静态页面都可以用 vscode 来打断点调试\n\n* CSS Peek(窥视)\n\n> 使用此插件，你可以追踪至样式表中 CSS 类和 ids 定义的地方。当你在 HTML 文件中右键单击选择器时，选择“ Go to Definition 和 Peek definition ”选项，它便会给你发送样式设置的 CSS 代码。\n\n* HTML Boilerplate(样板)\n\n> 通过使用 HTML 模版插件，你就摆脱了为 HTML 新文件重新编写头部和正文标签的苦恼。你只需在空文件中输入 html，并按 Tab 键，即可生成干净的文档结构。\n\n* Prettier(格式化)\n\n快捷键 Shift+Alt+F /////  Ctrl+Shift+P(F1)-->键入format-->格式化代码\n\n> Prettier 是目前 Web 开发中最受欢迎的代码格式化程序。安装了这个插件，它就能够自动应用 Prettier，并将整个 JS 和 CSS 文档快速格式化为统一的代码样式。如果你还想使用 ESLint，那么还有个 Prettier – Eslint 插件，你可不要错过咯！\n\n* Color Info\n\n> 这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了\n\n* SVG Viewer\n\n> 此插件在 Visual Studio 代码中添加了许多实用的 SVG 程序，你无需离开编辑器，便可以打开 SVG 文件并查看它们。同时，它还包含了用于转换为 PNG 格式和生成数据 URI 模式的选项。\n\n* Minify\n\nF1-->minify\n\n> 这是一款用于压缩合并 JavaScript 和 CSS 文件的应用程序。它提供了大量自定义的设置，以及自动压缩保存并导出为.min文件的选项。它能够分别通过 uglify-js、clean-css 和 html-minifier，与 JavaScript、CSS 和 HTML 协同工作。\n\n* Quokka(调试工具插件)\n\n> Quokka 是一个调试工具插件，能够根据你正在编写的代码提供实时反馈。它易于配置，并能够预览变量的函数和计算值结果。另外，在使用 JSX 或 TypeScript 项目中，它能够开箱即用\n\n* ESLint\n\n> EsLint可以帮助我们检查Javascript编程时的语法错误。比如：在Javascript应用中，你很难找到你漏泄的变量或者方法。EsLint能够帮助我们分析JS代码，找到bug并确保一定程度的JS语法书写的正确性。\n\n* Font-awesome\n\n> 用于 html 的Font-awesome代码片段\n\n* filesize\n\n> 在底部状态栏显示当前文件大小，点击后还可以看到详细创建、修改时间\n\n* Git History\n\n> 使用 command+shift+p（Ctrl+shift+p） 输入git log就可以看到了\n\n* htmltagwrap\n\n> 可以在选中HTML标签中外面套一层标签\n\n使用：选择一大段代码，然后按“Alt + W”\n\n* Image Preview\n\n> 鼠标移到路径里显示图像预览\n\n* Live Sass Compiler\n\n> 实时编译 sass ,不过需要配置，附上我的配置\n\n* markdownlint\n\n> markdown 语法检查\n\n* npm Intellisense\n\n> 在导入语句中自动填充npm模块,跟Node.js Modules Intellisense差不多\n\n* Project Manager\n\n> 工程项目过多时，shift+cmd+p(shift+ctrl+p) 然后输入project，第一次选择edit Project编辑自己的工程项目，之后就可以直接选择open打开你的项目\n\n* vscode-faker\n\n> 生成假数据，地址，电话，图片等等\n\n* Regex Previewer\n\n> 测试正则的插件v\n\n* React-Native/React/Redux snippets for es6/es7\n\n> react代码片段，下载人数超多\n\n* react-beautify\n\n> 格式化 javascript, JSX, typescript, TSX 文件","source":"_posts/工具/vsCode.md","raw":"---\ntitle: vsCode插件\ncategories:\n  - 前端技术\ntags:\n  - vsCode插件\ndate: 2017-12-03 13:38:50\n---\n\n> Microsoft在2015年4月30日Build 开发者大会上正式宣布了 Visual Studio Code 项目：一个运行于 Mac OS X、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器,一款轻量，采取了和VS相同的UI界面，搭配合适的插件可以优化前端开发的体验\n\n<!-- more -->\n\n### 安装\n\n[vscode官网](https://code.visualstudio.com/Download)\n\nVScode 中文设置\n\n1. 快捷键F1\n2. 输入Configure Language 回车\n3. “locale”:  \"zh-CN\"，locale设置为zh-CNK\n4. 保存, 重启vscode\n\n### 布局\n\n* 左侧是用于展示所要编辑的所有文件和文件夹的文件管理器，依次是`资源管理器`，`搜索`，`GIT`，`调试`，`插件`，\n\n* 右侧是打开文件的编辑区域，最多可同时打开三个编辑区域到侧边。\n\n* 底栏：依次是`Git Branch`，`error&warning`，`编码格式`等。\n\n### 插件\n\n* vscode-icon\n\nF1->icon-->icon Theme-->选择(安装自己喜欢的主题)\n\n> 这款必须要推荐，明显提升效率的小插件，在项目文件多类型多的情况下，找到制定文件会大大缩短时间；\n\n* fileheader\n\n修改作者 文件--->首选项--->设置--->fileheader--->修改\n\n> 顶部注释模板，可定义作者、时间等信息，并会自动更新最后修改时间, 快捷键 Ctrl+Alt+i\n\n* HTML Snippets \n\nCtrl+Shift+P-->输入snippets-->选择语言-->打开.json文件-->配置-->使用\n\n> 超级实用且初级的 H5代码片段以及提示\n\n* JavaScript Snippet Pack\n\n> 针对js的插件，包含了js的常用语法关键字，很实用, 代码片段(Tab或者Enter补全)\n\n* JavaScript Snippets\n\n> 此扩展包含Visual Studio代码编辑器（支持JavaScript和TypeScript）的ES6语法中的JavaScript代码片段。\n\n* HTML CSS Support\n\n> 在编写样式表的时候，自动补全功能大大缩减了编写时间，推荐！让 html 标签上写class 智能提示当前项目所支持的样式新版已经支持scss文件检索   (提示已有的class名)\n\n* Auto Close Tag\n\n> 编写html代码的时候，写完开始标签，这款插件会自动补全结束标签，其实上面所说的html自动补全插件一个Tab就搞定了，不过有时也需要这款插件；\n\n* Auto Rename Tag\n\n> 非常实用！要修改标签名称的时候自动修改结束标签，节省一半时间，提升效率，非常棒！\n\n* Document this\n\n> js 的注释模板 （注意：新版的vscode已经原生支持,在function上输入/** tab） Ctrl+Alt+D 快捷键, 光标放在关键字上\n\n* Change Case\n\n下划线命名  <-->   驼峰命名    大小写转换   \n\n> 虽然 VSCode 内置了开箱即用的文本转换选项，但其只能进行文本大小写的转换。而此插件则添加了用于修改文本的更多命名格式，包括驼峰命名、下划线分隔命名，snake_case 命名以及 CONST_CAS 命名等\n\n* jQuery Code Snippets\n\n> jquery提示插件\n\n* Path Intellisense\n\n> 自动路劲补全，默认不带这个功能的，赶紧装\n\n* Emoji  \n\nF1-->emo-->选择插入\n\n> 很好玩的一款插件，可以在代码中插入emoji了，也许是程序猿的娱乐方式吧；\n\n* Open-In-Browser\n\n> 由于 VSCode 没有提供直接在浏览器中打开文件的内置界面，所以此插件在快捷菜单中添加了在默认浏览器查看文件选项，以及在客户端（Firefox，Chrome，IE）中打开命令面板选项\n\n* Code Runner\n\n> 非常强大的一款插件，能够运行多种语言的代码片段或代码文件：C，C ++，Java，JavaScript，PHP，Python，Perl，Ruby，Go等等，安装完成后，右上角出现一个三角形，点击这个按钮就可以运行你的文件了（必备）。\n\n* Dash\n\n> 查文档必备，搭配 dash（不过似乎只有 mac 版）,快捷键 ctrl + h 它根据你当前选中的语言查找 dash 里面的文档\n\n* Debugger for Chrome\n\n> 让 vscode 映射 chrome 的 debug功能，使静态页面都可以用 vscode 来打断点调试\n\n* CSS Peek(窥视)\n\n> 使用此插件，你可以追踪至样式表中 CSS 类和 ids 定义的地方。当你在 HTML 文件中右键单击选择器时，选择“ Go to Definition 和 Peek definition ”选项，它便会给你发送样式设置的 CSS 代码。\n\n* HTML Boilerplate(样板)\n\n> 通过使用 HTML 模版插件，你就摆脱了为 HTML 新文件重新编写头部和正文标签的苦恼。你只需在空文件中输入 html，并按 Tab 键，即可生成干净的文档结构。\n\n* Prettier(格式化)\n\n快捷键 Shift+Alt+F /////  Ctrl+Shift+P(F1)-->键入format-->格式化代码\n\n> Prettier 是目前 Web 开发中最受欢迎的代码格式化程序。安装了这个插件，它就能够自动应用 Prettier，并将整个 JS 和 CSS 文档快速格式化为统一的代码样式。如果你还想使用 ESLint，那么还有个 Prettier – Eslint 插件，你可不要错过咯！\n\n* Color Info\n\n> 这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了\n\n* SVG Viewer\n\n> 此插件在 Visual Studio 代码中添加了许多实用的 SVG 程序，你无需离开编辑器，便可以打开 SVG 文件并查看它们。同时，它还包含了用于转换为 PNG 格式和生成数据 URI 模式的选项。\n\n* Minify\n\nF1-->minify\n\n> 这是一款用于压缩合并 JavaScript 和 CSS 文件的应用程序。它提供了大量自定义的设置，以及自动压缩保存并导出为.min文件的选项。它能够分别通过 uglify-js、clean-css 和 html-minifier，与 JavaScript、CSS 和 HTML 协同工作。\n\n* Quokka(调试工具插件)\n\n> Quokka 是一个调试工具插件，能够根据你正在编写的代码提供实时反馈。它易于配置，并能够预览变量的函数和计算值结果。另外，在使用 JSX 或 TypeScript 项目中，它能够开箱即用\n\n* ESLint\n\n> EsLint可以帮助我们检查Javascript编程时的语法错误。比如：在Javascript应用中，你很难找到你漏泄的变量或者方法。EsLint能够帮助我们分析JS代码，找到bug并确保一定程度的JS语法书写的正确性。\n\n* Font-awesome\n\n> 用于 html 的Font-awesome代码片段\n\n* filesize\n\n> 在底部状态栏显示当前文件大小，点击后还可以看到详细创建、修改时间\n\n* Git History\n\n> 使用 command+shift+p（Ctrl+shift+p） 输入git log就可以看到了\n\n* htmltagwrap\n\n> 可以在选中HTML标签中外面套一层标签\n\n使用：选择一大段代码，然后按“Alt + W”\n\n* Image Preview\n\n> 鼠标移到路径里显示图像预览\n\n* Live Sass Compiler\n\n> 实时编译 sass ,不过需要配置，附上我的配置\n\n* markdownlint\n\n> markdown 语法检查\n\n* npm Intellisense\n\n> 在导入语句中自动填充npm模块,跟Node.js Modules Intellisense差不多\n\n* Project Manager\n\n> 工程项目过多时，shift+cmd+p(shift+ctrl+p) 然后输入project，第一次选择edit Project编辑自己的工程项目，之后就可以直接选择open打开你的项目\n\n* vscode-faker\n\n> 生成假数据，地址，电话，图片等等\n\n* Regex Previewer\n\n> 测试正则的插件v\n\n* React-Native/React/Redux snippets for es6/es7\n\n> react代码片段，下载人数超多\n\n* react-beautify\n\n> 格式化 javascript, JSX, typescript, TSX 文件","slug":"工具/vsCode","published":1,"updated":"2018-04-12T02:24:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3de000juox1wmj3ff2k","content":"<blockquote>\n<p>Microsoft在2015年4月30日Build 开发者大会上正式宣布了 Visual Studio Code 项目：一个运行于 Mac OS X、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器,一款轻量，采取了和VS相同的UI界面，搭配合适的插件可以优化前端开发的体验</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p><a href=\"https://code.visualstudio.com/Download\" target=\"_blank\" rel=\"noopener\">vscode官网</a></p>\n<p>VScode 中文设置</p>\n<ol>\n<li>快捷键F1</li>\n<li>输入Configure Language 回车</li>\n<li>“locale”:  “zh-CN”，locale设置为zh-CNK</li>\n<li>保存, 重启vscode</li>\n</ol>\n<h3 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h3><ul>\n<li><p>左侧是用于展示所要编辑的所有文件和文件夹的文件管理器，依次是<code>资源管理器</code>，<code>搜索</code>，<code>GIT</code>，<code>调试</code>，<code>插件</code>，</p>\n</li>\n<li><p>右侧是打开文件的编辑区域，最多可同时打开三个编辑区域到侧边。</p>\n</li>\n<li><p>底栏：依次是<code>Git Branch</code>，<code>error&amp;warning</code>，<code>编码格式</code>等。</p>\n</li>\n</ul>\n<h3 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h3><ul>\n<li>vscode-icon</li>\n</ul>\n<p>F1-&gt;icon–&gt;icon Theme–&gt;选择(安装自己喜欢的主题)</p>\n<blockquote>\n<p>这款必须要推荐，明显提升效率的小插件，在项目文件多类型多的情况下，找到制定文件会大大缩短时间；</p>\n</blockquote>\n<ul>\n<li>fileheader</li>\n</ul>\n<p>修改作者 文件—&gt;首选项—&gt;设置—&gt;fileheader—&gt;修改</p>\n<blockquote>\n<p>顶部注释模板，可定义作者、时间等信息，并会自动更新最后修改时间, 快捷键 Ctrl+Alt+i</p>\n</blockquote>\n<ul>\n<li>HTML Snippets </li>\n</ul>\n<p>Ctrl+Shift+P–&gt;输入snippets–&gt;选择语言–&gt;打开.json文件–&gt;配置–&gt;使用</p>\n<blockquote>\n<p>超级实用且初级的 H5代码片段以及提示</p>\n</blockquote>\n<ul>\n<li>JavaScript Snippet Pack</li>\n</ul>\n<blockquote>\n<p>针对js的插件，包含了js的常用语法关键字，很实用, 代码片段(Tab或者Enter补全)</p>\n</blockquote>\n<ul>\n<li>JavaScript Snippets</li>\n</ul>\n<blockquote>\n<p>此扩展包含Visual Studio代码编辑器（支持JavaScript和TypeScript）的ES6语法中的JavaScript代码片段。</p>\n</blockquote>\n<ul>\n<li>HTML CSS Support</li>\n</ul>\n<blockquote>\n<p>在编写样式表的时候，自动补全功能大大缩减了编写时间，推荐！让 html 标签上写class 智能提示当前项目所支持的样式新版已经支持scss文件检索   (提示已有的class名)</p>\n</blockquote>\n<ul>\n<li>Auto Close Tag</li>\n</ul>\n<blockquote>\n<p>编写html代码的时候，写完开始标签，这款插件会自动补全结束标签，其实上面所说的html自动补全插件一个Tab就搞定了，不过有时也需要这款插件；</p>\n</blockquote>\n<ul>\n<li>Auto Rename Tag</li>\n</ul>\n<blockquote>\n<p>非常实用！要修改标签名称的时候自动修改结束标签，节省一半时间，提升效率，非常棒！</p>\n</blockquote>\n<ul>\n<li>Document this</li>\n</ul>\n<blockquote>\n<p>js 的注释模板 （注意：新版的vscode已经原生支持,在function上输入/** tab） Ctrl+Alt+D 快捷键, 光标放在关键字上</p>\n</blockquote>\n<ul>\n<li>Change Case</li>\n</ul>\n<p>下划线命名  &lt;–&gt;   驼峰命名    大小写转换   </p>\n<blockquote>\n<p>虽然 VSCode 内置了开箱即用的文本转换选项，但其只能进行文本大小写的转换。而此插件则添加了用于修改文本的更多命名格式，包括驼峰命名、下划线分隔命名，snake_case 命名以及 CONST_CAS 命名等</p>\n</blockquote>\n<ul>\n<li>jQuery Code Snippets</li>\n</ul>\n<blockquote>\n<p>jquery提示插件</p>\n</blockquote>\n<ul>\n<li>Path Intellisense</li>\n</ul>\n<blockquote>\n<p>自动路劲补全，默认不带这个功能的，赶紧装</p>\n</blockquote>\n<ul>\n<li>Emoji  </li>\n</ul>\n<p>F1–&gt;emo–&gt;选择插入</p>\n<blockquote>\n<p>很好玩的一款插件，可以在代码中插入emoji了，也许是程序猿的娱乐方式吧；</p>\n</blockquote>\n<ul>\n<li>Open-In-Browser</li>\n</ul>\n<blockquote>\n<p>由于 VSCode 没有提供直接在浏览器中打开文件的内置界面，所以此插件在快捷菜单中添加了在默认浏览器查看文件选项，以及在客户端（Firefox，Chrome，IE）中打开命令面板选项</p>\n</blockquote>\n<ul>\n<li>Code Runner</li>\n</ul>\n<blockquote>\n<p>非常强大的一款插件，能够运行多种语言的代码片段或代码文件：C，C ++，Java，JavaScript，PHP，Python，Perl，Ruby，Go等等，安装完成后，右上角出现一个三角形，点击这个按钮就可以运行你的文件了（必备）。</p>\n</blockquote>\n<ul>\n<li>Dash</li>\n</ul>\n<blockquote>\n<p>查文档必备，搭配 dash（不过似乎只有 mac 版）,快捷键 ctrl + h 它根据你当前选中的语言查找 dash 里面的文档</p>\n</blockquote>\n<ul>\n<li>Debugger for Chrome</li>\n</ul>\n<blockquote>\n<p>让 vscode 映射 chrome 的 debug功能，使静态页面都可以用 vscode 来打断点调试</p>\n</blockquote>\n<ul>\n<li>CSS Peek(窥视)</li>\n</ul>\n<blockquote>\n<p>使用此插件，你可以追踪至样式表中 CSS 类和 ids 定义的地方。当你在 HTML 文件中右键单击选择器时，选择“ Go to Definition 和 Peek definition ”选项，它便会给你发送样式设置的 CSS 代码。</p>\n</blockquote>\n<ul>\n<li>HTML Boilerplate(样板)</li>\n</ul>\n<blockquote>\n<p>通过使用 HTML 模版插件，你就摆脱了为 HTML 新文件重新编写头部和正文标签的苦恼。你只需在空文件中输入 html，并按 Tab 键，即可生成干净的文档结构。</p>\n</blockquote>\n<ul>\n<li>Prettier(格式化)</li>\n</ul>\n<p>快捷键 Shift+Alt+F /////  Ctrl+Shift+P(F1)–&gt;键入format–&gt;格式化代码</p>\n<blockquote>\n<p>Prettier 是目前 Web 开发中最受欢迎的代码格式化程序。安装了这个插件，它就能够自动应用 Prettier，并将整个 JS 和 CSS 文档快速格式化为统一的代码样式。如果你还想使用 ESLint，那么还有个 Prettier – Eslint 插件，你可不要错过咯！</p>\n</blockquote>\n<ul>\n<li>Color Info</li>\n</ul>\n<blockquote>\n<p>这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了</p>\n</blockquote>\n<ul>\n<li>SVG Viewer</li>\n</ul>\n<blockquote>\n<p>此插件在 Visual Studio 代码中添加了许多实用的 SVG 程序，你无需离开编辑器，便可以打开 SVG 文件并查看它们。同时，它还包含了用于转换为 PNG 格式和生成数据 URI 模式的选项。</p>\n</blockquote>\n<ul>\n<li>Minify</li>\n</ul>\n<p>F1–&gt;minify</p>\n<blockquote>\n<p>这是一款用于压缩合并 JavaScript 和 CSS 文件的应用程序。它提供了大量自定义的设置，以及自动压缩保存并导出为.min文件的选项。它能够分别通过 uglify-js、clean-css 和 html-minifier，与 JavaScript、CSS 和 HTML 协同工作。</p>\n</blockquote>\n<ul>\n<li>Quokka(调试工具插件)</li>\n</ul>\n<blockquote>\n<p>Quokka 是一个调试工具插件，能够根据你正在编写的代码提供实时反馈。它易于配置，并能够预览变量的函数和计算值结果。另外，在使用 JSX 或 TypeScript 项目中，它能够开箱即用</p>\n</blockquote>\n<ul>\n<li>ESLint</li>\n</ul>\n<blockquote>\n<p>EsLint可以帮助我们检查Javascript编程时的语法错误。比如：在Javascript应用中，你很难找到你漏泄的变量或者方法。EsLint能够帮助我们分析JS代码，找到bug并确保一定程度的JS语法书写的正确性。</p>\n</blockquote>\n<ul>\n<li>Font-awesome</li>\n</ul>\n<blockquote>\n<p>用于 html 的Font-awesome代码片段</p>\n</blockquote>\n<ul>\n<li>filesize</li>\n</ul>\n<blockquote>\n<p>在底部状态栏显示当前文件大小，点击后还可以看到详细创建、修改时间</p>\n</blockquote>\n<ul>\n<li>Git History</li>\n</ul>\n<blockquote>\n<p>使用 command+shift+p（Ctrl+shift+p） 输入git log就可以看到了</p>\n</blockquote>\n<ul>\n<li>htmltagwrap</li>\n</ul>\n<blockquote>\n<p>可以在选中HTML标签中外面套一层标签</p>\n</blockquote>\n<p>使用：选择一大段代码，然后按“Alt + W”</p>\n<ul>\n<li>Image Preview</li>\n</ul>\n<blockquote>\n<p>鼠标移到路径里显示图像预览</p>\n</blockquote>\n<ul>\n<li>Live Sass Compiler</li>\n</ul>\n<blockquote>\n<p>实时编译 sass ,不过需要配置，附上我的配置</p>\n</blockquote>\n<ul>\n<li>markdownlint</li>\n</ul>\n<blockquote>\n<p>markdown 语法检查</p>\n</blockquote>\n<ul>\n<li>npm Intellisense</li>\n</ul>\n<blockquote>\n<p>在导入语句中自动填充npm模块,跟Node.js Modules Intellisense差不多</p>\n</blockquote>\n<ul>\n<li>Project Manager</li>\n</ul>\n<blockquote>\n<p>工程项目过多时，shift+cmd+p(shift+ctrl+p) 然后输入project，第一次选择edit Project编辑自己的工程项目，之后就可以直接选择open打开你的项目</p>\n</blockquote>\n<ul>\n<li>vscode-faker</li>\n</ul>\n<blockquote>\n<p>生成假数据，地址，电话，图片等等</p>\n</blockquote>\n<ul>\n<li>Regex Previewer</li>\n</ul>\n<blockquote>\n<p>测试正则的插件v</p>\n</blockquote>\n<ul>\n<li>React-Native/React/Redux snippets for es6/es7</li>\n</ul>\n<blockquote>\n<p>react代码片段，下载人数超多</p>\n</blockquote>\n<ul>\n<li>react-beautify</li>\n</ul>\n<blockquote>\n<p>格式化 javascript, JSX, typescript, TSX 文件</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Microsoft在2015年4月30日Build 开发者大会上正式宣布了 Visual Studio Code 项目：一个运行于 Mac OS X、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器,一款轻量，采取了和VS相同的UI界面，搭配合适的插件可以优化前端开发的体验</p>\n</blockquote>","more":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p><a href=\"https://code.visualstudio.com/Download\" target=\"_blank\" rel=\"noopener\">vscode官网</a></p>\n<p>VScode 中文设置</p>\n<ol>\n<li>快捷键F1</li>\n<li>输入Configure Language 回车</li>\n<li>“locale”:  “zh-CN”，locale设置为zh-CNK</li>\n<li>保存, 重启vscode</li>\n</ol>\n<h3 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h3><ul>\n<li><p>左侧是用于展示所要编辑的所有文件和文件夹的文件管理器，依次是<code>资源管理器</code>，<code>搜索</code>，<code>GIT</code>，<code>调试</code>，<code>插件</code>，</p>\n</li>\n<li><p>右侧是打开文件的编辑区域，最多可同时打开三个编辑区域到侧边。</p>\n</li>\n<li><p>底栏：依次是<code>Git Branch</code>，<code>error&amp;warning</code>，<code>编码格式</code>等。</p>\n</li>\n</ul>\n<h3 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h3><ul>\n<li>vscode-icon</li>\n</ul>\n<p>F1-&gt;icon–&gt;icon Theme–&gt;选择(安装自己喜欢的主题)</p>\n<blockquote>\n<p>这款必须要推荐，明显提升效率的小插件，在项目文件多类型多的情况下，找到制定文件会大大缩短时间；</p>\n</blockquote>\n<ul>\n<li>fileheader</li>\n</ul>\n<p>修改作者 文件—&gt;首选项—&gt;设置—&gt;fileheader—&gt;修改</p>\n<blockquote>\n<p>顶部注释模板，可定义作者、时间等信息，并会自动更新最后修改时间, 快捷键 Ctrl+Alt+i</p>\n</blockquote>\n<ul>\n<li>HTML Snippets </li>\n</ul>\n<p>Ctrl+Shift+P–&gt;输入snippets–&gt;选择语言–&gt;打开.json文件–&gt;配置–&gt;使用</p>\n<blockquote>\n<p>超级实用且初级的 H5代码片段以及提示</p>\n</blockquote>\n<ul>\n<li>JavaScript Snippet Pack</li>\n</ul>\n<blockquote>\n<p>针对js的插件，包含了js的常用语法关键字，很实用, 代码片段(Tab或者Enter补全)</p>\n</blockquote>\n<ul>\n<li>JavaScript Snippets</li>\n</ul>\n<blockquote>\n<p>此扩展包含Visual Studio代码编辑器（支持JavaScript和TypeScript）的ES6语法中的JavaScript代码片段。</p>\n</blockquote>\n<ul>\n<li>HTML CSS Support</li>\n</ul>\n<blockquote>\n<p>在编写样式表的时候，自动补全功能大大缩减了编写时间，推荐！让 html 标签上写class 智能提示当前项目所支持的样式新版已经支持scss文件检索   (提示已有的class名)</p>\n</blockquote>\n<ul>\n<li>Auto Close Tag</li>\n</ul>\n<blockquote>\n<p>编写html代码的时候，写完开始标签，这款插件会自动补全结束标签，其实上面所说的html自动补全插件一个Tab就搞定了，不过有时也需要这款插件；</p>\n</blockquote>\n<ul>\n<li>Auto Rename Tag</li>\n</ul>\n<blockquote>\n<p>非常实用！要修改标签名称的时候自动修改结束标签，节省一半时间，提升效率，非常棒！</p>\n</blockquote>\n<ul>\n<li>Document this</li>\n</ul>\n<blockquote>\n<p>js 的注释模板 （注意：新版的vscode已经原生支持,在function上输入/** tab） Ctrl+Alt+D 快捷键, 光标放在关键字上</p>\n</blockquote>\n<ul>\n<li>Change Case</li>\n</ul>\n<p>下划线命名  &lt;–&gt;   驼峰命名    大小写转换   </p>\n<blockquote>\n<p>虽然 VSCode 内置了开箱即用的文本转换选项，但其只能进行文本大小写的转换。而此插件则添加了用于修改文本的更多命名格式，包括驼峰命名、下划线分隔命名，snake_case 命名以及 CONST_CAS 命名等</p>\n</blockquote>\n<ul>\n<li>jQuery Code Snippets</li>\n</ul>\n<blockquote>\n<p>jquery提示插件</p>\n</blockquote>\n<ul>\n<li>Path Intellisense</li>\n</ul>\n<blockquote>\n<p>自动路劲补全，默认不带这个功能的，赶紧装</p>\n</blockquote>\n<ul>\n<li>Emoji  </li>\n</ul>\n<p>F1–&gt;emo–&gt;选择插入</p>\n<blockquote>\n<p>很好玩的一款插件，可以在代码中插入emoji了，也许是程序猿的娱乐方式吧；</p>\n</blockquote>\n<ul>\n<li>Open-In-Browser</li>\n</ul>\n<blockquote>\n<p>由于 VSCode 没有提供直接在浏览器中打开文件的内置界面，所以此插件在快捷菜单中添加了在默认浏览器查看文件选项，以及在客户端（Firefox，Chrome，IE）中打开命令面板选项</p>\n</blockquote>\n<ul>\n<li>Code Runner</li>\n</ul>\n<blockquote>\n<p>非常强大的一款插件，能够运行多种语言的代码片段或代码文件：C，C ++，Java，JavaScript，PHP，Python，Perl，Ruby，Go等等，安装完成后，右上角出现一个三角形，点击这个按钮就可以运行你的文件了（必备）。</p>\n</blockquote>\n<ul>\n<li>Dash</li>\n</ul>\n<blockquote>\n<p>查文档必备，搭配 dash（不过似乎只有 mac 版）,快捷键 ctrl + h 它根据你当前选中的语言查找 dash 里面的文档</p>\n</blockquote>\n<ul>\n<li>Debugger for Chrome</li>\n</ul>\n<blockquote>\n<p>让 vscode 映射 chrome 的 debug功能，使静态页面都可以用 vscode 来打断点调试</p>\n</blockquote>\n<ul>\n<li>CSS Peek(窥视)</li>\n</ul>\n<blockquote>\n<p>使用此插件，你可以追踪至样式表中 CSS 类和 ids 定义的地方。当你在 HTML 文件中右键单击选择器时，选择“ Go to Definition 和 Peek definition ”选项，它便会给你发送样式设置的 CSS 代码。</p>\n</blockquote>\n<ul>\n<li>HTML Boilerplate(样板)</li>\n</ul>\n<blockquote>\n<p>通过使用 HTML 模版插件，你就摆脱了为 HTML 新文件重新编写头部和正文标签的苦恼。你只需在空文件中输入 html，并按 Tab 键，即可生成干净的文档结构。</p>\n</blockquote>\n<ul>\n<li>Prettier(格式化)</li>\n</ul>\n<p>快捷键 Shift+Alt+F /////  Ctrl+Shift+P(F1)–&gt;键入format–&gt;格式化代码</p>\n<blockquote>\n<p>Prettier 是目前 Web 开发中最受欢迎的代码格式化程序。安装了这个插件，它就能够自动应用 Prettier，并将整个 JS 和 CSS 文档快速格式化为统一的代码样式。如果你还想使用 ESLint，那么还有个 Prettier – Eslint 插件，你可不要错过咯！</p>\n</blockquote>\n<ul>\n<li>Color Info</li>\n</ul>\n<blockquote>\n<p>这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了</p>\n</blockquote>\n<ul>\n<li>SVG Viewer</li>\n</ul>\n<blockquote>\n<p>此插件在 Visual Studio 代码中添加了许多实用的 SVG 程序，你无需离开编辑器，便可以打开 SVG 文件并查看它们。同时，它还包含了用于转换为 PNG 格式和生成数据 URI 模式的选项。</p>\n</blockquote>\n<ul>\n<li>Minify</li>\n</ul>\n<p>F1–&gt;minify</p>\n<blockquote>\n<p>这是一款用于压缩合并 JavaScript 和 CSS 文件的应用程序。它提供了大量自定义的设置，以及自动压缩保存并导出为.min文件的选项。它能够分别通过 uglify-js、clean-css 和 html-minifier，与 JavaScript、CSS 和 HTML 协同工作。</p>\n</blockquote>\n<ul>\n<li>Quokka(调试工具插件)</li>\n</ul>\n<blockquote>\n<p>Quokka 是一个调试工具插件，能够根据你正在编写的代码提供实时反馈。它易于配置，并能够预览变量的函数和计算值结果。另外，在使用 JSX 或 TypeScript 项目中，它能够开箱即用</p>\n</blockquote>\n<ul>\n<li>ESLint</li>\n</ul>\n<blockquote>\n<p>EsLint可以帮助我们检查Javascript编程时的语法错误。比如：在Javascript应用中，你很难找到你漏泄的变量或者方法。EsLint能够帮助我们分析JS代码，找到bug并确保一定程度的JS语法书写的正确性。</p>\n</blockquote>\n<ul>\n<li>Font-awesome</li>\n</ul>\n<blockquote>\n<p>用于 html 的Font-awesome代码片段</p>\n</blockquote>\n<ul>\n<li>filesize</li>\n</ul>\n<blockquote>\n<p>在底部状态栏显示当前文件大小，点击后还可以看到详细创建、修改时间</p>\n</blockquote>\n<ul>\n<li>Git History</li>\n</ul>\n<blockquote>\n<p>使用 command+shift+p（Ctrl+shift+p） 输入git log就可以看到了</p>\n</blockquote>\n<ul>\n<li>htmltagwrap</li>\n</ul>\n<blockquote>\n<p>可以在选中HTML标签中外面套一层标签</p>\n</blockquote>\n<p>使用：选择一大段代码，然后按“Alt + W”</p>\n<ul>\n<li>Image Preview</li>\n</ul>\n<blockquote>\n<p>鼠标移到路径里显示图像预览</p>\n</blockquote>\n<ul>\n<li>Live Sass Compiler</li>\n</ul>\n<blockquote>\n<p>实时编译 sass ,不过需要配置，附上我的配置</p>\n</blockquote>\n<ul>\n<li>markdownlint</li>\n</ul>\n<blockquote>\n<p>markdown 语法检查</p>\n</blockquote>\n<ul>\n<li>npm Intellisense</li>\n</ul>\n<blockquote>\n<p>在导入语句中自动填充npm模块,跟Node.js Modules Intellisense差不多</p>\n</blockquote>\n<ul>\n<li>Project Manager</li>\n</ul>\n<blockquote>\n<p>工程项目过多时，shift+cmd+p(shift+ctrl+p) 然后输入project，第一次选择edit Project编辑自己的工程项目，之后就可以直接选择open打开你的项目</p>\n</blockquote>\n<ul>\n<li>vscode-faker</li>\n</ul>\n<blockquote>\n<p>生成假数据，地址，电话，图片等等</p>\n</blockquote>\n<ul>\n<li>Regex Previewer</li>\n</ul>\n<blockquote>\n<p>测试正则的插件v</p>\n</blockquote>\n<ul>\n<li>React-Native/React/Redux snippets for es6/es7</li>\n</ul>\n<blockquote>\n<p>react代码片段，下载人数超多</p>\n</blockquote>\n<ul>\n<li>react-beautify</li>\n</ul>\n<blockquote>\n<p>格式化 javascript, JSX, typescript, TSX 文件</p>\n</blockquote>"},{"title":"虚拟主机、ECS云服务器、VPS区别汇总","date":"2017-10-17T05:49:58.000Z","_content":"\n> 想做一个网站，但是在各种类型的服务器琳琅满目，现在总结一下市场上常见的几种服务器。\n\n<!-- more -->\n1.虚拟主机\n\n虚拟主机就是利用虚拟化的技术，将一台服务器划分出一定大小的空间，每个空间都给予单独的 FTP 权限和 Web 访问权限，多个用户共同平均使用这台服务器的硬件资源。不同配置的虚拟主机主要是在磁盘空间、数据库大小、流量上面的区别。虚拟主机也有可以分为独享的虚拟主机，和共享的虚拟主机。顾名思义，两者之间的区别在于服务器资源的独享和共享。网站主机、空间、都是一个意思。这一类的主机用户的权限很低，没有远程桌面，只有FTP权限供用户上传文档等操作。优势是比较价格便宜。\n\n2.VPS\n\n先说一下vps，Virtual Private Server 虚拟专用服务器,一般是将一个独立服务器通过虚拟化技术虚拟成多个虚拟专用服务器。与虚拟主机不同的是，你拥有的是一台虚拟的服务器，类似于Windows上的虚拟机一样，虽然是虚拟的，但是使用起来，和使用客户机没有什么区别。同理，VPS可以使用远程桌面登录对服务器进行维护操作。\n\n \n\n3.ECS云服务器\n\n现在的主流的服务器解决方案，一般理解云服务器和VPS一样，同样是虚拟化的技术虚拟出来的服务器。也有人说以前的VPS就是现在的ECS，其实不然，云服务器是一个计算，网络，存储的组合。简单点说就是通过多个CPU，内存，硬盘组成的计算池和存储池和网络的组合；在这样的平台上虚拟出的服务器，用户可以根据自己的运算需要选择配置不同的云服务器。具体区别总结如下：\n\n![呈现引擎的基本流程图](/img/VPS&ECS.png)\n\n\n","source":"_posts/服务器/虚拟主机&VPS&ECS.md","raw":"---\ntitle: 虚拟主机、ECS云服务器、VPS区别汇总\ndate: 2017-10-17 13:49:58\ncategories:\n- 前端技术\ntags: \n- 服务器区别\n---\n\n> 想做一个网站，但是在各种类型的服务器琳琅满目，现在总结一下市场上常见的几种服务器。\n\n<!-- more -->\n1.虚拟主机\n\n虚拟主机就是利用虚拟化的技术，将一台服务器划分出一定大小的空间，每个空间都给予单独的 FTP 权限和 Web 访问权限，多个用户共同平均使用这台服务器的硬件资源。不同配置的虚拟主机主要是在磁盘空间、数据库大小、流量上面的区别。虚拟主机也有可以分为独享的虚拟主机，和共享的虚拟主机。顾名思义，两者之间的区别在于服务器资源的独享和共享。网站主机、空间、都是一个意思。这一类的主机用户的权限很低，没有远程桌面，只有FTP权限供用户上传文档等操作。优势是比较价格便宜。\n\n2.VPS\n\n先说一下vps，Virtual Private Server 虚拟专用服务器,一般是将一个独立服务器通过虚拟化技术虚拟成多个虚拟专用服务器。与虚拟主机不同的是，你拥有的是一台虚拟的服务器，类似于Windows上的虚拟机一样，虽然是虚拟的，但是使用起来，和使用客户机没有什么区别。同理，VPS可以使用远程桌面登录对服务器进行维护操作。\n\n \n\n3.ECS云服务器\n\n现在的主流的服务器解决方案，一般理解云服务器和VPS一样，同样是虚拟化的技术虚拟出来的服务器。也有人说以前的VPS就是现在的ECS，其实不然，云服务器是一个计算，网络，存储的组合。简单点说就是通过多个CPU，内存，硬盘组成的计算池和存储池和网络的组合；在这样的平台上虚拟出的服务器，用户可以根据自己的运算需要选择配置不同的云服务器。具体区别总结如下：\n\n![呈现引擎的基本流程图](/img/VPS&ECS.png)\n\n\n","slug":"服务器/虚拟主机&VPS&ECS","published":1,"updated":"2018-04-12T02:24:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3de000kuox1ozxlqv7z","content":"<blockquote>\n<p>想做一个网站，但是在各种类型的服务器琳琅满目，现在总结一下市场上常见的几种服务器。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>1.虚拟主机</p>\n<p>虚拟主机就是利用虚拟化的技术，将一台服务器划分出一定大小的空间，每个空间都给予单独的 FTP 权限和 Web 访问权限，多个用户共同平均使用这台服务器的硬件资源。不同配置的虚拟主机主要是在磁盘空间、数据库大小、流量上面的区别。虚拟主机也有可以分为独享的虚拟主机，和共享的虚拟主机。顾名思义，两者之间的区别在于服务器资源的独享和共享。网站主机、空间、都是一个意思。这一类的主机用户的权限很低，没有远程桌面，只有FTP权限供用户上传文档等操作。优势是比较价格便宜。</p>\n<p>2.VPS</p>\n<p>先说一下vps，Virtual Private Server 虚拟专用服务器,一般是将一个独立服务器通过虚拟化技术虚拟成多个虚拟专用服务器。与虚拟主机不同的是，你拥有的是一台虚拟的服务器，类似于Windows上的虚拟机一样，虽然是虚拟的，但是使用起来，和使用客户机没有什么区别。同理，VPS可以使用远程桌面登录对服务器进行维护操作。</p>\n<p>3.ECS云服务器</p>\n<p>现在的主流的服务器解决方案，一般理解云服务器和VPS一样，同样是虚拟化的技术虚拟出来的服务器。也有人说以前的VPS就是现在的ECS，其实不然，云服务器是一个计算，网络，存储的组合。简单点说就是通过多个CPU，内存，硬盘组成的计算池和存储池和网络的组合；在这样的平台上虚拟出的服务器，用户可以根据自己的运算需要选择配置不同的云服务器。具体区别总结如下：</p>\n<p><img src=\"/img/VPS&amp;ECS.png\" alt=\"呈现引擎的基本流程图\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>想做一个网站，但是在各种类型的服务器琳琅满目，现在总结一下市场上常见的几种服务器。</p>\n</blockquote>","more":"<p>1.虚拟主机</p>\n<p>虚拟主机就是利用虚拟化的技术，将一台服务器划分出一定大小的空间，每个空间都给予单独的 FTP 权限和 Web 访问权限，多个用户共同平均使用这台服务器的硬件资源。不同配置的虚拟主机主要是在磁盘空间、数据库大小、流量上面的区别。虚拟主机也有可以分为独享的虚拟主机，和共享的虚拟主机。顾名思义，两者之间的区别在于服务器资源的独享和共享。网站主机、空间、都是一个意思。这一类的主机用户的权限很低，没有远程桌面，只有FTP权限供用户上传文档等操作。优势是比较价格便宜。</p>\n<p>2.VPS</p>\n<p>先说一下vps，Virtual Private Server 虚拟专用服务器,一般是将一个独立服务器通过虚拟化技术虚拟成多个虚拟专用服务器。与虚拟主机不同的是，你拥有的是一台虚拟的服务器，类似于Windows上的虚拟机一样，虽然是虚拟的，但是使用起来，和使用客户机没有什么区别。同理，VPS可以使用远程桌面登录对服务器进行维护操作。</p>\n<p>3.ECS云服务器</p>\n<p>现在的主流的服务器解决方案，一般理解云服务器和VPS一样，同样是虚拟化的技术虚拟出来的服务器。也有人说以前的VPS就是现在的ECS，其实不然，云服务器是一个计算，网络，存储的组合。简单点说就是通过多个CPU，内存，硬盘组成的计算池和存储池和网络的组合；在这样的平台上虚拟出的服务器，用户可以根据自己的运算需要选择配置不同的云服务器。具体区别总结如下：</p>\n<p><img src=\"/img/VPS&amp;ECS.png\" alt=\"呈现引擎的基本流程图\"></p>"},{"title":"各类书籍收藏","date":"2017-12-12T01:10:55.000Z","_content":"\n> 一旦读书用书成为一种嗜好之后，总要收藏一些书，书籍的作用确实是无与伦比、不可替代的。书能够影响人的心灵，人的心灵和人的气质又是相通的。一个人要想把自己打扮得可爱、漂亮或者具有吸引力，就来读书吧!\n\n<!-- more -->\n\n### 提升类\n\n***《走到人生边上——自问自答》***\n\n![](/img/book-collection/1.jpg)\n\n> 这是杨绛先生在96岁高龄时创作的一部充满哲思与意趣的散文集。杨先生通过对命运、人生、生与死、灵与肉等根本问题的思考，指出人生的价值在于遵循“灵性良心”的要求修炼自己，完善自身。\n\n***《独立思考：日常生活中的批判性思维》***\n\n![](/img/book-collection/2.jpg)\n\n> 在这个充满繁杂信息的时代，我们每天都会接触各种真假难辨、良莠不齐甚至相互矛盾的信息，我们如何拨除迷雾，去伪存真，用批判性思维看待这个世界，成为独立的思考者。本书是一部畅销的美国批判性思维课程教科书，具有很强的实践性和启发性。让你遇见一个更好的自己。\n\n***《追寻生命的意义》***\n\n![](/img/book-collection/3.jpg)\n\n> 这本书是一个人面对巨大的苦难时，用来拯救自己的内在世界，同时也是一个关于每个人存在的价值和能者多劳们生存的社会所应担负职责的思考。这本书对于每一个想要了解我们这个时代的人来说，都是一部必不可少的读物。\n\n***《乌合之众：大众心理研究》***\n\n![](/img/book-collection/4.jpg)\n\n> 这本书颠覆了我们通常对群体的认识，对群体的特点剖析得淋漓尽致，层层分析，逐步推进。这本书是社会心理学领域中具有影响力的著作，他对群体性格特征的预测在后世都得到了很好的印证，是一本值得每个人研读、思考的好书。\n\n***《吃掉那只青蛙》***\n\n![](/img/book-collection/5.jpg)\n\n> 博恩·崔西最具代表性著作，全球最值得阅读的时间管理领域经典之一，拒绝穷忙，把时间留给最重要的事。\n\n***《终结拖延症》***\n\n![](/img/book-collection/6.jpg)\n\n> 以行之有效的心理学方法，搞定拖延症，美国著名心理治疗专家30年经验分享。\n\n***《时间投资法》***\n\n![](/img/book-collection/7.jpg)\n\n> 时间需要的是‘投资‘，而不是’管理‘，时间投资法，让你的年收入增加10倍。\n\n***《刻意练习：如何从新手到大师》[美] 安德斯·艾利克森、罗伯特·普尔***\n\n![](/img/book-collection/8.jpg)\n\n> 总结起来就是：练习，不断地练习，反馈效果，走出舒适区，不过对于还不知道如何学习的，可以尝试读一下\n\n***《如何阅读一本书》[美] 莫提默·J. 艾德勒 / 查尔斯·范多伦 ***\n\n![](/img/book-collection/9.jpg)\n\n> 初探阅读的人，读这本书可以少走冤枉路。对阅读有所体会的人，读这本书可以有更深的印证和领悟。\n\n***《如何高效记忆》 [美]肯尼思•希格比（Kenneth L. Higbee）***\n\n![](/img/book-collection/10.jpg)\n\n> 书里面详细介绍了各种记忆方法，记忆宫殿、数字编码、体桩记忆、图片联想、语音记忆、人名头像记忆……\n\n***《学会提问》 [美] M.尼尔•布朗 / [美] 斯图尔特·基利 ***\n\n![](/img/book-collection/11.jpg)\n\n> 这本书教你一种全新的思考和提问方式，让你的提问更容易得到回复\n\n***《聪明人如何用方格笔记本》高桥政史 ***\n\n![](/img/book-collection/12.jpg \"《聪明人如何用方格笔记本》\")\n\n> 一本教读者如何通过记笔记整理大脑思路的书，不会做笔记或者想提高自己笔记水平的，这本书不能错过。\n\n***《高效能人士的七个习惯》[美] 史蒂芬·柯维 ***\n\n![](/img/book-collection/13.jpg)\n\n> 一本提升效率的书，本书的内容不是某种流行时尚或管理技巧，而是经过时间的考验并且能够指导行为的基本原则。\n\n***《关键对话》（美）科里·帕特森约瑟夫·格雷尼、罗恩·麦克米兰、艾尔·史威茨勒***\n\n![](/img/book-collection/13.jpg)\n\n> 该书剖析了人们在沟通上常见的盲点，并提供了许多谈话、倾听、行动技巧，辅以对话情境和小故事，帮助读者以最迅速的方式掌握这些技巧。\n\n***《拆掉思维的强》 古典 ***\n\n![](/img/book-collection/15.jpg)\n\n> 打破固定思维，有时钻牛角尖的时候就可以翻翻，书名就已经告诉我们这本书的主旨了，里面的故事案例读读还是蛮有意思的\n\n***《极简主义》[美] 乔舒亚•菲尔茨•米尔本 / [美] 瑞安•尼科迪默斯 ***\n\n![](/img/book-collection/15.jpg)\n\n> 打破固定思维，有时钻牛角尖的时候就可以翻翻，书名就已经告诉我们这本书的主旨了，里面的故事案例读读还是蛮有意思的\n\n***《趋势的力量》赵正宝***\n\n![](/img/book-collection/17.jpg)\n\n> 一本关于个人职业发展战略决策的实用指南，本书中还告诉读者该如何分析行业发展趋势，如何判断当期哪些行业是符合未来发展趋势的。\n\n***《自控力》[美] 凯利·麦格尼格尔***\n\n![](/img/book-collection/18.jpg)\n\n> 本书讲述了什么是自控力，自控力如何发生作用，以及为何自控力如此重要。觉得自己经常需要剁手的或者经常事后反悔的，可以翻一翻，不过说实话，这本书写的挺罗嗦的\n \n","source":"_posts/收藏/书籍收藏.md","raw":"---\ntitle: 各类书籍收藏\ndate: 2017-12-12 09:10:55\ncategories:\n- 收藏\ntags: \n- 书籍收藏\n---\n\n> 一旦读书用书成为一种嗜好之后，总要收藏一些书，书籍的作用确实是无与伦比、不可替代的。书能够影响人的心灵，人的心灵和人的气质又是相通的。一个人要想把自己打扮得可爱、漂亮或者具有吸引力，就来读书吧!\n\n<!-- more -->\n\n### 提升类\n\n***《走到人生边上——自问自答》***\n\n![](/img/book-collection/1.jpg)\n\n> 这是杨绛先生在96岁高龄时创作的一部充满哲思与意趣的散文集。杨先生通过对命运、人生、生与死、灵与肉等根本问题的思考，指出人生的价值在于遵循“灵性良心”的要求修炼自己，完善自身。\n\n***《独立思考：日常生活中的批判性思维》***\n\n![](/img/book-collection/2.jpg)\n\n> 在这个充满繁杂信息的时代，我们每天都会接触各种真假难辨、良莠不齐甚至相互矛盾的信息，我们如何拨除迷雾，去伪存真，用批判性思维看待这个世界，成为独立的思考者。本书是一部畅销的美国批判性思维课程教科书，具有很强的实践性和启发性。让你遇见一个更好的自己。\n\n***《追寻生命的意义》***\n\n![](/img/book-collection/3.jpg)\n\n> 这本书是一个人面对巨大的苦难时，用来拯救自己的内在世界，同时也是一个关于每个人存在的价值和能者多劳们生存的社会所应担负职责的思考。这本书对于每一个想要了解我们这个时代的人来说，都是一部必不可少的读物。\n\n***《乌合之众：大众心理研究》***\n\n![](/img/book-collection/4.jpg)\n\n> 这本书颠覆了我们通常对群体的认识，对群体的特点剖析得淋漓尽致，层层分析，逐步推进。这本书是社会心理学领域中具有影响力的著作，他对群体性格特征的预测在后世都得到了很好的印证，是一本值得每个人研读、思考的好书。\n\n***《吃掉那只青蛙》***\n\n![](/img/book-collection/5.jpg)\n\n> 博恩·崔西最具代表性著作，全球最值得阅读的时间管理领域经典之一，拒绝穷忙，把时间留给最重要的事。\n\n***《终结拖延症》***\n\n![](/img/book-collection/6.jpg)\n\n> 以行之有效的心理学方法，搞定拖延症，美国著名心理治疗专家30年经验分享。\n\n***《时间投资法》***\n\n![](/img/book-collection/7.jpg)\n\n> 时间需要的是‘投资‘，而不是’管理‘，时间投资法，让你的年收入增加10倍。\n\n***《刻意练习：如何从新手到大师》[美] 安德斯·艾利克森、罗伯特·普尔***\n\n![](/img/book-collection/8.jpg)\n\n> 总结起来就是：练习，不断地练习，反馈效果，走出舒适区，不过对于还不知道如何学习的，可以尝试读一下\n\n***《如何阅读一本书》[美] 莫提默·J. 艾德勒 / 查尔斯·范多伦 ***\n\n![](/img/book-collection/9.jpg)\n\n> 初探阅读的人，读这本书可以少走冤枉路。对阅读有所体会的人，读这本书可以有更深的印证和领悟。\n\n***《如何高效记忆》 [美]肯尼思•希格比（Kenneth L. Higbee）***\n\n![](/img/book-collection/10.jpg)\n\n> 书里面详细介绍了各种记忆方法，记忆宫殿、数字编码、体桩记忆、图片联想、语音记忆、人名头像记忆……\n\n***《学会提问》 [美] M.尼尔•布朗 / [美] 斯图尔特·基利 ***\n\n![](/img/book-collection/11.jpg)\n\n> 这本书教你一种全新的思考和提问方式，让你的提问更容易得到回复\n\n***《聪明人如何用方格笔记本》高桥政史 ***\n\n![](/img/book-collection/12.jpg \"《聪明人如何用方格笔记本》\")\n\n> 一本教读者如何通过记笔记整理大脑思路的书，不会做笔记或者想提高自己笔记水平的，这本书不能错过。\n\n***《高效能人士的七个习惯》[美] 史蒂芬·柯维 ***\n\n![](/img/book-collection/13.jpg)\n\n> 一本提升效率的书，本书的内容不是某种流行时尚或管理技巧，而是经过时间的考验并且能够指导行为的基本原则。\n\n***《关键对话》（美）科里·帕特森约瑟夫·格雷尼、罗恩·麦克米兰、艾尔·史威茨勒***\n\n![](/img/book-collection/13.jpg)\n\n> 该书剖析了人们在沟通上常见的盲点，并提供了许多谈话、倾听、行动技巧，辅以对话情境和小故事，帮助读者以最迅速的方式掌握这些技巧。\n\n***《拆掉思维的强》 古典 ***\n\n![](/img/book-collection/15.jpg)\n\n> 打破固定思维，有时钻牛角尖的时候就可以翻翻，书名就已经告诉我们这本书的主旨了，里面的故事案例读读还是蛮有意思的\n\n***《极简主义》[美] 乔舒亚•菲尔茨•米尔本 / [美] 瑞安•尼科迪默斯 ***\n\n![](/img/book-collection/15.jpg)\n\n> 打破固定思维，有时钻牛角尖的时候就可以翻翻，书名就已经告诉我们这本书的主旨了，里面的故事案例读读还是蛮有意思的\n\n***《趋势的力量》赵正宝***\n\n![](/img/book-collection/17.jpg)\n\n> 一本关于个人职业发展战略决策的实用指南，本书中还告诉读者该如何分析行业发展趋势，如何判断当期哪些行业是符合未来发展趋势的。\n\n***《自控力》[美] 凯利·麦格尼格尔***\n\n![](/img/book-collection/18.jpg)\n\n> 本书讲述了什么是自控力，自控力如何发生作用，以及为何自控力如此重要。觉得自己经常需要剁手的或者经常事后反悔的，可以翻一翻，不过说实话，这本书写的挺罗嗦的\n \n","slug":"收藏/书籍收藏","published":1,"updated":"2017-12-20T03:13:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3df000luox1zcpv5ys5","content":"<blockquote>\n<p>一旦读书用书成为一种嗜好之后，总要收藏一些书，书籍的作用确实是无与伦比、不可替代的。书能够影响人的心灵，人的心灵和人的气质又是相通的。一个人要想把自己打扮得可爱、漂亮或者具有吸引力，就来读书吧!</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"提升类\"><a href=\"#提升类\" class=\"headerlink\" title=\"提升类\"></a>提升类</h3><p><strong><em>《走到人生边上——自问自答》</em></strong></p>\n<p><img src=\"/img/book-collection/1.jpg\" alt=\"\"></p>\n<blockquote>\n<p>这是杨绛先生在96岁高龄时创作的一部充满哲思与意趣的散文集。杨先生通过对命运、人生、生与死、灵与肉等根本问题的思考，指出人生的价值在于遵循“灵性良心”的要求修炼自己，完善自身。</p>\n</blockquote>\n<p><strong><em>《独立思考：日常生活中的批判性思维》</em></strong></p>\n<p><img src=\"/img/book-collection/2.jpg\" alt=\"\"></p>\n<blockquote>\n<p>在这个充满繁杂信息的时代，我们每天都会接触各种真假难辨、良莠不齐甚至相互矛盾的信息，我们如何拨除迷雾，去伪存真，用批判性思维看待这个世界，成为独立的思考者。本书是一部畅销的美国批判性思维课程教科书，具有很强的实践性和启发性。让你遇见一个更好的自己。</p>\n</blockquote>\n<p><strong><em>《追寻生命的意义》</em></strong></p>\n<p><img src=\"/img/book-collection/3.jpg\" alt=\"\"></p>\n<blockquote>\n<p>这本书是一个人面对巨大的苦难时，用来拯救自己的内在世界，同时也是一个关于每个人存在的价值和能者多劳们生存的社会所应担负职责的思考。这本书对于每一个想要了解我们这个时代的人来说，都是一部必不可少的读物。</p>\n</blockquote>\n<p><strong><em>《乌合之众：大众心理研究》</em></strong></p>\n<p><img src=\"/img/book-collection/4.jpg\" alt=\"\"></p>\n<blockquote>\n<p>这本书颠覆了我们通常对群体的认识，对群体的特点剖析得淋漓尽致，层层分析，逐步推进。这本书是社会心理学领域中具有影响力的著作，他对群体性格特征的预测在后世都得到了很好的印证，是一本值得每个人研读、思考的好书。</p>\n</blockquote>\n<p><strong><em>《吃掉那只青蛙》</em></strong></p>\n<p><img src=\"/img/book-collection/5.jpg\" alt=\"\"></p>\n<blockquote>\n<p>博恩·崔西最具代表性著作，全球最值得阅读的时间管理领域经典之一，拒绝穷忙，把时间留给最重要的事。</p>\n</blockquote>\n<p><strong><em>《终结拖延症》</em></strong></p>\n<p><img src=\"/img/book-collection/6.jpg\" alt=\"\"></p>\n<blockquote>\n<p>以行之有效的心理学方法，搞定拖延症，美国著名心理治疗专家30年经验分享。</p>\n</blockquote>\n<p><strong><em>《时间投资法》</em></strong></p>\n<p><img src=\"/img/book-collection/7.jpg\" alt=\"\"></p>\n<blockquote>\n<p>时间需要的是‘投资‘，而不是’管理‘，时间投资法，让你的年收入增加10倍。</p>\n</blockquote>\n<p><strong><em>《刻意练习：如何从新手到大师》[美] 安德斯·艾利克森、罗伯特·普尔</em></strong></p>\n<p><img src=\"/img/book-collection/8.jpg\" alt=\"\"></p>\n<blockquote>\n<p>总结起来就是：练习，不断地练习，反馈效果，走出舒适区，不过对于还不知道如何学习的，可以尝试读一下</p>\n</blockquote>\n<p><strong><em>《如何阅读一本书》[美] 莫提默·J. 艾德勒 / 查尔斯·范多伦 </em></strong></p>\n<p><img src=\"/img/book-collection/9.jpg\" alt=\"\"></p>\n<blockquote>\n<p>初探阅读的人，读这本书可以少走冤枉路。对阅读有所体会的人，读这本书可以有更深的印证和领悟。</p>\n</blockquote>\n<p><strong><em>《如何高效记忆》 [美]肯尼思•希格比（Kenneth L. Higbee）</em></strong></p>\n<p><img src=\"/img/book-collection/10.jpg\" alt=\"\"></p>\n<blockquote>\n<p>书里面详细介绍了各种记忆方法，记忆宫殿、数字编码、体桩记忆、图片联想、语音记忆、人名头像记忆……</p>\n</blockquote>\n<p><strong><em>《学会提问》 [美] M.尼尔•布朗 / [美] 斯图尔特·基利 </em></strong></p>\n<p><img src=\"/img/book-collection/11.jpg\" alt=\"\"></p>\n<blockquote>\n<p>这本书教你一种全新的思考和提问方式，让你的提问更容易得到回复</p>\n</blockquote>\n<p><strong><em>《聪明人如何用方格笔记本》高桥政史 </em></strong></p>\n<p><img src=\"/img/book-collection/12.jpg\" alt=\"\" title=\"《聪明人如何用方格笔记本》\"></p>\n<blockquote>\n<p>一本教读者如何通过记笔记整理大脑思路的书，不会做笔记或者想提高自己笔记水平的，这本书不能错过。</p>\n</blockquote>\n<p><strong><em>《高效能人士的七个习惯》[美] 史蒂芬·柯维 </em></strong></p>\n<p><img src=\"/img/book-collection/13.jpg\" alt=\"\"></p>\n<blockquote>\n<p>一本提升效率的书，本书的内容不是某种流行时尚或管理技巧，而是经过时间的考验并且能够指导行为的基本原则。</p>\n</blockquote>\n<p><strong><em>《关键对话》（美）科里·帕特森约瑟夫·格雷尼、罗恩·麦克米兰、艾尔·史威茨勒</em></strong></p>\n<p><img src=\"/img/book-collection/13.jpg\" alt=\"\"></p>\n<blockquote>\n<p>该书剖析了人们在沟通上常见的盲点，并提供了许多谈话、倾听、行动技巧，辅以对话情境和小故事，帮助读者以最迅速的方式掌握这些技巧。</p>\n</blockquote>\n<p><strong><em>《拆掉思维的强》 古典 </em></strong></p>\n<p><img src=\"/img/book-collection/15.jpg\" alt=\"\"></p>\n<blockquote>\n<p>打破固定思维，有时钻牛角尖的时候就可以翻翻，书名就已经告诉我们这本书的主旨了，里面的故事案例读读还是蛮有意思的</p>\n</blockquote>\n<p><strong><em>《极简主义》[美] 乔舒亚•菲尔茨•米尔本 / [美] 瑞安•尼科迪默斯 </em></strong></p>\n<p><img src=\"/img/book-collection/15.jpg\" alt=\"\"></p>\n<blockquote>\n<p>打破固定思维，有时钻牛角尖的时候就可以翻翻，书名就已经告诉我们这本书的主旨了，里面的故事案例读读还是蛮有意思的</p>\n</blockquote>\n<p><strong><em>《趋势的力量》赵正宝</em></strong></p>\n<p><img src=\"/img/book-collection/17.jpg\" alt=\"\"></p>\n<blockquote>\n<p>一本关于个人职业发展战略决策的实用指南，本书中还告诉读者该如何分析行业发展趋势，如何判断当期哪些行业是符合未来发展趋势的。</p>\n</blockquote>\n<p><strong><em>《自控力》[美] 凯利·麦格尼格尔</em></strong></p>\n<p><img src=\"/img/book-collection/18.jpg\" alt=\"\"></p>\n<blockquote>\n<p>本书讲述了什么是自控力，自控力如何发生作用，以及为何自控力如此重要。觉得自己经常需要剁手的或者经常事后反悔的，可以翻一翻，不过说实话，这本书写的挺罗嗦的</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>一旦读书用书成为一种嗜好之后，总要收藏一些书，书籍的作用确实是无与伦比、不可替代的。书能够影响人的心灵，人的心灵和人的气质又是相通的。一个人要想把自己打扮得可爱、漂亮或者具有吸引力，就来读书吧!</p>\n</blockquote>","more":"<h3 id=\"提升类\"><a href=\"#提升类\" class=\"headerlink\" title=\"提升类\"></a>提升类</h3><p><strong><em>《走到人生边上——自问自答》</em></strong></p>\n<p><img src=\"/img/book-collection/1.jpg\" alt=\"\"></p>\n<blockquote>\n<p>这是杨绛先生在96岁高龄时创作的一部充满哲思与意趣的散文集。杨先生通过对命运、人生、生与死、灵与肉等根本问题的思考，指出人生的价值在于遵循“灵性良心”的要求修炼自己，完善自身。</p>\n</blockquote>\n<p><strong><em>《独立思考：日常生活中的批判性思维》</em></strong></p>\n<p><img src=\"/img/book-collection/2.jpg\" alt=\"\"></p>\n<blockquote>\n<p>在这个充满繁杂信息的时代，我们每天都会接触各种真假难辨、良莠不齐甚至相互矛盾的信息，我们如何拨除迷雾，去伪存真，用批判性思维看待这个世界，成为独立的思考者。本书是一部畅销的美国批判性思维课程教科书，具有很强的实践性和启发性。让你遇见一个更好的自己。</p>\n</blockquote>\n<p><strong><em>《追寻生命的意义》</em></strong></p>\n<p><img src=\"/img/book-collection/3.jpg\" alt=\"\"></p>\n<blockquote>\n<p>这本书是一个人面对巨大的苦难时，用来拯救自己的内在世界，同时也是一个关于每个人存在的价值和能者多劳们生存的社会所应担负职责的思考。这本书对于每一个想要了解我们这个时代的人来说，都是一部必不可少的读物。</p>\n</blockquote>\n<p><strong><em>《乌合之众：大众心理研究》</em></strong></p>\n<p><img src=\"/img/book-collection/4.jpg\" alt=\"\"></p>\n<blockquote>\n<p>这本书颠覆了我们通常对群体的认识，对群体的特点剖析得淋漓尽致，层层分析，逐步推进。这本书是社会心理学领域中具有影响力的著作，他对群体性格特征的预测在后世都得到了很好的印证，是一本值得每个人研读、思考的好书。</p>\n</blockquote>\n<p><strong><em>《吃掉那只青蛙》</em></strong></p>\n<p><img src=\"/img/book-collection/5.jpg\" alt=\"\"></p>\n<blockquote>\n<p>博恩·崔西最具代表性著作，全球最值得阅读的时间管理领域经典之一，拒绝穷忙，把时间留给最重要的事。</p>\n</blockquote>\n<p><strong><em>《终结拖延症》</em></strong></p>\n<p><img src=\"/img/book-collection/6.jpg\" alt=\"\"></p>\n<blockquote>\n<p>以行之有效的心理学方法，搞定拖延症，美国著名心理治疗专家30年经验分享。</p>\n</blockquote>\n<p><strong><em>《时间投资法》</em></strong></p>\n<p><img src=\"/img/book-collection/7.jpg\" alt=\"\"></p>\n<blockquote>\n<p>时间需要的是‘投资‘，而不是’管理‘，时间投资法，让你的年收入增加10倍。</p>\n</blockquote>\n<p><strong><em>《刻意练习：如何从新手到大师》[美] 安德斯·艾利克森、罗伯特·普尔</em></strong></p>\n<p><img src=\"/img/book-collection/8.jpg\" alt=\"\"></p>\n<blockquote>\n<p>总结起来就是：练习，不断地练习，反馈效果，走出舒适区，不过对于还不知道如何学习的，可以尝试读一下</p>\n</blockquote>\n<p><strong><em>《如何阅读一本书》[美] 莫提默·J. 艾德勒 / 查尔斯·范多伦 </em></strong></p>\n<p><img src=\"/img/book-collection/9.jpg\" alt=\"\"></p>\n<blockquote>\n<p>初探阅读的人，读这本书可以少走冤枉路。对阅读有所体会的人，读这本书可以有更深的印证和领悟。</p>\n</blockquote>\n<p><strong><em>《如何高效记忆》 [美]肯尼思•希格比（Kenneth L. Higbee）</em></strong></p>\n<p><img src=\"/img/book-collection/10.jpg\" alt=\"\"></p>\n<blockquote>\n<p>书里面详细介绍了各种记忆方法，记忆宫殿、数字编码、体桩记忆、图片联想、语音记忆、人名头像记忆……</p>\n</blockquote>\n<p><strong><em>《学会提问》 [美] M.尼尔•布朗 / [美] 斯图尔特·基利 </em></strong></p>\n<p><img src=\"/img/book-collection/11.jpg\" alt=\"\"></p>\n<blockquote>\n<p>这本书教你一种全新的思考和提问方式，让你的提问更容易得到回复</p>\n</blockquote>\n<p><strong><em>《聪明人如何用方格笔记本》高桥政史 </em></strong></p>\n<p><img src=\"/img/book-collection/12.jpg\" alt=\"\" title=\"《聪明人如何用方格笔记本》\"></p>\n<blockquote>\n<p>一本教读者如何通过记笔记整理大脑思路的书，不会做笔记或者想提高自己笔记水平的，这本书不能错过。</p>\n</blockquote>\n<p><strong><em>《高效能人士的七个习惯》[美] 史蒂芬·柯维 </em></strong></p>\n<p><img src=\"/img/book-collection/13.jpg\" alt=\"\"></p>\n<blockquote>\n<p>一本提升效率的书，本书的内容不是某种流行时尚或管理技巧，而是经过时间的考验并且能够指导行为的基本原则。</p>\n</blockquote>\n<p><strong><em>《关键对话》（美）科里·帕特森约瑟夫·格雷尼、罗恩·麦克米兰、艾尔·史威茨勒</em></strong></p>\n<p><img src=\"/img/book-collection/13.jpg\" alt=\"\"></p>\n<blockquote>\n<p>该书剖析了人们在沟通上常见的盲点，并提供了许多谈话、倾听、行动技巧，辅以对话情境和小故事，帮助读者以最迅速的方式掌握这些技巧。</p>\n</blockquote>\n<p><strong><em>《拆掉思维的强》 古典 </em></strong></p>\n<p><img src=\"/img/book-collection/15.jpg\" alt=\"\"></p>\n<blockquote>\n<p>打破固定思维，有时钻牛角尖的时候就可以翻翻，书名就已经告诉我们这本书的主旨了，里面的故事案例读读还是蛮有意思的</p>\n</blockquote>\n<p><strong><em>《极简主义》[美] 乔舒亚•菲尔茨•米尔本 / [美] 瑞安•尼科迪默斯 </em></strong></p>\n<p><img src=\"/img/book-collection/15.jpg\" alt=\"\"></p>\n<blockquote>\n<p>打破固定思维，有时钻牛角尖的时候就可以翻翻，书名就已经告诉我们这本书的主旨了，里面的故事案例读读还是蛮有意思的</p>\n</blockquote>\n<p><strong><em>《趋势的力量》赵正宝</em></strong></p>\n<p><img src=\"/img/book-collection/17.jpg\" alt=\"\"></p>\n<blockquote>\n<p>一本关于个人职业发展战略决策的实用指南，本书中还告诉读者该如何分析行业发展趋势，如何判断当期哪些行业是符合未来发展趋势的。</p>\n</blockquote>\n<p><strong><em>《自控力》[美] 凯利·麦格尼格尔</em></strong></p>\n<p><img src=\"/img/book-collection/18.jpg\" alt=\"\"></p>\n<blockquote>\n<p>本书讲述了什么是自控力，自控力如何发生作用，以及为何自控力如此重要。觉得自己经常需要剁手的或者经常事后反悔的，可以翻一翻，不过说实话，这本书写的挺罗嗦的</p>\n</blockquote>"},{"title":"探索浏览器","date":"2017-10-19T06:37:45.000Z","_content":"\n* [简介](#0)\n* [浏览器内核](#1)\n* [浏览器的主要功能](#2)\n* [浏览器的高层结构](#3)\n* [主流程](#4)\n* [浏览器处理脚本和样式表的顺序](#5)\n* [浏览器如何干活的](#6)\n\n<!-- more -->\n\n### <span id='0'>简介</span>\n\n网页浏览器（英语：web browser），常被简称为浏览器，是一种用于检索并展示万维网信息资源的应用程序。这些信息资源可为网页、图片、影音或其他内容，它们由统一资源标志符标志。信息资源中的超链接可使用户方便地浏览相关信息。\n\n网页浏览器虽然主要用于使用万维网，但也可用于获取专用网络中网页服务器之信息或文件系统内之文件。\n\n主流网页浏览器(内核): Internet Explorer(Trident)、Firefox(Gecko)、Safari(WebKit)、Chrome(WebKit)、Opera(Blink)\n\n### <span id='1'>[浏览器内核(渲染引擎)](https://baike.baidu.com/item/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/10602413?fr=aladdin)</span>\n\n浏览器最重要或者说核心的部分是_***浏览器内核***_，也称为排版引擎（layout engine）、页面渲染引擎（rendering engine）或样版引擎\n\n负责对网页语法的解释并渲染网页。 所以，通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因\n\n### <span id='2'>浏览器的主要功能</span>\n\n向服务器发出请求，在浏览器窗口中展示您选择的网络资源(一般是指 HTML 文档，也可以是 PDF、图片或其他的类型), 资源的位置由用户使用 URI（统一资源标示符）指定\n\n浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。 \n多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范\n\n奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如 Firefox 的下载管理器\n\n### <span id='3'>浏览器的高层结构</span>\n\n* **用户界面** - 包括地址栏、前进/后退按钮、书签菜单、用于刷新和停止加载当前文档的刷新和停止按钮、用于返回主页的主页按钮等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。\n* **浏览器引擎** - 在用户界面和呈现引擎之间传送指令。\n* **呈现引擎** - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。\n* **网络** - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。\n* **用户界面后端** - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。\n* **JavaScript 解释器**。用于解析和执行 JavaScript 代码。\n* **数据存储**。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“[网络数据库](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%BA%93/1717974?fr=aladdin)”，这是一个完整（但是轻便）的浏览器内数据库。\n\n![浏览器的主要组件图](/img/broswer1.png \"浏览器的主要组件\")\n_值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程(即每个标签页面都在独立的“沙箱”内运行，在提高安全性的同时，一个标签页面的崩溃也不会导致其他标签页面被关闭)_\n\n### <span id='4'>主流程</span>\n呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。\n\n然后进行如下所示的基本流程\n\n![呈现引擎的基本流程图](/img/broswer2.png \"呈现引擎的基本流程\")\n\n解析HTML来构造DOM树----->构造渲染树----->布局渲染树----->绘制渲染树\n\n呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：呈现树。\n\n呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。\n\n呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。\n\n需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。\n\n#### 主流程示例\n虽然 WebKit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。\n\n![呈现引擎的基本流程图](/img/broswer3.png)\n\n* Gecko将视觉格式化元素组成的树称为”框架树”(frame)。每个元素都是一个框架。Webkit使用的术语是”渲染树”(render)，它由”渲染对象”组成。\n* 对于元素的放置，Webkit 使用的术语是”布局”(layout)，而 Gecko 称之为”重排”(reflow)。\n* Webkit称利用dom节点及样式信息去构建render树的过程为attachment，Gecko在html和dom树之间附加了一层，这层称为内容接收器，相当制造dom元素的工厂\n\n### <span id='5'>浏览器处理脚本和样式表的顺序</span>\n\n#### 预解析\n\nWebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。\n\n#### 脚本\n\n网络的模型是同步的。网页作者希望解析器遇到 &lt;script&gt; 标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在 HTML4 和 HTML5 规范中进行了指定。作者也可以将脚本标注为“defer”，这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 增加了一个选项，可将脚本标记为异步，以便由其他线程解析和执行。\n\n#### 样式表\n\n另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。\n\n### <span id='6'>浏览器如何干活的?</span>\n\n1. 用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；\n2. 浏览器开始载入html代码，发现 &lt;head&gt; 标签内有一个 &lt;link&gt; 标签引用外部CSS文件；\n3. 浏览器又发出CSS文件的请求，服务器返回这个CSS文件；\n4. 浏览器继续载入html中 &lt;body&gt; 部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；\n5. 浏览器在代码中发现一个 &lt;img&gt;标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；\n6. 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；\n7. 浏览器发现了一个包含一行Javascript代码的 &lt;script&gt; 标签，赶快运行它；\n8. Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个 div （style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码；\n9. 终于等到了/html 的到来，浏览器泪流满面……\n10. 等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下&lt;link&gt;标签的CSS路径；\n11. 浏览器召集了在座的各位&lt;span&gt;&lt;ul&gt;&lt;li&gt;们，“大伙儿收拾收拾 行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/浏览器/浏览器工作原理.md","raw":"---\ntitle: 探索浏览器\ndate: 2017-10-19 14:37:45\ncategories:\n- 前端技术\ntags:\n- 浏览器\n---\n\n* [简介](#0)\n* [浏览器内核](#1)\n* [浏览器的主要功能](#2)\n* [浏览器的高层结构](#3)\n* [主流程](#4)\n* [浏览器处理脚本和样式表的顺序](#5)\n* [浏览器如何干活的](#6)\n\n<!-- more -->\n\n### <span id='0'>简介</span>\n\n网页浏览器（英语：web browser），常被简称为浏览器，是一种用于检索并展示万维网信息资源的应用程序。这些信息资源可为网页、图片、影音或其他内容，它们由统一资源标志符标志。信息资源中的超链接可使用户方便地浏览相关信息。\n\n网页浏览器虽然主要用于使用万维网，但也可用于获取专用网络中网页服务器之信息或文件系统内之文件。\n\n主流网页浏览器(内核): Internet Explorer(Trident)、Firefox(Gecko)、Safari(WebKit)、Chrome(WebKit)、Opera(Blink)\n\n### <span id='1'>[浏览器内核(渲染引擎)](https://baike.baidu.com/item/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/10602413?fr=aladdin)</span>\n\n浏览器最重要或者说核心的部分是_***浏览器内核***_，也称为排版引擎（layout engine）、页面渲染引擎（rendering engine）或样版引擎\n\n负责对网页语法的解释并渲染网页。 所以，通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因\n\n### <span id='2'>浏览器的主要功能</span>\n\n向服务器发出请求，在浏览器窗口中展示您选择的网络资源(一般是指 HTML 文档，也可以是 PDF、图片或其他的类型), 资源的位置由用户使用 URI（统一资源标示符）指定\n\n浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。 \n多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范\n\n奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如 Firefox 的下载管理器\n\n### <span id='3'>浏览器的高层结构</span>\n\n* **用户界面** - 包括地址栏、前进/后退按钮、书签菜单、用于刷新和停止加载当前文档的刷新和停止按钮、用于返回主页的主页按钮等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。\n* **浏览器引擎** - 在用户界面和呈现引擎之间传送指令。\n* **呈现引擎** - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。\n* **网络** - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。\n* **用户界面后端** - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。\n* **JavaScript 解释器**。用于解析和执行 JavaScript 代码。\n* **数据存储**。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“[网络数据库](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%BA%93/1717974?fr=aladdin)”，这是一个完整（但是轻便）的浏览器内数据库。\n\n![浏览器的主要组件图](/img/broswer1.png \"浏览器的主要组件\")\n_值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程(即每个标签页面都在独立的“沙箱”内运行，在提高安全性的同时，一个标签页面的崩溃也不会导致其他标签页面被关闭)_\n\n### <span id='4'>主流程</span>\n呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。\n\n然后进行如下所示的基本流程\n\n![呈现引擎的基本流程图](/img/broswer2.png \"呈现引擎的基本流程\")\n\n解析HTML来构造DOM树----->构造渲染树----->布局渲染树----->绘制渲染树\n\n呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：呈现树。\n\n呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。\n\n呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。\n\n需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。\n\n#### 主流程示例\n虽然 WebKit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。\n\n![呈现引擎的基本流程图](/img/broswer3.png)\n\n* Gecko将视觉格式化元素组成的树称为”框架树”(frame)。每个元素都是一个框架。Webkit使用的术语是”渲染树”(render)，它由”渲染对象”组成。\n* 对于元素的放置，Webkit 使用的术语是”布局”(layout)，而 Gecko 称之为”重排”(reflow)。\n* Webkit称利用dom节点及样式信息去构建render树的过程为attachment，Gecko在html和dom树之间附加了一层，这层称为内容接收器，相当制造dom元素的工厂\n\n### <span id='5'>浏览器处理脚本和样式表的顺序</span>\n\n#### 预解析\n\nWebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。\n\n#### 脚本\n\n网络的模型是同步的。网页作者希望解析器遇到 &lt;script&gt; 标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在 HTML4 和 HTML5 规范中进行了指定。作者也可以将脚本标注为“defer”，这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 增加了一个选项，可将脚本标记为异步，以便由其他线程解析和执行。\n\n#### 样式表\n\n另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。\n\n### <span id='6'>浏览器如何干活的?</span>\n\n1. 用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；\n2. 浏览器开始载入html代码，发现 &lt;head&gt; 标签内有一个 &lt;link&gt; 标签引用外部CSS文件；\n3. 浏览器又发出CSS文件的请求，服务器返回这个CSS文件；\n4. 浏览器继续载入html中 &lt;body&gt; 部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；\n5. 浏览器在代码中发现一个 &lt;img&gt;标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；\n6. 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；\n7. 浏览器发现了一个包含一行Javascript代码的 &lt;script&gt; 标签，赶快运行它；\n8. Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个 div （style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码；\n9. 终于等到了/html 的到来，浏览器泪流满面……\n10. 等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下&lt;link&gt;标签的CSS路径；\n11. 浏览器召集了在座的各位&lt;span&gt;&lt;ul&gt;&lt;li&gt;们，“大伙儿收拾收拾 行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"浏览器/浏览器工作原理","published":1,"updated":"2018-04-12T02:24:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3df000muox1noaoqch6","content":"<ul>\n<li><a href=\"#0\">简介</a></li>\n<li><a href=\"#1\">浏览器内核</a></li>\n<li><a href=\"#2\">浏览器的主要功能</a></li>\n<li><a href=\"#3\">浏览器的高层结构</a></li>\n<li><a href=\"#4\">主流程</a></li>\n<li><a href=\"#5\">浏览器处理脚本和样式表的顺序</a></li>\n<li><a href=\"#6\">浏览器如何干活的</a></li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><span id=\"0\">简介</span></h3><p>网页浏览器（英语：web browser），常被简称为浏览器，是一种用于检索并展示万维网信息资源的应用程序。这些信息资源可为网页、图片、影音或其他内容，它们由统一资源标志符标志。信息资源中的超链接可使用户方便地浏览相关信息。</p>\n<p>网页浏览器虽然主要用于使用万维网，但也可用于获取专用网络中网页服务器之信息或文件系统内之文件。</p>\n<p>主流网页浏览器(内核): Internet Explorer(Trident)、Firefox(Gecko)、Safari(WebKit)、Chrome(WebKit)、Opera(Blink)</p>\n<h3 id=\"浏览器内核-渲染引擎\"><a href=\"#浏览器内核-渲染引擎\" class=\"headerlink\" title=\"浏览器内核(渲染引擎)\"></a><span id=\"1\"><a href=\"https://baike.baidu.com/item/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/10602413?fr=aladdin\" target=\"_blank\" rel=\"noopener\">浏览器内核(渲染引擎)</a></span></h3><p>浏览器最重要或者说核心的部分是<em><strong><em>浏览器内核</em></strong></em>，也称为排版引擎（layout engine）、页面渲染引擎（rendering engine）或样版引擎</p>\n<p>负责对网页语法的解释并渲染网页。 所以，通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因</p>\n<h3 id=\"浏览器的主要功能\"><a href=\"#浏览器的主要功能\" class=\"headerlink\" title=\"浏览器的主要功能\"></a><span id=\"2\">浏览器的主要功能</span></h3><p>向服务器发出请求，在浏览器窗口中展示您选择的网络资源(一般是指 HTML 文档，也可以是 PDF、图片或其他的类型), 资源的位置由用户使用 URI（统一资源标示符）指定</p>\n<p>浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。<br>多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范</p>\n<p>奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如 Firefox 的下载管理器</p>\n<h3 id=\"浏览器的高层结构\"><a href=\"#浏览器的高层结构\" class=\"headerlink\" title=\"浏览器的高层结构\"></a><span id=\"3\">浏览器的高层结构</span></h3><ul>\n<li><strong>用户界面</strong> - 包括地址栏、前进/后退按钮、书签菜单、用于刷新和停止加载当前文档的刷新和停止按钮、用于返回主页的主页按钮等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</li>\n<li><strong>浏览器引擎</strong> - 在用户界面和呈现引擎之间传送指令。</li>\n<li><strong>呈现引擎</strong> - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li>\n<li><strong>网络</strong> - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</li>\n<li><strong>用户界面后端</strong> - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</li>\n<li><strong>JavaScript 解释器</strong>。用于解析和执行 JavaScript 代码。</li>\n<li><strong>数据存储</strong>。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“<a href=\"https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%BA%93/1717974?fr=aladdin\" target=\"_blank\" rel=\"noopener\">网络数据库</a>”，这是一个完整（但是轻便）的浏览器内数据库。</li>\n</ul>\n<p><img src=\"/img/broswer1.png\" alt=\"浏览器的主要组件图\" title=\"浏览器的主要组件\"><br><em>值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程(即每个标签页面都在独立的“沙箱”内运行，在提高安全性的同时，一个标签页面的崩溃也不会导致其他标签页面被关闭)</em></p>\n<h3 id=\"主流程\"><a href=\"#主流程\" class=\"headerlink\" title=\"主流程\"></a><span id=\"4\">主流程</span></h3><p>呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。</p>\n<p>然后进行如下所示的基本流程</p>\n<p><img src=\"/img/broswer2.png\" alt=\"呈现引擎的基本流程图\" title=\"呈现引擎的基本流程\"></p>\n<p>解析HTML来构造DOM树—–&gt;构造渲染树—–&gt;布局渲染树—–&gt;绘制渲染树</p>\n<p>呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：呈现树。</p>\n<p>呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</p>\n<p>呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。</p>\n<p>需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。</p>\n<h4 id=\"主流程示例\"><a href=\"#主流程示例\" class=\"headerlink\" title=\"主流程示例\"></a>主流程示例</h4><p>虽然 WebKit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。</p>\n<p><img src=\"/img/broswer3.png\" alt=\"呈现引擎的基本流程图\"></p>\n<ul>\n<li>Gecko将视觉格式化元素组成的树称为”框架树”(frame)。每个元素都是一个框架。Webkit使用的术语是”渲染树”(render)，它由”渲染对象”组成。</li>\n<li>对于元素的放置，Webkit 使用的术语是”布局”(layout)，而 Gecko 称之为”重排”(reflow)。</li>\n<li>Webkit称利用dom节点及样式信息去构建render树的过程为attachment，Gecko在html和dom树之间附加了一层，这层称为内容接收器，相当制造dom元素的工厂</li>\n</ul>\n<h3 id=\"浏览器处理脚本和样式表的顺序\"><a href=\"#浏览器处理脚本和样式表的顺序\" class=\"headerlink\" title=\"浏览器处理脚本和样式表的顺序\"></a><span id=\"5\">浏览器处理脚本和样式表的顺序</span></h3><h4 id=\"预解析\"><a href=\"#预解析\" class=\"headerlink\" title=\"预解析\"></a>预解析</h4><p>WebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。</p>\n<h4 id=\"脚本\"><a href=\"#脚本\" class=\"headerlink\" title=\"脚本\"></a>脚本</h4><p>网络的模型是同步的。网页作者希望解析器遇到 &lt;script&gt; 标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在 HTML4 和 HTML5 规范中进行了指定。作者也可以将脚本标注为“defer”，这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 增加了一个选项，可将脚本标记为异步，以便由其他线程解析和执行。</p>\n<h4 id=\"样式表\"><a href=\"#样式表\" class=\"headerlink\" title=\"样式表\"></a>样式表</h4><p>另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。</p>\n<h3 id=\"浏览器如何干活的\"><a href=\"#浏览器如何干活的\" class=\"headerlink\" title=\"浏览器如何干活的?\"></a><span id=\"6\">浏览器如何干活的?</span></h3><ol>\n<li>用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；</li>\n<li>浏览器开始载入html代码，发现 &lt;head&gt; 标签内有一个 &lt;link&gt; 标签引用外部CSS文件；</li>\n<li>浏览器又发出CSS文件的请求，服务器返回这个CSS文件；</li>\n<li>浏览器继续载入html中 &lt;body&gt; 部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；</li>\n<li>浏览器在代码中发现一个 &lt;img&gt;标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；</li>\n<li>服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；</li>\n<li>浏览器发现了一个包含一行Javascript代码的 &lt;script&gt; 标签，赶快运行它；</li>\n<li>Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个 div （style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码；</li>\n<li>终于等到了/html 的到来，浏览器泪流满面……</li>\n<li>等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下&lt;link&gt;标签的CSS路径；</li>\n<li>浏览器召集了在座的各位&lt;span&gt;&lt;ul&gt;&lt;li&gt;们，“大伙儿收拾收拾 行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<ul>\n<li><a href=\"#0\">简介</a></li>\n<li><a href=\"#1\">浏览器内核</a></li>\n<li><a href=\"#2\">浏览器的主要功能</a></li>\n<li><a href=\"#3\">浏览器的高层结构</a></li>\n<li><a href=\"#4\">主流程</a></li>\n<li><a href=\"#5\">浏览器处理脚本和样式表的顺序</a></li>\n<li><a href=\"#6\">浏览器如何干活的</a></li>\n</ul>","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><span id=\"0\">简介</span></h3><p>网页浏览器（英语：web browser），常被简称为浏览器，是一种用于检索并展示万维网信息资源的应用程序。这些信息资源可为网页、图片、影音或其他内容，它们由统一资源标志符标志。信息资源中的超链接可使用户方便地浏览相关信息。</p>\n<p>网页浏览器虽然主要用于使用万维网，但也可用于获取专用网络中网页服务器之信息或文件系统内之文件。</p>\n<p>主流网页浏览器(内核): Internet Explorer(Trident)、Firefox(Gecko)、Safari(WebKit)、Chrome(WebKit)、Opera(Blink)</p>\n<h3 id=\"浏览器内核-渲染引擎\"><a href=\"#浏览器内核-渲染引擎\" class=\"headerlink\" title=\"浏览器内核(渲染引擎)\"></a><span id=\"1\"><a href=\"https://baike.baidu.com/item/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/10602413?fr=aladdin\" target=\"_blank\" rel=\"noopener\">浏览器内核(渲染引擎)</a></span></h3><p>浏览器最重要或者说核心的部分是<em><strong><em>浏览器内核</em></strong></em>，也称为排版引擎（layout engine）、页面渲染引擎（rendering engine）或样版引擎</p>\n<p>负责对网页语法的解释并渲染网页。 所以，通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因</p>\n<h3 id=\"浏览器的主要功能\"><a href=\"#浏览器的主要功能\" class=\"headerlink\" title=\"浏览器的主要功能\"></a><span id=\"2\">浏览器的主要功能</span></h3><p>向服务器发出请求，在浏览器窗口中展示您选择的网络资源(一般是指 HTML 文档，也可以是 PDF、图片或其他的类型), 资源的位置由用户使用 URI（统一资源标示符）指定</p>\n<p>浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。<br>多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范</p>\n<p>奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如 Firefox 的下载管理器</p>\n<h3 id=\"浏览器的高层结构\"><a href=\"#浏览器的高层结构\" class=\"headerlink\" title=\"浏览器的高层结构\"></a><span id=\"3\">浏览器的高层结构</span></h3><ul>\n<li><strong>用户界面</strong> - 包括地址栏、前进/后退按钮、书签菜单、用于刷新和停止加载当前文档的刷新和停止按钮、用于返回主页的主页按钮等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</li>\n<li><strong>浏览器引擎</strong> - 在用户界面和呈现引擎之间传送指令。</li>\n<li><strong>呈现引擎</strong> - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li>\n<li><strong>网络</strong> - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</li>\n<li><strong>用户界面后端</strong> - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</li>\n<li><strong>JavaScript 解释器</strong>。用于解析和执行 JavaScript 代码。</li>\n<li><strong>数据存储</strong>。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“<a href=\"https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%BA%93/1717974?fr=aladdin\" target=\"_blank\" rel=\"noopener\">网络数据库</a>”，这是一个完整（但是轻便）的浏览器内数据库。</li>\n</ul>\n<p><img src=\"/img/broswer1.png\" alt=\"浏览器的主要组件图\" title=\"浏览器的主要组件\"><br><em>值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程(即每个标签页面都在独立的“沙箱”内运行，在提高安全性的同时，一个标签页面的崩溃也不会导致其他标签页面被关闭)</em></p>\n<h3 id=\"主流程\"><a href=\"#主流程\" class=\"headerlink\" title=\"主流程\"></a><span id=\"4\">主流程</span></h3><p>呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。</p>\n<p>然后进行如下所示的基本流程</p>\n<p><img src=\"/img/broswer2.png\" alt=\"呈现引擎的基本流程图\" title=\"呈现引擎的基本流程\"></p>\n<p>解析HTML来构造DOM树—–&gt;构造渲染树—–&gt;布局渲染树—–&gt;绘制渲染树</p>\n<p>呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：呈现树。</p>\n<p>呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</p>\n<p>呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。</p>\n<p>需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。</p>\n<h4 id=\"主流程示例\"><a href=\"#主流程示例\" class=\"headerlink\" title=\"主流程示例\"></a>主流程示例</h4><p>虽然 WebKit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。</p>\n<p><img src=\"/img/broswer3.png\" alt=\"呈现引擎的基本流程图\"></p>\n<ul>\n<li>Gecko将视觉格式化元素组成的树称为”框架树”(frame)。每个元素都是一个框架。Webkit使用的术语是”渲染树”(render)，它由”渲染对象”组成。</li>\n<li>对于元素的放置，Webkit 使用的术语是”布局”(layout)，而 Gecko 称之为”重排”(reflow)。</li>\n<li>Webkit称利用dom节点及样式信息去构建render树的过程为attachment，Gecko在html和dom树之间附加了一层，这层称为内容接收器，相当制造dom元素的工厂</li>\n</ul>\n<h3 id=\"浏览器处理脚本和样式表的顺序\"><a href=\"#浏览器处理脚本和样式表的顺序\" class=\"headerlink\" title=\"浏览器处理脚本和样式表的顺序\"></a><span id=\"5\">浏览器处理脚本和样式表的顺序</span></h3><h4 id=\"预解析\"><a href=\"#预解析\" class=\"headerlink\" title=\"预解析\"></a>预解析</h4><p>WebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。</p>\n<h4 id=\"脚本\"><a href=\"#脚本\" class=\"headerlink\" title=\"脚本\"></a>脚本</h4><p>网络的模型是同步的。网页作者希望解析器遇到 &lt;script&gt; 标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在 HTML4 和 HTML5 规范中进行了指定。作者也可以将脚本标注为“defer”，这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 增加了一个选项，可将脚本标记为异步，以便由其他线程解析和执行。</p>\n<h4 id=\"样式表\"><a href=\"#样式表\" class=\"headerlink\" title=\"样式表\"></a>样式表</h4><p>另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。</p>\n<h3 id=\"浏览器如何干活的\"><a href=\"#浏览器如何干活的\" class=\"headerlink\" title=\"浏览器如何干活的?\"></a><span id=\"6\">浏览器如何干活的?</span></h3><ol>\n<li>用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；</li>\n<li>浏览器开始载入html代码，发现 &lt;head&gt; 标签内有一个 &lt;link&gt; 标签引用外部CSS文件；</li>\n<li>浏览器又发出CSS文件的请求，服务器返回这个CSS文件；</li>\n<li>浏览器继续载入html中 &lt;body&gt; 部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；</li>\n<li>浏览器在代码中发现一个 &lt;img&gt;标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；</li>\n<li>服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；</li>\n<li>浏览器发现了一个包含一行Javascript代码的 &lt;script&gt; 标签，赶快运行它；</li>\n<li>Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个 div （style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码；</li>\n<li>终于等到了/html 的到来，浏览器泪流满面……</li>\n<li>等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下&lt;link&gt;标签的CSS路径；</li>\n<li>浏览器召集了在座的各位&lt;span&gt;&lt;ul&gt;&lt;li&gt;们，“大伙儿收拾收拾 行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。</li>\n</ol>"},{"title":"","date":"2017-12-21T07:40:55.000Z","_content":"\n> 每一个根源的烦恼都在自己这里\n\n生气，是因为不够大度；郁闷，是因为不够豁达；焦虑，是因为不够从容；悲伤，是因为不够坚强；惆怅，是因为不够阳光；嫉妒，是因为不够优秀。每一个根源的烦恼都在自己这里，每一次烦恼的出现，都是一个让我们改正自己缺点的机会。\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/生活小常识/健康类.md","raw":"---\ntitle: \ndate: 2017-12-21 15:40:55\ncategories:\n- 生活小常识\ntags: \n- 健康\n---\n\n> 每一个根源的烦恼都在自己这里\n\n生气，是因为不够大度；郁闷，是因为不够豁达；焦虑，是因为不够从容；悲伤，是因为不够坚强；惆怅，是因为不够阳光；嫉妒，是因为不够优秀。每一个根源的烦恼都在自己这里，每一次烦恼的出现，都是一个让我们改正自己缺点的机会。\n\n\n\n\n\n\n\n\n\n\n","slug":"生活小常识/健康类","published":1,"updated":"2018-04-12T02:24:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3dg000nuox1htuori8l","content":"<blockquote>\n<p>每一个根源的烦恼都在自己这里</p>\n</blockquote>\n<p>生气，是因为不够大度；郁闷，是因为不够豁达；焦虑，是因为不够从容；悲伤，是因为不够坚强；惆怅，是因为不够阳光；嫉妒，是因为不够优秀。每一个根源的烦恼都在自己这里，每一次烦恼的出现，都是一个让我们改正自己缺点的机会。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>每一个根源的烦恼都在自己这里</p>\n</blockquote>\n<p>生气，是因为不够大度；郁闷，是因为不够豁达；焦虑，是因为不够从容；悲伤，是因为不够坚强；惆怅，是因为不够阳光；嫉妒，是因为不够优秀。每一个根源的烦恼都在自己这里，每一次烦恼的出现，都是一个让我们改正自己缺点的机会。</p>\n"},{"title":"单词","date":"2018-05-31T07:03:58.000Z","_content":"\n> word\n<!--more -->\nvomiting  吐         \nnauseous  恶心      \ndizzy   头晕    \nblood pressure   血压    \nstomach flu 肠胃炎    \nappetite   胃口     \nliquids   液体   \nmedicine   药    \nprescription  处方 药方     \nsymptoms  症状 \npharmacy  药房\npharmacist  药剂师\nfill   配药\npick up  领药\ninsurance  保险\nbe allergic to  对什么过敏\ndrowsiness   昏睡\nsprained  right wrist  扭伤右手腕\nbruised three ribs   碰伤了三根肋骨\nbroke his leg  \nfell down the stairs \nslipped and fell down  滑一下 跌倒\n\n","source":"_posts/英语/word.md","raw":"---\ntitle: 单词\ndate: 2018-05-31 15:03:58\ncategories:\n- 英语\ntags: 英语\n---\n\n> word\n<!--more -->\nvomiting  吐         \nnauseous  恶心      \ndizzy   头晕    \nblood pressure   血压    \nstomach flu 肠胃炎    \nappetite   胃口     \nliquids   液体   \nmedicine   药    \nprescription  处方 药方     \nsymptoms  症状 \npharmacy  药房\npharmacist  药剂师\nfill   配药\npick up  领药\ninsurance  保险\nbe allergic to  对什么过敏\ndrowsiness   昏睡\nsprained  right wrist  扭伤右手腕\nbruised three ribs   碰伤了三根肋骨\nbroke his leg  \nfell down the stairs \nslipped and fell down  滑一下 跌倒\n\n","slug":"英语/word","published":1,"updated":"2019-02-26T05:41:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3dh000ouox14to7choo","content":"<blockquote>\n<p>word<br><a id=\"more\"></a><br>vomiting  吐<br>nauseous  恶心<br>dizzy   头晕<br>blood pressure   血压<br>stomach flu 肠胃炎<br>appetite   胃口<br>liquids   液体<br>medicine   药<br>prescription  处方 药方<br>symptoms  症状<br>pharmacy  药房<br>pharmacist  药剂师<br>fill   配药<br>pick up  领药<br>insurance  保险<br>be allergic to  对什么过敏<br>drowsiness   昏睡<br>sprained  right wrist  扭伤右手腕<br>bruised three ribs   碰伤了三根肋骨<br>broke his leg<br>fell down the stairs<br>slipped and fell down  滑一下 跌倒</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>word<br>","more":"<br>vomiting  吐<br>nauseous  恶心<br>dizzy   头晕<br>blood pressure   血压<br>stomach flu 肠胃炎<br>appetite   胃口<br>liquids   液体<br>medicine   药<br>prescription  处方 药方<br>symptoms  症状<br>pharmacy  药房<br>pharmacist  药剂师<br>fill   配药<br>pick up  领药<br>insurance  保险<br>be allergic to  对什么过敏<br>drowsiness   昏睡<br>sprained  right wrist  扭伤右手腕<br>bruised three ribs   碰伤了三根肋骨<br>broke his leg<br>fell down the stairs<br>slipped and fell down  滑一下 跌倒</p>\n</blockquote>"},{"title":"4-unit-1","date":"2017-12-28T03:04:58.000Z","_content":"\n> 4-unit-1，加入英孚，整理每个单元所学的重点词汇，语法，句子，以及各种阅读技巧和英语听力，汇总各个场合的口语。\n\n<!-- more -->\n\n## 1-1（描述休闲娱乐的选择）\n\n### 1. 词汇\n\n\ta dance       一支舞\n\ta concert     一场音乐会\n\ta play        一部戏剧\n\ta musical     一部音乐剧\n\ta lecture     一场演讲\n\ta movie       一部电影\n\ta game        一个游戏\n\n### 2. 语法\n\n***1）、动词不定式***\n\n    plan, want, need + to do something\n\n***2）、动名词***\n\n    enjoy, keep, think about + doing something\n\n***3）、动词不定式or动名词***\n\n    like, love, begin + to do/doing something\n\n### 3. 表达\n\n***1）、短语 know how to 表示你具有做某事的知识或能力。添加 not 表示否定意义。 ***\n\n\tI know how to drive.\t我知道怎么开车。\n\tI don't know how to swim.    \t我不知道怎么游泳。\n\t\n你也可以使用短语 good at 和 bad at 描述能力程度。这些短语常常与 really、very 和 pretty 等副词搭配使用。\n\n\tCarol is really good at chess.\tCarol 非常擅长下棋。\n\tJames is pretty bad at computer games.\tJames 玩电脑游戏很差劲。\n\n你可以使用短语 terrible at 描述非常差的能力。\n\n\tI'm terrible at driving.\t我开车很差劲。\n\n语言点：单词 pretty 有两层意思，它既表示某人外表迷人，做副词使用时，则修饰强调后接的形容词。\n\n***2）、询问和谈谈选择***\n\n使用类似这样的问题向他人询问他们想做的事情和可以从事的活动：\n\n\tWhat do you want to do?\t你想做什么？  \n\tWhat are we going to do tonight?\t我们今天晚上要做什么？\n\tWhat's going on?\t有什么正在进行的活动？\n\n使用短语 there is 和 there are 搭配 and 来列举演出活动。\n\n\tThere's a new movie at the theater and a lecture at the university.\t电影院新上映了一部影片，大学有一场讲座。\n\tThere are some great movies and plays going on this week.\t本周有不少好看的电影和戏剧。\n\n***3）、使用 can 和 could 介绍可能的活动，搭配 or 来提出不同的选择。***\n\n\tWe can go to the lecture or the movie.\t我们可以去听讲座或看电影。\n\tYou could go swimming or you could go hiking.\t你可以去游泳或者去远足。\n\n使用 what else 搭配问题来询问更多选择。\n\n\tWhat else is there to do?\t还可以做什么？\n\tWhat else is going on?\t还有什么活动？\n\n## 1-2（谈论即将发生的活动）\n\n### 1. 词汇\n\n\tbar           酒吧\n\tauditorium    礼堂\n\ttheater       剧院、剧场\n\tconcert hall  音乐厅\n\tcafe          咖啡馆\n\tacquarium     水族馆\n\tnightclub     夜总会\n\tstadium       体育馆\n\trestaurant    饭店\n\n### 2. 语法\n\n<font color=red>时间和地点介词，三个时间和地点介词 in、on 和 at</font>\n\n***1）、大的地区或长的时间，比如国家或年，使用 in。***\n\n\tBeijing is in China.\t北京位于中国。\n\tThey came here in 2005.\t他们 2005 年来到这里。\n\n***2）、像街道等较小的地区以及星期和日期，则使用 on。***\n\n\tI live on Main Street.\t我住在 Main Street 街。\n\tThe lecture is on Monday.\t讲座在星期一。\n\tMy birthday is on April 17th.\t我生日是 4 月 17 日。\n\n***3）、地址、公司和建筑，以及表示确切时间则使用 at。***\n\n\tHis house is at 465 Pine Street.\t他家在 Pine Street 街 465 号。\n\tThe concert is at 5 p.m.\t音乐会下午 5 点开始。\n\tThe lecture is at the auditorium.\t讲座在礼堂举行。\n\n***4）、使用 in 搭配 morning、afternoon 和 evening。使用 at 搭配 night、midnight 和 noon。***\n\n\tIn the morning, I'm very tired.\t早上我很累。\n\tAt night, I like to read.\t晚上我喜欢阅读。\n\n### 3. 表达\n\n<font color=red>请求帮助</font>\n\n用下列带有 Could you 的问句请求帮助。\n\n \tCould you do me a favor? \t您能帮我一个忙吗？\n \tCould you help me?\t您能帮我吗？\n\n你可以使用这些表达对他人的帮助请求表示同意。\n\n \tSure. \t当然。\n \tNo problem.      \t没问题。\n \tOK.     \t好的。\n\n如果你帮不了忙，你可以说 I'm sorry, but 来表示道歉，然后说明原因。\n\n \tI'm sorry, but I'm really busy right now. \t对不起，可我现在真的很忙。\n \tI'm really sorry, but I can't help you.   \t真对不起，可我帮不了你。\n\n### 4. 阅读\n\n<font color=red>阅读演出信息</font>\n \n阅读演出描述时，你可以试着快速浏览信息，寻找关键词。不要在不懂的单词上花费大量时间，关注你知道意思的单词。\n下为关键词的一些分类：\n\n***演出名称：***\n\n\tconcert, picnic, lecture, play, musical\n\n***演出地点：***\n\n\tauditorium, theater, aquarium, concert hall\n\n***时间和日期：***\n\n\ton February 6, in the evening, at 5 o'clock\n\n***地点：***\n\n\tat Martina's restaurant, in Central Park, on 5th Street\n\n## 1-3（计划与朋友晚上外出）\n\n### 1. 词汇\n\n<font color=red>有关演出的形容词</font>\n\n许多可以用来描述演出的形容词都以 -ing 结尾，从动词变化而来。比如，形容词 relaxing 来自动词 relax。\n\n\tinteresting\t有趣的           \n\tboring \t无聊的\n\trelaxing\t轻松的\n\texciting\t令人兴奋的\n\tsurprising     \t令人惊讶的\n\n以下是其他一些描述演出的形容词。\n\n\tfun  \t快乐的，有趣的\n\tincredible\t精彩的，不可信的;不可思议的,惊人的\n\tloud\t喧闹的\n\tquiet\t安静的\n\twonderful\t出色的\n\tterrible\t糟糕的\n\n识记形容词的一个方法是同时学习它们的反义词。\n\n\tinteresting - boring \n\trelaxing - exciting \n\tloud - quiet \n\twonderful - terrible \n\n\thorror    惊骇, 惊恐\n\tromance   富于想像力的故事; 浪漫故事\n\tdrama     戏剧\n\tclassic   经典, 第一流的, 古典的\n\tcomedy    喜剧\n\n### 2. 语法\n\n***Let's + 搭配动词原形***\n\n    Let's go to the dance performance.\t我们去看舞蹈演出吧。\n\nHow about 或 what about + 搭配动名词\n\n    What about meeting some friends?\t去见一些朋友怎么样？\n\n***Could + 搭配动词原形***\n\n    We could go out for a drink at Harry's Bar.\t我们可以去 Harry's Bar 酒吧喝点东西。\n\n***Why don't we + 搭配动词原形***\n\n    Why don't we try a new restaurant?\t我们为什不试试一家新餐馆呢？\n\n### 3. 表达\n\n\tThere's a great comedy on TV.电视上在播一部优秀的喜剧。\n\tNah, I don't think so.不，我不这么想。\n\tWhy not?为什么不呢？\n\tBecause I want to go out tonight.因为今天晚上我想出去。\n\tWe could go out for a drink or see a movie.我们可以出去喝酒或者去看电影。\n\tWhat else is going on?还有其他什么活动吗？\n\tHow about trying that new French restaurant?去新开的那家法国餐厅尝尝怎么样？\n\n## 1-4（看电影）\n\n### 1. 语法\n\n 一般现在时表示的将来时\n谈论将来时，你有时可以使用一般现在时。如果谈及的演出活动隶属某计划表、时间表或演出日程，这种情况最为常见。表示演出开始或结束的动词，比如 begin 和 close，常常以一般现在时来表示将来时。\n表示演出开始的一般现在时\n\n \tbegin\t开始\n \tstart\t开始\n \topen\t开始\n\tThe dance performance begins at 8 o'clock tonight.\t舞蹈演出今晚八点开始。\n\tHarold's Department Store opens at 9 a.m. tomorrow.\tHarold's Department Store 明天早上九点开张。\n\n表示演出结束的一般现在时\n\n \tclose \t结束\n \tend \t结束\n \tbe over \t结束，完了\n \tfinish \t结束\n\tThe movie is over at 9:15 p.m.       \t电影晚上九点一刻结束。\n\tShe closes her shop at 6 o'clock.\t她六点钟关店。\n\n语言点：记住在 he、she 和 it 后面，动词一般现在时后加 s。例如：  \n\n\tThe movie ends at midnight. \t电影午夜结束。\n\n### 2. 表达\n\n\tCan you give me some information?\t你能告诉我一些信息吗？\n\tDo you have a website?\t你们有网站吗？\n\tCan I buy tickets online?\t我可以网上购票吗？\n\tWhat's your address?\t地址在哪里？\n\tWhat time is the next show?\t下一场演出在什么时候？\n\tAre tickets still available?\t还有票吗？\n\tHow much are tickets?\t票多少钱一张？\n\n表达恼怒有许多方法。主要的方法是提高说话音量。这表达出强烈的情感。\n表达恼怒的另一种方法是重复短语表示强调。\n\n\tOK, OK. I'm coming. I'm coming.\t好好，我来了，我来了。                           \n\t通过表示你不相信某人做了某事，也能传达你的恼怒。\n\tI don't believe it! \t我不相信！\n\tI can't believe it!\t我不敢相信！\n\n你也可以通过夸大某人犯错的频率来表达愤怒。使用 always 和 never 来表示夸大。重读这些词来强调频率。\n\n\tJake always forgets.\tJake 老是忘记。\n\tMary never helps me.\tMary 从来不帮我。\n\t你可以使用 stupid 或 crazy 等形容词表达程度更强的恼怒。如果你用这些词形容一个人，表示你不是恼怒，而是生气了。谨慎使用这些词，因为它们可能伤害人的感情。\n\tThis is stupid!\t这很傻。\n\tAre you crazy? 你疯了吗？\n\n\n\n","source":"_posts/英语/4-unit-1.md","raw":"---\ntitle: 4-unit-1\ndate: 2017-12-28 11:04:58\ncategories:\n- 英语\ntags: 英语\n---\n\n> 4-unit-1，加入英孚，整理每个单元所学的重点词汇，语法，句子，以及各种阅读技巧和英语听力，汇总各个场合的口语。\n\n<!-- more -->\n\n## 1-1（描述休闲娱乐的选择）\n\n### 1. 词汇\n\n\ta dance       一支舞\n\ta concert     一场音乐会\n\ta play        一部戏剧\n\ta musical     一部音乐剧\n\ta lecture     一场演讲\n\ta movie       一部电影\n\ta game        一个游戏\n\n### 2. 语法\n\n***1）、动词不定式***\n\n    plan, want, need + to do something\n\n***2）、动名词***\n\n    enjoy, keep, think about + doing something\n\n***3）、动词不定式or动名词***\n\n    like, love, begin + to do/doing something\n\n### 3. 表达\n\n***1）、短语 know how to 表示你具有做某事的知识或能力。添加 not 表示否定意义。 ***\n\n\tI know how to drive.\t我知道怎么开车。\n\tI don't know how to swim.    \t我不知道怎么游泳。\n\t\n你也可以使用短语 good at 和 bad at 描述能力程度。这些短语常常与 really、very 和 pretty 等副词搭配使用。\n\n\tCarol is really good at chess.\tCarol 非常擅长下棋。\n\tJames is pretty bad at computer games.\tJames 玩电脑游戏很差劲。\n\n你可以使用短语 terrible at 描述非常差的能力。\n\n\tI'm terrible at driving.\t我开车很差劲。\n\n语言点：单词 pretty 有两层意思，它既表示某人外表迷人，做副词使用时，则修饰强调后接的形容词。\n\n***2）、询问和谈谈选择***\n\n使用类似这样的问题向他人询问他们想做的事情和可以从事的活动：\n\n\tWhat do you want to do?\t你想做什么？  \n\tWhat are we going to do tonight?\t我们今天晚上要做什么？\n\tWhat's going on?\t有什么正在进行的活动？\n\n使用短语 there is 和 there are 搭配 and 来列举演出活动。\n\n\tThere's a new movie at the theater and a lecture at the university.\t电影院新上映了一部影片，大学有一场讲座。\n\tThere are some great movies and plays going on this week.\t本周有不少好看的电影和戏剧。\n\n***3）、使用 can 和 could 介绍可能的活动，搭配 or 来提出不同的选择。***\n\n\tWe can go to the lecture or the movie.\t我们可以去听讲座或看电影。\n\tYou could go swimming or you could go hiking.\t你可以去游泳或者去远足。\n\n使用 what else 搭配问题来询问更多选择。\n\n\tWhat else is there to do?\t还可以做什么？\n\tWhat else is going on?\t还有什么活动？\n\n## 1-2（谈论即将发生的活动）\n\n### 1. 词汇\n\n\tbar           酒吧\n\tauditorium    礼堂\n\ttheater       剧院、剧场\n\tconcert hall  音乐厅\n\tcafe          咖啡馆\n\tacquarium     水族馆\n\tnightclub     夜总会\n\tstadium       体育馆\n\trestaurant    饭店\n\n### 2. 语法\n\n<font color=red>时间和地点介词，三个时间和地点介词 in、on 和 at</font>\n\n***1）、大的地区或长的时间，比如国家或年，使用 in。***\n\n\tBeijing is in China.\t北京位于中国。\n\tThey came here in 2005.\t他们 2005 年来到这里。\n\n***2）、像街道等较小的地区以及星期和日期，则使用 on。***\n\n\tI live on Main Street.\t我住在 Main Street 街。\n\tThe lecture is on Monday.\t讲座在星期一。\n\tMy birthday is on April 17th.\t我生日是 4 月 17 日。\n\n***3）、地址、公司和建筑，以及表示确切时间则使用 at。***\n\n\tHis house is at 465 Pine Street.\t他家在 Pine Street 街 465 号。\n\tThe concert is at 5 p.m.\t音乐会下午 5 点开始。\n\tThe lecture is at the auditorium.\t讲座在礼堂举行。\n\n***4）、使用 in 搭配 morning、afternoon 和 evening。使用 at 搭配 night、midnight 和 noon。***\n\n\tIn the morning, I'm very tired.\t早上我很累。\n\tAt night, I like to read.\t晚上我喜欢阅读。\n\n### 3. 表达\n\n<font color=red>请求帮助</font>\n\n用下列带有 Could you 的问句请求帮助。\n\n \tCould you do me a favor? \t您能帮我一个忙吗？\n \tCould you help me?\t您能帮我吗？\n\n你可以使用这些表达对他人的帮助请求表示同意。\n\n \tSure. \t当然。\n \tNo problem.      \t没问题。\n \tOK.     \t好的。\n\n如果你帮不了忙，你可以说 I'm sorry, but 来表示道歉，然后说明原因。\n\n \tI'm sorry, but I'm really busy right now. \t对不起，可我现在真的很忙。\n \tI'm really sorry, but I can't help you.   \t真对不起，可我帮不了你。\n\n### 4. 阅读\n\n<font color=red>阅读演出信息</font>\n \n阅读演出描述时，你可以试着快速浏览信息，寻找关键词。不要在不懂的单词上花费大量时间，关注你知道意思的单词。\n下为关键词的一些分类：\n\n***演出名称：***\n\n\tconcert, picnic, lecture, play, musical\n\n***演出地点：***\n\n\tauditorium, theater, aquarium, concert hall\n\n***时间和日期：***\n\n\ton February 6, in the evening, at 5 o'clock\n\n***地点：***\n\n\tat Martina's restaurant, in Central Park, on 5th Street\n\n## 1-3（计划与朋友晚上外出）\n\n### 1. 词汇\n\n<font color=red>有关演出的形容词</font>\n\n许多可以用来描述演出的形容词都以 -ing 结尾，从动词变化而来。比如，形容词 relaxing 来自动词 relax。\n\n\tinteresting\t有趣的           \n\tboring \t无聊的\n\trelaxing\t轻松的\n\texciting\t令人兴奋的\n\tsurprising     \t令人惊讶的\n\n以下是其他一些描述演出的形容词。\n\n\tfun  \t快乐的，有趣的\n\tincredible\t精彩的，不可信的;不可思议的,惊人的\n\tloud\t喧闹的\n\tquiet\t安静的\n\twonderful\t出色的\n\tterrible\t糟糕的\n\n识记形容词的一个方法是同时学习它们的反义词。\n\n\tinteresting - boring \n\trelaxing - exciting \n\tloud - quiet \n\twonderful - terrible \n\n\thorror    惊骇, 惊恐\n\tromance   富于想像力的故事; 浪漫故事\n\tdrama     戏剧\n\tclassic   经典, 第一流的, 古典的\n\tcomedy    喜剧\n\n### 2. 语法\n\n***Let's + 搭配动词原形***\n\n    Let's go to the dance performance.\t我们去看舞蹈演出吧。\n\nHow about 或 what about + 搭配动名词\n\n    What about meeting some friends?\t去见一些朋友怎么样？\n\n***Could + 搭配动词原形***\n\n    We could go out for a drink at Harry's Bar.\t我们可以去 Harry's Bar 酒吧喝点东西。\n\n***Why don't we + 搭配动词原形***\n\n    Why don't we try a new restaurant?\t我们为什不试试一家新餐馆呢？\n\n### 3. 表达\n\n\tThere's a great comedy on TV.电视上在播一部优秀的喜剧。\n\tNah, I don't think so.不，我不这么想。\n\tWhy not?为什么不呢？\n\tBecause I want to go out tonight.因为今天晚上我想出去。\n\tWe could go out for a drink or see a movie.我们可以出去喝酒或者去看电影。\n\tWhat else is going on?还有其他什么活动吗？\n\tHow about trying that new French restaurant?去新开的那家法国餐厅尝尝怎么样？\n\n## 1-4（看电影）\n\n### 1. 语法\n\n 一般现在时表示的将来时\n谈论将来时，你有时可以使用一般现在时。如果谈及的演出活动隶属某计划表、时间表或演出日程，这种情况最为常见。表示演出开始或结束的动词，比如 begin 和 close，常常以一般现在时来表示将来时。\n表示演出开始的一般现在时\n\n \tbegin\t开始\n \tstart\t开始\n \topen\t开始\n\tThe dance performance begins at 8 o'clock tonight.\t舞蹈演出今晚八点开始。\n\tHarold's Department Store opens at 9 a.m. tomorrow.\tHarold's Department Store 明天早上九点开张。\n\n表示演出结束的一般现在时\n\n \tclose \t结束\n \tend \t结束\n \tbe over \t结束，完了\n \tfinish \t结束\n\tThe movie is over at 9:15 p.m.       \t电影晚上九点一刻结束。\n\tShe closes her shop at 6 o'clock.\t她六点钟关店。\n\n语言点：记住在 he、she 和 it 后面，动词一般现在时后加 s。例如：  \n\n\tThe movie ends at midnight. \t电影午夜结束。\n\n### 2. 表达\n\n\tCan you give me some information?\t你能告诉我一些信息吗？\n\tDo you have a website?\t你们有网站吗？\n\tCan I buy tickets online?\t我可以网上购票吗？\n\tWhat's your address?\t地址在哪里？\n\tWhat time is the next show?\t下一场演出在什么时候？\n\tAre tickets still available?\t还有票吗？\n\tHow much are tickets?\t票多少钱一张？\n\n表达恼怒有许多方法。主要的方法是提高说话音量。这表达出强烈的情感。\n表达恼怒的另一种方法是重复短语表示强调。\n\n\tOK, OK. I'm coming. I'm coming.\t好好，我来了，我来了。                           \n\t通过表示你不相信某人做了某事，也能传达你的恼怒。\n\tI don't believe it! \t我不相信！\n\tI can't believe it!\t我不敢相信！\n\n你也可以通过夸大某人犯错的频率来表达愤怒。使用 always 和 never 来表示夸大。重读这些词来强调频率。\n\n\tJake always forgets.\tJake 老是忘记。\n\tMary never helps me.\tMary 从来不帮我。\n\t你可以使用 stupid 或 crazy 等形容词表达程度更强的恼怒。如果你用这些词形容一个人，表示你不是恼怒，而是生气了。谨慎使用这些词，因为它们可能伤害人的感情。\n\tThis is stupid!\t这很傻。\n\tAre you crazy? 你疯了吗？\n\n\n\n","slug":"英语/4-unit-1","published":1,"updated":"2018-05-31T10:27:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3dh000puox1bhzwm456","content":"<blockquote>\n<p>4-unit-1，加入英孚，整理每个单元所学的重点词汇，语法，句子，以及各种阅读技巧和英语听力，汇总各个场合的口语。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"1-1（描述休闲娱乐的选择）\"><a href=\"#1-1（描述休闲娱乐的选择）\" class=\"headerlink\" title=\"1-1（描述休闲娱乐的选择）\"></a>1-1（描述休闲娱乐的选择）</h2><h3 id=\"1-词汇\"><a href=\"#1-词汇\" class=\"headerlink\" title=\"1. 词汇\"></a>1. 词汇</h3><pre><code>a dance       一支舞\na concert     一场音乐会\na play        一部戏剧\na musical     一部音乐剧\na lecture     一场演讲\na movie       一部电影\na game        一个游戏\n</code></pre><h3 id=\"2-语法\"><a href=\"#2-语法\" class=\"headerlink\" title=\"2. 语法\"></a>2. 语法</h3><p><strong><em>1）、动词不定式</em></strong></p>\n<pre><code>plan, want, need + to do something\n</code></pre><p><strong><em>2）、动名词</em></strong></p>\n<pre><code>enjoy, keep, think about + doing something\n</code></pre><p><strong><em>3）、动词不定式or动名词</em></strong></p>\n<pre><code>like, love, begin + to do/doing something\n</code></pre><h3 id=\"3-表达\"><a href=\"#3-表达\" class=\"headerlink\" title=\"3. 表达\"></a>3. 表达</h3><p><strong><em>1）、短语 know how to 表示你具有做某事的知识或能力。添加 not 表示否定意义。 </em></strong></p>\n<pre><code>I know how to drive.    我知道怎么开车。\nI don&apos;t know how to swim.        我不知道怎么游泳。\n</code></pre><p>你也可以使用短语 good at 和 bad at 描述能力程度。这些短语常常与 really、very 和 pretty 等副词搭配使用。</p>\n<pre><code>Carol is really good at chess.    Carol 非常擅长下棋。\nJames is pretty bad at computer games.    James 玩电脑游戏很差劲。\n</code></pre><p>你可以使用短语 terrible at 描述非常差的能力。</p>\n<pre><code>I&apos;m terrible at driving.    我开车很差劲。\n</code></pre><p>语言点：单词 pretty 有两层意思，它既表示某人外表迷人，做副词使用时，则修饰强调后接的形容词。</p>\n<p><strong><em>2）、询问和谈谈选择</em></strong></p>\n<p>使用类似这样的问题向他人询问他们想做的事情和可以从事的活动：</p>\n<pre><code>What do you want to do?    你想做什么？  \nWhat are we going to do tonight?    我们今天晚上要做什么？\nWhat&apos;s going on?    有什么正在进行的活动？\n</code></pre><p>使用短语 there is 和 there are 搭配 and 来列举演出活动。</p>\n<pre><code>There&apos;s a new movie at the theater and a lecture at the university.    电影院新上映了一部影片，大学有一场讲座。\nThere are some great movies and plays going on this week.    本周有不少好看的电影和戏剧。\n</code></pre><p><strong><em>3）、使用 can 和 could 介绍可能的活动，搭配 or 来提出不同的选择。</em></strong></p>\n<pre><code>We can go to the lecture or the movie.    我们可以去听讲座或看电影。\nYou could go swimming or you could go hiking.    你可以去游泳或者去远足。\n</code></pre><p>使用 what else 搭配问题来询问更多选择。</p>\n<pre><code>What else is there to do?    还可以做什么？\nWhat else is going on?    还有什么活动？\n</code></pre><h2 id=\"1-2（谈论即将发生的活动）\"><a href=\"#1-2（谈论即将发生的活动）\" class=\"headerlink\" title=\"1-2（谈论即将发生的活动）\"></a>1-2（谈论即将发生的活动）</h2><h3 id=\"1-词汇-1\"><a href=\"#1-词汇-1\" class=\"headerlink\" title=\"1. 词汇\"></a>1. 词汇</h3><pre><code>bar           酒吧\nauditorium    礼堂\ntheater       剧院、剧场\nconcert hall  音乐厅\ncafe          咖啡馆\nacquarium     水族馆\nnightclub     夜总会\nstadium       体育馆\nrestaurant    饭店\n</code></pre><h3 id=\"2-语法-1\"><a href=\"#2-语法-1\" class=\"headerlink\" title=\"2. 语法\"></a>2. 语法</h3><font color=\"red\">时间和地点介词，三个时间和地点介词 in、on 和 at</font>\n\n<p><strong><em>1）、大的地区或长的时间，比如国家或年，使用 in。</em></strong></p>\n<pre><code>Beijing is in China.    北京位于中国。\nThey came here in 2005.    他们 2005 年来到这里。\n</code></pre><p><strong><em>2）、像街道等较小的地区以及星期和日期，则使用 on。</em></strong></p>\n<pre><code>I live on Main Street.    我住在 Main Street 街。\nThe lecture is on Monday.    讲座在星期一。\nMy birthday is on April 17th.    我生日是 4 月 17 日。\n</code></pre><p><strong><em>3）、地址、公司和建筑，以及表示确切时间则使用 at。</em></strong></p>\n<pre><code>His house is at 465 Pine Street.    他家在 Pine Street 街 465 号。\nThe concert is at 5 p.m.    音乐会下午 5 点开始。\nThe lecture is at the auditorium.    讲座在礼堂举行。\n</code></pre><p><strong><em>4）、使用 in 搭配 morning、afternoon 和 evening。使用 at 搭配 night、midnight 和 noon。</em></strong></p>\n<pre><code>In the morning, I&apos;m very tired.    早上我很累。\nAt night, I like to read.    晚上我喜欢阅读。\n</code></pre><h3 id=\"3-表达-1\"><a href=\"#3-表达-1\" class=\"headerlink\" title=\"3. 表达\"></a>3. 表达</h3><font color=\"red\">请求帮助</font>\n\n<p>用下列带有 Could you 的问句请求帮助。</p>\n<pre><code>Could you do me a favor?     您能帮我一个忙吗？\nCould you help me?    您能帮我吗？\n</code></pre><p>你可以使用这些表达对他人的帮助请求表示同意。</p>\n<pre><code>Sure.     当然。\nNo problem.          没问题。\nOK.         好的。\n</code></pre><p>如果你帮不了忙，你可以说 I’m sorry, but 来表示道歉，然后说明原因。</p>\n<pre><code>I&apos;m sorry, but I&apos;m really busy right now.     对不起，可我现在真的很忙。\nI&apos;m really sorry, but I can&apos;t help you.       真对不起，可我帮不了你。\n</code></pre><h3 id=\"4-阅读\"><a href=\"#4-阅读\" class=\"headerlink\" title=\"4. 阅读\"></a>4. 阅读</h3><font color=\"red\">阅读演出信息</font>\n\n<p>阅读演出描述时，你可以试着快速浏览信息，寻找关键词。不要在不懂的单词上花费大量时间，关注你知道意思的单词。<br>下为关键词的一些分类：</p>\n<p><strong><em>演出名称：</em></strong></p>\n<pre><code>concert, picnic, lecture, play, musical\n</code></pre><p><strong><em>演出地点：</em></strong></p>\n<pre><code>auditorium, theater, aquarium, concert hall\n</code></pre><p><strong><em>时间和日期：</em></strong></p>\n<pre><code>on February 6, in the evening, at 5 o&apos;clock\n</code></pre><p><strong><em>地点：</em></strong></p>\n<pre><code>at Martina&apos;s restaurant, in Central Park, on 5th Street\n</code></pre><h2 id=\"1-3（计划与朋友晚上外出）\"><a href=\"#1-3（计划与朋友晚上外出）\" class=\"headerlink\" title=\"1-3（计划与朋友晚上外出）\"></a>1-3（计划与朋友晚上外出）</h2><h3 id=\"1-词汇-2\"><a href=\"#1-词汇-2\" class=\"headerlink\" title=\"1. 词汇\"></a>1. 词汇</h3><font color=\"red\">有关演出的形容词</font>\n\n<p>许多可以用来描述演出的形容词都以 -ing 结尾，从动词变化而来。比如，形容词 relaxing 来自动词 relax。</p>\n<pre><code>interesting    有趣的           \nboring     无聊的\nrelaxing    轻松的\nexciting    令人兴奋的\nsurprising         令人惊讶的\n</code></pre><p>以下是其他一些描述演出的形容词。</p>\n<pre><code>fun      快乐的，有趣的\nincredible    精彩的，不可信的;不可思议的,惊人的\nloud    喧闹的\nquiet    安静的\nwonderful    出色的\nterrible    糟糕的\n</code></pre><p>识记形容词的一个方法是同时学习它们的反义词。</p>\n<pre><code>interesting - boring \nrelaxing - exciting \nloud - quiet \nwonderful - terrible \n\nhorror    惊骇, 惊恐\nromance   富于想像力的故事; 浪漫故事\ndrama     戏剧\nclassic   经典, 第一流的, 古典的\ncomedy    喜剧\n</code></pre><h3 id=\"2-语法-2\"><a href=\"#2-语法-2\" class=\"headerlink\" title=\"2. 语法\"></a>2. 语法</h3><p><strong><em>Let’s + 搭配动词原形</em></strong></p>\n<pre><code>Let&apos;s go to the dance performance.    我们去看舞蹈演出吧。\n</code></pre><p>How about 或 what about + 搭配动名词</p>\n<pre><code>What about meeting some friends?    去见一些朋友怎么样？\n</code></pre><p><strong><em>Could + 搭配动词原形</em></strong></p>\n<pre><code>We could go out for a drink at Harry&apos;s Bar.    我们可以去 Harry&apos;s Bar 酒吧喝点东西。\n</code></pre><p><strong><em>Why don’t we + 搭配动词原形</em></strong></p>\n<pre><code>Why don&apos;t we try a new restaurant?    我们为什不试试一家新餐馆呢？\n</code></pre><h3 id=\"3-表达-2\"><a href=\"#3-表达-2\" class=\"headerlink\" title=\"3. 表达\"></a>3. 表达</h3><pre><code>There&apos;s a great comedy on TV.电视上在播一部优秀的喜剧。\nNah, I don&apos;t think so.不，我不这么想。\nWhy not?为什么不呢？\nBecause I want to go out tonight.因为今天晚上我想出去。\nWe could go out for a drink or see a movie.我们可以出去喝酒或者去看电影。\nWhat else is going on?还有其他什么活动吗？\nHow about trying that new French restaurant?去新开的那家法国餐厅尝尝怎么样？\n</code></pre><h2 id=\"1-4（看电影）\"><a href=\"#1-4（看电影）\" class=\"headerlink\" title=\"1-4（看电影）\"></a>1-4（看电影）</h2><h3 id=\"1-语法\"><a href=\"#1-语法\" class=\"headerlink\" title=\"1. 语法\"></a>1. 语法</h3><p> 一般现在时表示的将来时<br>谈论将来时，你有时可以使用一般现在时。如果谈及的演出活动隶属某计划表、时间表或演出日程，这种情况最为常见。表示演出开始或结束的动词，比如 begin 和 close，常常以一般现在时来表示将来时。<br>表示演出开始的一般现在时</p>\n<pre><code> begin    开始\n start    开始\n open    开始\nThe dance performance begins at 8 o&apos;clock tonight.    舞蹈演出今晚八点开始。\nHarold&apos;s Department Store opens at 9 a.m. tomorrow.    Harold&apos;s Department Store 明天早上九点开张。\n</code></pre><p>表示演出结束的一般现在时</p>\n<pre><code> close     结束\n end     结束\n be over     结束，完了\n finish     结束\nThe movie is over at 9:15 p.m.           电影晚上九点一刻结束。\nShe closes her shop at 6 o&apos;clock.    她六点钟关店。\n</code></pre><p>语言点：记住在 he、she 和 it 后面，动词一般现在时后加 s。例如：  </p>\n<pre><code>The movie ends at midnight.     电影午夜结束。\n</code></pre><h3 id=\"2-表达\"><a href=\"#2-表达\" class=\"headerlink\" title=\"2. 表达\"></a>2. 表达</h3><pre><code>Can you give me some information?    你能告诉我一些信息吗？\nDo you have a website?    你们有网站吗？\nCan I buy tickets online?    我可以网上购票吗？\nWhat&apos;s your address?    地址在哪里？\nWhat time is the next show?    下一场演出在什么时候？\nAre tickets still available?    还有票吗？\nHow much are tickets?    票多少钱一张？\n</code></pre><p>表达恼怒有许多方法。主要的方法是提高说话音量。这表达出强烈的情感。<br>表达恼怒的另一种方法是重复短语表示强调。</p>\n<pre><code>OK, OK. I&apos;m coming. I&apos;m coming.    好好，我来了，我来了。                           \n通过表示你不相信某人做了某事，也能传达你的恼怒。\nI don&apos;t believe it!     我不相信！\nI can&apos;t believe it!    我不敢相信！\n</code></pre><p>你也可以通过夸大某人犯错的频率来表达愤怒。使用 always 和 never 来表示夸大。重读这些词来强调频率。</p>\n<pre><code>Jake always forgets.    Jake 老是忘记。\nMary never helps me.    Mary 从来不帮我。\n你可以使用 stupid 或 crazy 等形容词表达程度更强的恼怒。如果你用这些词形容一个人，表示你不是恼怒，而是生气了。谨慎使用这些词，因为它们可能伤害人的感情。\nThis is stupid!    这很傻。\nAre you crazy? 你疯了吗？\n</code></pre>","site":{"data":{}},"excerpt":"<blockquote>\n<p>4-unit-1，加入英孚，整理每个单元所学的重点词汇，语法，句子，以及各种阅读技巧和英语听力，汇总各个场合的口语。</p>\n</blockquote>","more":"<h2 id=\"1-1（描述休闲娱乐的选择）\"><a href=\"#1-1（描述休闲娱乐的选择）\" class=\"headerlink\" title=\"1-1（描述休闲娱乐的选择）\"></a>1-1（描述休闲娱乐的选择）</h2><h3 id=\"1-词汇\"><a href=\"#1-词汇\" class=\"headerlink\" title=\"1. 词汇\"></a>1. 词汇</h3><pre><code>a dance       一支舞\na concert     一场音乐会\na play        一部戏剧\na musical     一部音乐剧\na lecture     一场演讲\na movie       一部电影\na game        一个游戏\n</code></pre><h3 id=\"2-语法\"><a href=\"#2-语法\" class=\"headerlink\" title=\"2. 语法\"></a>2. 语法</h3><p><strong><em>1）、动词不定式</em></strong></p>\n<pre><code>plan, want, need + to do something\n</code></pre><p><strong><em>2）、动名词</em></strong></p>\n<pre><code>enjoy, keep, think about + doing something\n</code></pre><p><strong><em>3）、动词不定式or动名词</em></strong></p>\n<pre><code>like, love, begin + to do/doing something\n</code></pre><h3 id=\"3-表达\"><a href=\"#3-表达\" class=\"headerlink\" title=\"3. 表达\"></a>3. 表达</h3><p><strong><em>1）、短语 know how to 表示你具有做某事的知识或能力。添加 not 表示否定意义。 </em></strong></p>\n<pre><code>I know how to drive.    我知道怎么开车。\nI don&apos;t know how to swim.        我不知道怎么游泳。\n</code></pre><p>你也可以使用短语 good at 和 bad at 描述能力程度。这些短语常常与 really、very 和 pretty 等副词搭配使用。</p>\n<pre><code>Carol is really good at chess.    Carol 非常擅长下棋。\nJames is pretty bad at computer games.    James 玩电脑游戏很差劲。\n</code></pre><p>你可以使用短语 terrible at 描述非常差的能力。</p>\n<pre><code>I&apos;m terrible at driving.    我开车很差劲。\n</code></pre><p>语言点：单词 pretty 有两层意思，它既表示某人外表迷人，做副词使用时，则修饰强调后接的形容词。</p>\n<p><strong><em>2）、询问和谈谈选择</em></strong></p>\n<p>使用类似这样的问题向他人询问他们想做的事情和可以从事的活动：</p>\n<pre><code>What do you want to do?    你想做什么？  \nWhat are we going to do tonight?    我们今天晚上要做什么？\nWhat&apos;s going on?    有什么正在进行的活动？\n</code></pre><p>使用短语 there is 和 there are 搭配 and 来列举演出活动。</p>\n<pre><code>There&apos;s a new movie at the theater and a lecture at the university.    电影院新上映了一部影片，大学有一场讲座。\nThere are some great movies and plays going on this week.    本周有不少好看的电影和戏剧。\n</code></pre><p><strong><em>3）、使用 can 和 could 介绍可能的活动，搭配 or 来提出不同的选择。</em></strong></p>\n<pre><code>We can go to the lecture or the movie.    我们可以去听讲座或看电影。\nYou could go swimming or you could go hiking.    你可以去游泳或者去远足。\n</code></pre><p>使用 what else 搭配问题来询问更多选择。</p>\n<pre><code>What else is there to do?    还可以做什么？\nWhat else is going on?    还有什么活动？\n</code></pre><h2 id=\"1-2（谈论即将发生的活动）\"><a href=\"#1-2（谈论即将发生的活动）\" class=\"headerlink\" title=\"1-2（谈论即将发生的活动）\"></a>1-2（谈论即将发生的活动）</h2><h3 id=\"1-词汇-1\"><a href=\"#1-词汇-1\" class=\"headerlink\" title=\"1. 词汇\"></a>1. 词汇</h3><pre><code>bar           酒吧\nauditorium    礼堂\ntheater       剧院、剧场\nconcert hall  音乐厅\ncafe          咖啡馆\nacquarium     水族馆\nnightclub     夜总会\nstadium       体育馆\nrestaurant    饭店\n</code></pre><h3 id=\"2-语法-1\"><a href=\"#2-语法-1\" class=\"headerlink\" title=\"2. 语法\"></a>2. 语法</h3><font color=\"red\">时间和地点介词，三个时间和地点介词 in、on 和 at</font>\n\n<p><strong><em>1）、大的地区或长的时间，比如国家或年，使用 in。</em></strong></p>\n<pre><code>Beijing is in China.    北京位于中国。\nThey came here in 2005.    他们 2005 年来到这里。\n</code></pre><p><strong><em>2）、像街道等较小的地区以及星期和日期，则使用 on。</em></strong></p>\n<pre><code>I live on Main Street.    我住在 Main Street 街。\nThe lecture is on Monday.    讲座在星期一。\nMy birthday is on April 17th.    我生日是 4 月 17 日。\n</code></pre><p><strong><em>3）、地址、公司和建筑，以及表示确切时间则使用 at。</em></strong></p>\n<pre><code>His house is at 465 Pine Street.    他家在 Pine Street 街 465 号。\nThe concert is at 5 p.m.    音乐会下午 5 点开始。\nThe lecture is at the auditorium.    讲座在礼堂举行。\n</code></pre><p><strong><em>4）、使用 in 搭配 morning、afternoon 和 evening。使用 at 搭配 night、midnight 和 noon。</em></strong></p>\n<pre><code>In the morning, I&apos;m very tired.    早上我很累。\nAt night, I like to read.    晚上我喜欢阅读。\n</code></pre><h3 id=\"3-表达-1\"><a href=\"#3-表达-1\" class=\"headerlink\" title=\"3. 表达\"></a>3. 表达</h3><font color=\"red\">请求帮助</font>\n\n<p>用下列带有 Could you 的问句请求帮助。</p>\n<pre><code>Could you do me a favor?     您能帮我一个忙吗？\nCould you help me?    您能帮我吗？\n</code></pre><p>你可以使用这些表达对他人的帮助请求表示同意。</p>\n<pre><code>Sure.     当然。\nNo problem.          没问题。\nOK.         好的。\n</code></pre><p>如果你帮不了忙，你可以说 I’m sorry, but 来表示道歉，然后说明原因。</p>\n<pre><code>I&apos;m sorry, but I&apos;m really busy right now.     对不起，可我现在真的很忙。\nI&apos;m really sorry, but I can&apos;t help you.       真对不起，可我帮不了你。\n</code></pre><h3 id=\"4-阅读\"><a href=\"#4-阅读\" class=\"headerlink\" title=\"4. 阅读\"></a>4. 阅读</h3><font color=\"red\">阅读演出信息</font>\n\n<p>阅读演出描述时，你可以试着快速浏览信息，寻找关键词。不要在不懂的单词上花费大量时间，关注你知道意思的单词。<br>下为关键词的一些分类：</p>\n<p><strong><em>演出名称：</em></strong></p>\n<pre><code>concert, picnic, lecture, play, musical\n</code></pre><p><strong><em>演出地点：</em></strong></p>\n<pre><code>auditorium, theater, aquarium, concert hall\n</code></pre><p><strong><em>时间和日期：</em></strong></p>\n<pre><code>on February 6, in the evening, at 5 o&apos;clock\n</code></pre><p><strong><em>地点：</em></strong></p>\n<pre><code>at Martina&apos;s restaurant, in Central Park, on 5th Street\n</code></pre><h2 id=\"1-3（计划与朋友晚上外出）\"><a href=\"#1-3（计划与朋友晚上外出）\" class=\"headerlink\" title=\"1-3（计划与朋友晚上外出）\"></a>1-3（计划与朋友晚上外出）</h2><h3 id=\"1-词汇-2\"><a href=\"#1-词汇-2\" class=\"headerlink\" title=\"1. 词汇\"></a>1. 词汇</h3><font color=\"red\">有关演出的形容词</font>\n\n<p>许多可以用来描述演出的形容词都以 -ing 结尾，从动词变化而来。比如，形容词 relaxing 来自动词 relax。</p>\n<pre><code>interesting    有趣的           \nboring     无聊的\nrelaxing    轻松的\nexciting    令人兴奋的\nsurprising         令人惊讶的\n</code></pre><p>以下是其他一些描述演出的形容词。</p>\n<pre><code>fun      快乐的，有趣的\nincredible    精彩的，不可信的;不可思议的,惊人的\nloud    喧闹的\nquiet    安静的\nwonderful    出色的\nterrible    糟糕的\n</code></pre><p>识记形容词的一个方法是同时学习它们的反义词。</p>\n<pre><code>interesting - boring \nrelaxing - exciting \nloud - quiet \nwonderful - terrible \n\nhorror    惊骇, 惊恐\nromance   富于想像力的故事; 浪漫故事\ndrama     戏剧\nclassic   经典, 第一流的, 古典的\ncomedy    喜剧\n</code></pre><h3 id=\"2-语法-2\"><a href=\"#2-语法-2\" class=\"headerlink\" title=\"2. 语法\"></a>2. 语法</h3><p><strong><em>Let’s + 搭配动词原形</em></strong></p>\n<pre><code>Let&apos;s go to the dance performance.    我们去看舞蹈演出吧。\n</code></pre><p>How about 或 what about + 搭配动名词</p>\n<pre><code>What about meeting some friends?    去见一些朋友怎么样？\n</code></pre><p><strong><em>Could + 搭配动词原形</em></strong></p>\n<pre><code>We could go out for a drink at Harry&apos;s Bar.    我们可以去 Harry&apos;s Bar 酒吧喝点东西。\n</code></pre><p><strong><em>Why don’t we + 搭配动词原形</em></strong></p>\n<pre><code>Why don&apos;t we try a new restaurant?    我们为什不试试一家新餐馆呢？\n</code></pre><h3 id=\"3-表达-2\"><a href=\"#3-表达-2\" class=\"headerlink\" title=\"3. 表达\"></a>3. 表达</h3><pre><code>There&apos;s a great comedy on TV.电视上在播一部优秀的喜剧。\nNah, I don&apos;t think so.不，我不这么想。\nWhy not?为什么不呢？\nBecause I want to go out tonight.因为今天晚上我想出去。\nWe could go out for a drink or see a movie.我们可以出去喝酒或者去看电影。\nWhat else is going on?还有其他什么活动吗？\nHow about trying that new French restaurant?去新开的那家法国餐厅尝尝怎么样？\n</code></pre><h2 id=\"1-4（看电影）\"><a href=\"#1-4（看电影）\" class=\"headerlink\" title=\"1-4（看电影）\"></a>1-4（看电影）</h2><h3 id=\"1-语法\"><a href=\"#1-语法\" class=\"headerlink\" title=\"1. 语法\"></a>1. 语法</h3><p> 一般现在时表示的将来时<br>谈论将来时，你有时可以使用一般现在时。如果谈及的演出活动隶属某计划表、时间表或演出日程，这种情况最为常见。表示演出开始或结束的动词，比如 begin 和 close，常常以一般现在时来表示将来时。<br>表示演出开始的一般现在时</p>\n<pre><code> begin    开始\n start    开始\n open    开始\nThe dance performance begins at 8 o&apos;clock tonight.    舞蹈演出今晚八点开始。\nHarold&apos;s Department Store opens at 9 a.m. tomorrow.    Harold&apos;s Department Store 明天早上九点开张。\n</code></pre><p>表示演出结束的一般现在时</p>\n<pre><code> close     结束\n end     结束\n be over     结束，完了\n finish     结束\nThe movie is over at 9:15 p.m.           电影晚上九点一刻结束。\nShe closes her shop at 6 o&apos;clock.    她六点钟关店。\n</code></pre><p>语言点：记住在 he、she 和 it 后面，动词一般现在时后加 s。例如：  </p>\n<pre><code>The movie ends at midnight.     电影午夜结束。\n</code></pre><h3 id=\"2-表达\"><a href=\"#2-表达\" class=\"headerlink\" title=\"2. 表达\"></a>2. 表达</h3><pre><code>Can you give me some information?    你能告诉我一些信息吗？\nDo you have a website?    你们有网站吗？\nCan I buy tickets online?    我可以网上购票吗？\nWhat&apos;s your address?    地址在哪里？\nWhat time is the next show?    下一场演出在什么时候？\nAre tickets still available?    还有票吗？\nHow much are tickets?    票多少钱一张？\n</code></pre><p>表达恼怒有许多方法。主要的方法是提高说话音量。这表达出强烈的情感。<br>表达恼怒的另一种方法是重复短语表示强调。</p>\n<pre><code>OK, OK. I&apos;m coming. I&apos;m coming.    好好，我来了，我来了。                           \n通过表示你不相信某人做了某事，也能传达你的恼怒。\nI don&apos;t believe it!     我不相信！\nI can&apos;t believe it!    我不敢相信！\n</code></pre><p>你也可以通过夸大某人犯错的频率来表达愤怒。使用 always 和 never 来表示夸大。重读这些词来强调频率。</p>\n<pre><code>Jake always forgets.    Jake 老是忘记。\nMary never helps me.    Mary 从来不帮我。\n你可以使用 stupid 或 crazy 等形容词表达程度更强的恼怒。如果你用这些词形容一个人，表示你不是恼怒，而是生气了。谨慎使用这些词，因为它们可能伤害人的感情。\nThis is stupid!    这很傻。\nAre you crazy? 你疯了吗？\n</code></pre>"},{"title":"4-unit-2","date":"2018-01-04T11:06:58.000Z","_content":"\n> 4-unit-2，加入英孚，整理每个单元所学的重点词汇，语法，句子，以及各种阅读技巧和英语听力，汇总各个场合的口语。\n\n<!-- more -->\n\n## 2-1（描述他人）\n\n### 1. 词汇\n\n    tall\t高\n    medium height\t中等高度\n    short\t矮\n    overweight\t超重\n    fat\t肥胖\n    thin\t瘦\n    She is tall and thin.\t她又高又瘦。\n    He has a nice smile.\t他拥有迷人的笑容。\n    long \t长发\n    medium length\t中长发\n    short\t短发\n    curly\t卷发\n    straight\t直发\n    blond\t金发\n    bald\t秃顶\n    She has long, straight, brown hair.\t她拥有一头棕色的长长的直发。\n    My father is bald.\t\n    old\t老年\n    middle-aged\t中年\n    young\t年轻\n\n### 2. 语法\n\n当您使用一个以上的形容词进行描述时，一般的规则是把它们按大小，年龄，然后颜色的顺序排列。\n\n    He has big, brown eyes.\t\n    他长着一双大大的棕色眼睛。\n    Her hair is shorter and grayer than before.\t\n    她的头发比以前更短了，也变得更灰白了。\n    That tall, young, blond man drives a truck.\t\n    那个高个儿的，金发碧眼的年轻男子开一辆卡车。形容词的排序\n\n### 3. 表达\n\nWhat is (person) like? 或者 What does (person) look like?是用来询问一个人的身材，形体，年龄或者整体的外貌。 使用动词 be 来描述整体的外貌。\n\n    A: What does he look like?\t他长什么样？\n    B: He is tall and middle-aged. He's very good-looking.\t他高个子，中年人，样子很好看。\n\n您也可以使用像What's his hair like? 或 What color are his eyes? 这样的疑问句去询问一个人的身体特定部位的描述。 使用动词have 来指身体的部位。\n\n    A: What color are his eyes?\t他的眼睛是什么颜色的？\n    B: They're brown.\t它们是棕色的。\n    A: How tall is she?\t她有多高？\n    B: She's very tall.\t她很高。\n    A: What do the children look like?\t这些小孩看起来像什么？\n    B: They have curly, red hair. Jasmine has big, brown eyes, and Jason has blue eyes.\t他们的头发又红又卷，杰斯敏的眼睛大大的，是棕色的，而贾森的眼睛是蓝色的。\n\n## 2-2（描述关系）\n\n### 1. 词汇\n\n    wife\t妻子\n    husband\t丈夫\n    granddaughter\t孙女\n    grandson\t孙子\n    aunt\t阿姨\n    uncle\t叔叔\n    niece\t侄女\n    nephew\t侄子\n    cousin\t堂表兄弟姐妹\n\n### 2. 语法\n\n使用类似以下的表达来描述一段关系中正在发生的事情。注意，所有表达都后接动名词 (verb + -ing)。\n表达式可以是肯定的：\n\n    We spend time watching movies. \t我们看电影打发时间。\n    I always have fun talking with him.\t和他谈天我总是感到很开心。\n\n表达式可以是否定的：\n\n    We have a hard time getting together.\t我们好不容易在一起。\n    She has trouble making money.\t赚钱对她来说是件困难的事。\n    They often waste time fighting.\t(他们常常浪费时间吵架。)\n\n### 3. 表达\n\n请使用类似以下的问题来询问别人一段关系。注意答复中表达式 +动名词的结构。\n\n    A: How are you and your brother doing?\n    B: We're doing well, thanks. We spend time talking on the phone.\t你和你哥哥（弟弟）关系还好吗？\n    我们关系很好，谢谢。我们会花时间打电话聊天。\n    A: What do you and Sylvia do for fun?\n    B: Let's see … We have a lot of fun playing tennis together.\t你和 Sylvia 都玩什么？\n    让我想想……我们一起打网球，玩得很开心。\n    您可以使用you two 表达密切的关系 - 例如，丈夫与妻子之间或母亲与孩子之前。\n    A: Are you two having trouble?\n    B: Yeah, we are. I am having trouble understanding her problems.\n    A: I'm sorry to hear that.\t你们两人碰到什么难题了吗？\n    是的，我们碰到了难题。我难以理解她的问题。\n    听到这我很难过。\n \n## 2-3（评估员工）\n\n### 1. 词汇\n\n    performance appraisals 绩效评估\n    hardworking 勤奋的\n    does a really good job 做得出色\n    worked really well with the team 与团队合作融洽\n    team player 有团队精神的人\n    not efficient enough 不够高效的\n    organized 有条理的\n    lazy 懒惰的\n    good in meetings 在会议中表现出色\n    helpful 有帮助的\n    efficient\t有效率的\n    creative\t富有创造性的\n    positive\t积极的\n    does a good job \t做得不错\n    works well with the team / team player\t与团队/ 队员合作愉快\n    getting better\t逐渐在改善\n    good in meetings\t善于开会\n\n    could do better \t可以做得更好\n    late \t迟到\n    negative\t消极的\n    disorganized\t混乱的\n    lazy\t懒惰\n\n一种更积极的方式来应对员工的弱点即是给出建设性的批评，而不是简单地给出消极的评论。\n\n    She's so disorganized. > She needs to be more organized.\t她很混乱。 > 她应该要更有条理些。\n    He's too negative. > He should be more positive.\t他太消极了。 > 他应该积极些。\n\n### 2. 语法\n\n<font color=red>'Too' 和 'enough'</font>\n\n请用 too + 形容词来描述某样东西超过必要，或超过所需时。\n\n    Her project is late because she's too disorganized.\t她的项目已经晚了，因为她太没有条理了。\n    She's too negative. She thinks too much about problems.\t她太消极了。 她想问题考虑得太多了。\n\n请用形容词 + enough 来描述当某件东西足够的，或让人满意的时候。\n\n    Carson is hardworking and efficient enough to be the new manager.\tCarson够勤劳且够有效率，够格成为新经理。\n    请用not + 形容词 + enough 来描述某件东西缺乏或不尽人意时。\n    Sally's not efficient enough. \tSally的效率还不够高。\n    He's not creative enough to work in marketing.   \t他没有足够的创造力做市场营销工作。\n\n### 3.表达\n\n发表意见的时候用 'I think that'\n\n使用 I think that 来表示您在发表一个意见。 使用 so do I 来表示同意一个 I think that 和 I like 这样的短语所表达的意见. \n\n    A: I think that he does a really good job. 我觉得他干的不错。 \n    B: So do I.      我也觉得。\t\n\n    A: I like them both.  我喜欢他俩。\n    B: So do I.        \t  我也觉得。\n\n    使用neither do I 来赞成 I don't think that  这样句式所表达的意见, 或其他否定意见。\n    A: I don't think she's lazy.  我并不觉得她懒。\n    B: Neither do I. \t我也不觉得。\n    请注意 that 可以省掉且句子的含义没有受到影响。\n    \n    要征求别人的意见，您可以使用what do you think about 以及 do you think。\n    A: What do you think about Denise?  您觉得Denise怎么样? 她很有效率。\n    B: She's very efficient.     \t她非常有效率。\n    A: Do you think Paul is too disorganized?  您觉不觉得Paul这个人太混乱了?\n    B: No, not really.  不，不是的。\t\n\n    语言注释：neither有两种发音方法。在下面的例子中，第一个在美国比较普遍的；第二种多见于英国。但它们可以互换使用。\n\n    A: I don't think he's disorganized. 我并不觉得他这个人没有调理。\n    B: Neither do I. \t我也不觉得。\n\n    A: I don't think she's very efficient. 我并不觉得她很有效率。\n    B: Neither do I. \t我也不觉得。\n\n## 2-3（给出推荐）\n\n### 1. 词汇\n\n    learn it pretty quickly  学得很快\n\n副词解释how, when or where。它们可以修饰一个动词，形容词或另一个副词。许多副词以-ly 结尾的是最容易识别的和形成的。但是，许多副词是不以-ly 结尾的,识别它们的最好的方式是将它们连接到它们所修饰的动词，形容词或副词。\n\n使用状态副词加动词来表示完成某件事情的方式。\n\n    Martina works quickly. \tMartina工作效率高。\n    She works well with the team.\t她与团队合作得很愉快。\n    I highly recommend Martina.\t我强烈推荐Martina。\n    I'm going to miss her terribly. \t我将会非常想念她。\n\n使用时间副词加动词来表示时间。\n\n    Her husband is already in New York.  \t她的丈夫已经在纽约了。\n    She's leaving that soon?\t她这么快就走了?\n    \n使用频率副词加动词来表示一个动作的频率。\n\n    She was always organized.     \t她一向都很有条理的。\n\n使用可能性副词加动词来表示一个行动的可能性。\n\n    She can probably learn that in one or two days.   \t她可能会在一或两天内知道。\n    您可以使用 only 加动词来把注意力集中到信息上。\n    The project only took her one day.    \t她可以仅用一天时间完成此项目。\n\n您可以使用副词来修饰形容词。\n\n    The brochure was really beautiful.    \t这本小册子真的很漂亮。\n    She's so creative.     \t她真有创意。\n\n有些副词修饰其他副词. 请注意 pretty 和 so 是如何给这些句子添加额外的细节的。\n\n    She can learn that pretty quickly.\t她能领悟得相当快。\n    He writes so well.     \n    他写得真好。\n    您可以使用副词honestly 在一个句子前边来强调强调某个要点。\n    Honestly, what are we going to do?    \t说实话, 我们去干嘛?\n\n### 2. 语法\n\n<font color=red>'So' 和 'such'</font>\n\n请用so + 形容词 或 so + 副词来强调个人品质。\n\n    Kyle is so disorganized.  \tKyle 非常没有条理。\n    She works so quickly.   \t她做事很快。\n\n请用such + 名词来强调个人品质.\n\n    Debra is such a team player. \tDebra 是非常具有团队精神的人。\n    She shows such creativity.      她表现出极大的创造力。\n    Oscar is such a hard worker.    Oscar 是工作非常努力的人。\n\n### 3. 表达\n\n作为工作面试流程的一部分，公司可能会电话联系推荐人并索要推荐。\n\n    We're interviewing Joe Wilson for a job at our company.  我们正在为我们公司的一个职位面试乔威尔逊。\n    Joe gave us your name as a reference.   乔把您的名字给我们做为他的推荐人。\n \n在这些例子中，注意问题是如何用具体信息回答的。\n \n    A. Did you work together?  你们一共工作过吗？\n    B. Yes. We worked together for two years at Sunset Computers.  是的。我们在Sunset Computers 公司一起工作过两年。\n    A. Do you recommend him?  您推荐他吗？\n    B. Yes. I highly recommend him. He's very intelligent. 是的。我强烈推荐他。他非常聪明。\n    A. What else can you tell me about him?  关于他还有些别的什么您能告诉我的吗？\n    B. Well, he was very organized. He worked well on a team.  嗯，他很有条理。他和团队工作和谐。\n","source":"_posts/英语/4-unit-2.md","raw":"---\ntitle: 4-unit-2\ndate: 2018-01-04 19:06:58\ncategories:\n- 英语\ntags: 英语\n---\n\n> 4-unit-2，加入英孚，整理每个单元所学的重点词汇，语法，句子，以及各种阅读技巧和英语听力，汇总各个场合的口语。\n\n<!-- more -->\n\n## 2-1（描述他人）\n\n### 1. 词汇\n\n    tall\t高\n    medium height\t中等高度\n    short\t矮\n    overweight\t超重\n    fat\t肥胖\n    thin\t瘦\n    She is tall and thin.\t她又高又瘦。\n    He has a nice smile.\t他拥有迷人的笑容。\n    long \t长发\n    medium length\t中长发\n    short\t短发\n    curly\t卷发\n    straight\t直发\n    blond\t金发\n    bald\t秃顶\n    She has long, straight, brown hair.\t她拥有一头棕色的长长的直发。\n    My father is bald.\t\n    old\t老年\n    middle-aged\t中年\n    young\t年轻\n\n### 2. 语法\n\n当您使用一个以上的形容词进行描述时，一般的规则是把它们按大小，年龄，然后颜色的顺序排列。\n\n    He has big, brown eyes.\t\n    他长着一双大大的棕色眼睛。\n    Her hair is shorter and grayer than before.\t\n    她的头发比以前更短了，也变得更灰白了。\n    That tall, young, blond man drives a truck.\t\n    那个高个儿的，金发碧眼的年轻男子开一辆卡车。形容词的排序\n\n### 3. 表达\n\nWhat is (person) like? 或者 What does (person) look like?是用来询问一个人的身材，形体，年龄或者整体的外貌。 使用动词 be 来描述整体的外貌。\n\n    A: What does he look like?\t他长什么样？\n    B: He is tall and middle-aged. He's very good-looking.\t他高个子，中年人，样子很好看。\n\n您也可以使用像What's his hair like? 或 What color are his eyes? 这样的疑问句去询问一个人的身体特定部位的描述。 使用动词have 来指身体的部位。\n\n    A: What color are his eyes?\t他的眼睛是什么颜色的？\n    B: They're brown.\t它们是棕色的。\n    A: How tall is she?\t她有多高？\n    B: She's very tall.\t她很高。\n    A: What do the children look like?\t这些小孩看起来像什么？\n    B: They have curly, red hair. Jasmine has big, brown eyes, and Jason has blue eyes.\t他们的头发又红又卷，杰斯敏的眼睛大大的，是棕色的，而贾森的眼睛是蓝色的。\n\n## 2-2（描述关系）\n\n### 1. 词汇\n\n    wife\t妻子\n    husband\t丈夫\n    granddaughter\t孙女\n    grandson\t孙子\n    aunt\t阿姨\n    uncle\t叔叔\n    niece\t侄女\n    nephew\t侄子\n    cousin\t堂表兄弟姐妹\n\n### 2. 语法\n\n使用类似以下的表达来描述一段关系中正在发生的事情。注意，所有表达都后接动名词 (verb + -ing)。\n表达式可以是肯定的：\n\n    We spend time watching movies. \t我们看电影打发时间。\n    I always have fun talking with him.\t和他谈天我总是感到很开心。\n\n表达式可以是否定的：\n\n    We have a hard time getting together.\t我们好不容易在一起。\n    She has trouble making money.\t赚钱对她来说是件困难的事。\n    They often waste time fighting.\t(他们常常浪费时间吵架。)\n\n### 3. 表达\n\n请使用类似以下的问题来询问别人一段关系。注意答复中表达式 +动名词的结构。\n\n    A: How are you and your brother doing?\n    B: We're doing well, thanks. We spend time talking on the phone.\t你和你哥哥（弟弟）关系还好吗？\n    我们关系很好，谢谢。我们会花时间打电话聊天。\n    A: What do you and Sylvia do for fun?\n    B: Let's see … We have a lot of fun playing tennis together.\t你和 Sylvia 都玩什么？\n    让我想想……我们一起打网球，玩得很开心。\n    您可以使用you two 表达密切的关系 - 例如，丈夫与妻子之间或母亲与孩子之前。\n    A: Are you two having trouble?\n    B: Yeah, we are. I am having trouble understanding her problems.\n    A: I'm sorry to hear that.\t你们两人碰到什么难题了吗？\n    是的，我们碰到了难题。我难以理解她的问题。\n    听到这我很难过。\n \n## 2-3（评估员工）\n\n### 1. 词汇\n\n    performance appraisals 绩效评估\n    hardworking 勤奋的\n    does a really good job 做得出色\n    worked really well with the team 与团队合作融洽\n    team player 有团队精神的人\n    not efficient enough 不够高效的\n    organized 有条理的\n    lazy 懒惰的\n    good in meetings 在会议中表现出色\n    helpful 有帮助的\n    efficient\t有效率的\n    creative\t富有创造性的\n    positive\t积极的\n    does a good job \t做得不错\n    works well with the team / team player\t与团队/ 队员合作愉快\n    getting better\t逐渐在改善\n    good in meetings\t善于开会\n\n    could do better \t可以做得更好\n    late \t迟到\n    negative\t消极的\n    disorganized\t混乱的\n    lazy\t懒惰\n\n一种更积极的方式来应对员工的弱点即是给出建设性的批评，而不是简单地给出消极的评论。\n\n    She's so disorganized. > She needs to be more organized.\t她很混乱。 > 她应该要更有条理些。\n    He's too negative. > He should be more positive.\t他太消极了。 > 他应该积极些。\n\n### 2. 语法\n\n<font color=red>'Too' 和 'enough'</font>\n\n请用 too + 形容词来描述某样东西超过必要，或超过所需时。\n\n    Her project is late because she's too disorganized.\t她的项目已经晚了，因为她太没有条理了。\n    She's too negative. She thinks too much about problems.\t她太消极了。 她想问题考虑得太多了。\n\n请用形容词 + enough 来描述当某件东西足够的，或让人满意的时候。\n\n    Carson is hardworking and efficient enough to be the new manager.\tCarson够勤劳且够有效率，够格成为新经理。\n    请用not + 形容词 + enough 来描述某件东西缺乏或不尽人意时。\n    Sally's not efficient enough. \tSally的效率还不够高。\n    He's not creative enough to work in marketing.   \t他没有足够的创造力做市场营销工作。\n\n### 3.表达\n\n发表意见的时候用 'I think that'\n\n使用 I think that 来表示您在发表一个意见。 使用 so do I 来表示同意一个 I think that 和 I like 这样的短语所表达的意见. \n\n    A: I think that he does a really good job. 我觉得他干的不错。 \n    B: So do I.      我也觉得。\t\n\n    A: I like them both.  我喜欢他俩。\n    B: So do I.        \t  我也觉得。\n\n    使用neither do I 来赞成 I don't think that  这样句式所表达的意见, 或其他否定意见。\n    A: I don't think she's lazy.  我并不觉得她懒。\n    B: Neither do I. \t我也不觉得。\n    请注意 that 可以省掉且句子的含义没有受到影响。\n    \n    要征求别人的意见，您可以使用what do you think about 以及 do you think。\n    A: What do you think about Denise?  您觉得Denise怎么样? 她很有效率。\n    B: She's very efficient.     \t她非常有效率。\n    A: Do you think Paul is too disorganized?  您觉不觉得Paul这个人太混乱了?\n    B: No, not really.  不，不是的。\t\n\n    语言注释：neither有两种发音方法。在下面的例子中，第一个在美国比较普遍的；第二种多见于英国。但它们可以互换使用。\n\n    A: I don't think he's disorganized. 我并不觉得他这个人没有调理。\n    B: Neither do I. \t我也不觉得。\n\n    A: I don't think she's very efficient. 我并不觉得她很有效率。\n    B: Neither do I. \t我也不觉得。\n\n## 2-3（给出推荐）\n\n### 1. 词汇\n\n    learn it pretty quickly  学得很快\n\n副词解释how, when or where。它们可以修饰一个动词，形容词或另一个副词。许多副词以-ly 结尾的是最容易识别的和形成的。但是，许多副词是不以-ly 结尾的,识别它们的最好的方式是将它们连接到它们所修饰的动词，形容词或副词。\n\n使用状态副词加动词来表示完成某件事情的方式。\n\n    Martina works quickly. \tMartina工作效率高。\n    She works well with the team.\t她与团队合作得很愉快。\n    I highly recommend Martina.\t我强烈推荐Martina。\n    I'm going to miss her terribly. \t我将会非常想念她。\n\n使用时间副词加动词来表示时间。\n\n    Her husband is already in New York.  \t她的丈夫已经在纽约了。\n    She's leaving that soon?\t她这么快就走了?\n    \n使用频率副词加动词来表示一个动作的频率。\n\n    She was always organized.     \t她一向都很有条理的。\n\n使用可能性副词加动词来表示一个行动的可能性。\n\n    She can probably learn that in one or two days.   \t她可能会在一或两天内知道。\n    您可以使用 only 加动词来把注意力集中到信息上。\n    The project only took her one day.    \t她可以仅用一天时间完成此项目。\n\n您可以使用副词来修饰形容词。\n\n    The brochure was really beautiful.    \t这本小册子真的很漂亮。\n    She's so creative.     \t她真有创意。\n\n有些副词修饰其他副词. 请注意 pretty 和 so 是如何给这些句子添加额外的细节的。\n\n    She can learn that pretty quickly.\t她能领悟得相当快。\n    He writes so well.     \n    他写得真好。\n    您可以使用副词honestly 在一个句子前边来强调强调某个要点。\n    Honestly, what are we going to do?    \t说实话, 我们去干嘛?\n\n### 2. 语法\n\n<font color=red>'So' 和 'such'</font>\n\n请用so + 形容词 或 so + 副词来强调个人品质。\n\n    Kyle is so disorganized.  \tKyle 非常没有条理。\n    She works so quickly.   \t她做事很快。\n\n请用such + 名词来强调个人品质.\n\n    Debra is such a team player. \tDebra 是非常具有团队精神的人。\n    She shows such creativity.      她表现出极大的创造力。\n    Oscar is such a hard worker.    Oscar 是工作非常努力的人。\n\n### 3. 表达\n\n作为工作面试流程的一部分，公司可能会电话联系推荐人并索要推荐。\n\n    We're interviewing Joe Wilson for a job at our company.  我们正在为我们公司的一个职位面试乔威尔逊。\n    Joe gave us your name as a reference.   乔把您的名字给我们做为他的推荐人。\n \n在这些例子中，注意问题是如何用具体信息回答的。\n \n    A. Did you work together?  你们一共工作过吗？\n    B. Yes. We worked together for two years at Sunset Computers.  是的。我们在Sunset Computers 公司一起工作过两年。\n    A. Do you recommend him?  您推荐他吗？\n    B. Yes. I highly recommend him. He's very intelligent. 是的。我强烈推荐他。他非常聪明。\n    A. What else can you tell me about him?  关于他还有些别的什么您能告诉我的吗？\n    B. Well, he was very organized. He worked well on a team.  嗯，他很有条理。他和团队工作和谐。\n","slug":"英语/4-unit-2","published":1,"updated":"2018-05-31T10:27:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3di000quox1uq9igqq6","content":"<blockquote>\n<p>4-unit-2，加入英孚，整理每个单元所学的重点词汇，语法，句子，以及各种阅读技巧和英语听力，汇总各个场合的口语。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"2-1（描述他人）\"><a href=\"#2-1（描述他人）\" class=\"headerlink\" title=\"2-1（描述他人）\"></a>2-1（描述他人）</h2><h3 id=\"1-词汇\"><a href=\"#1-词汇\" class=\"headerlink\" title=\"1. 词汇\"></a>1. 词汇</h3><pre><code>tall    高\nmedium height    中等高度\nshort    矮\noverweight    超重\nfat    肥胖\nthin    瘦\nShe is tall and thin.    她又高又瘦。\nHe has a nice smile.    他拥有迷人的笑容。\nlong     长发\nmedium length    中长发\nshort    短发\ncurly    卷发\nstraight    直发\nblond    金发\nbald    秃顶\nShe has long, straight, brown hair.    她拥有一头棕色的长长的直发。\nMy father is bald.    \nold    老年\nmiddle-aged    中年\nyoung    年轻\n</code></pre><h3 id=\"2-语法\"><a href=\"#2-语法\" class=\"headerlink\" title=\"2. 语法\"></a>2. 语法</h3><p>当您使用一个以上的形容词进行描述时，一般的规则是把它们按大小，年龄，然后颜色的顺序排列。</p>\n<pre><code>He has big, brown eyes.    \n他长着一双大大的棕色眼睛。\nHer hair is shorter and grayer than before.    \n她的头发比以前更短了，也变得更灰白了。\nThat tall, young, blond man drives a truck.    \n那个高个儿的，金发碧眼的年轻男子开一辆卡车。形容词的排序\n</code></pre><h3 id=\"3-表达\"><a href=\"#3-表达\" class=\"headerlink\" title=\"3. 表达\"></a>3. 表达</h3><p>What is (person) like? 或者 What does (person) look like?是用来询问一个人的身材，形体，年龄或者整体的外貌。 使用动词 be 来描述整体的外貌。</p>\n<pre><code>A: What does he look like?    他长什么样？\nB: He is tall and middle-aged. He&apos;s very good-looking.    他高个子，中年人，样子很好看。\n</code></pre><p>您也可以使用像What’s his hair like? 或 What color are his eyes? 这样的疑问句去询问一个人的身体特定部位的描述。 使用动词have 来指身体的部位。</p>\n<pre><code>A: What color are his eyes?    他的眼睛是什么颜色的？\nB: They&apos;re brown.    它们是棕色的。\nA: How tall is she?    她有多高？\nB: She&apos;s very tall.    她很高。\nA: What do the children look like?    这些小孩看起来像什么？\nB: They have curly, red hair. Jasmine has big, brown eyes, and Jason has blue eyes.    他们的头发又红又卷，杰斯敏的眼睛大大的，是棕色的，而贾森的眼睛是蓝色的。\n</code></pre><h2 id=\"2-2（描述关系）\"><a href=\"#2-2（描述关系）\" class=\"headerlink\" title=\"2-2（描述关系）\"></a>2-2（描述关系）</h2><h3 id=\"1-词汇-1\"><a href=\"#1-词汇-1\" class=\"headerlink\" title=\"1. 词汇\"></a>1. 词汇</h3><pre><code>wife    妻子\nhusband    丈夫\ngranddaughter    孙女\ngrandson    孙子\naunt    阿姨\nuncle    叔叔\nniece    侄女\nnephew    侄子\ncousin    堂表兄弟姐妹\n</code></pre><h3 id=\"2-语法-1\"><a href=\"#2-语法-1\" class=\"headerlink\" title=\"2. 语法\"></a>2. 语法</h3><p>使用类似以下的表达来描述一段关系中正在发生的事情。注意，所有表达都后接动名词 (verb + -ing)。<br>表达式可以是肯定的：</p>\n<pre><code>We spend time watching movies.     我们看电影打发时间。\nI always have fun talking with him.    和他谈天我总是感到很开心。\n</code></pre><p>表达式可以是否定的：</p>\n<pre><code>We have a hard time getting together.    我们好不容易在一起。\nShe has trouble making money.    赚钱对她来说是件困难的事。\nThey often waste time fighting.    (他们常常浪费时间吵架。)\n</code></pre><h3 id=\"3-表达-1\"><a href=\"#3-表达-1\" class=\"headerlink\" title=\"3. 表达\"></a>3. 表达</h3><p>请使用类似以下的问题来询问别人一段关系。注意答复中表达式 +动名词的结构。</p>\n<pre><code>A: How are you and your brother doing?\nB: We&apos;re doing well, thanks. We spend time talking on the phone.    你和你哥哥（弟弟）关系还好吗？\n我们关系很好，谢谢。我们会花时间打电话聊天。\nA: What do you and Sylvia do for fun?\nB: Let&apos;s see … We have a lot of fun playing tennis together.    你和 Sylvia 都玩什么？\n让我想想……我们一起打网球，玩得很开心。\n您可以使用you two 表达密切的关系 - 例如，丈夫与妻子之间或母亲与孩子之前。\nA: Are you two having trouble?\nB: Yeah, we are. I am having trouble understanding her problems.\nA: I&apos;m sorry to hear that.    你们两人碰到什么难题了吗？\n是的，我们碰到了难题。我难以理解她的问题。\n听到这我很难过。\n</code></pre><h2 id=\"2-3（评估员工）\"><a href=\"#2-3（评估员工）\" class=\"headerlink\" title=\"2-3（评估员工）\"></a>2-3（评估员工）</h2><h3 id=\"1-词汇-2\"><a href=\"#1-词汇-2\" class=\"headerlink\" title=\"1. 词汇\"></a>1. 词汇</h3><pre><code>performance appraisals 绩效评估\nhardworking 勤奋的\ndoes a really good job 做得出色\nworked really well with the team 与团队合作融洽\nteam player 有团队精神的人\nnot efficient enough 不够高效的\norganized 有条理的\nlazy 懒惰的\ngood in meetings 在会议中表现出色\nhelpful 有帮助的\nefficient    有效率的\ncreative    富有创造性的\npositive    积极的\ndoes a good job     做得不错\nworks well with the team / team player    与团队/ 队员合作愉快\ngetting better    逐渐在改善\ngood in meetings    善于开会\n\ncould do better     可以做得更好\nlate     迟到\nnegative    消极的\ndisorganized    混乱的\nlazy    懒惰\n</code></pre><p>一种更积极的方式来应对员工的弱点即是给出建设性的批评，而不是简单地给出消极的评论。</p>\n<pre><code>She&apos;s so disorganized. &gt; She needs to be more organized.    她很混乱。 &gt; 她应该要更有条理些。\nHe&apos;s too negative. &gt; He should be more positive.    他太消极了。 &gt; 他应该积极些。\n</code></pre><h3 id=\"2-语法-2\"><a href=\"#2-语法-2\" class=\"headerlink\" title=\"2. 语法\"></a>2. 语法</h3><font color=\"red\">‘Too’ 和 ‘enough’</font>\n\n<p>请用 too + 形容词来描述某样东西超过必要，或超过所需时。</p>\n<pre><code>Her project is late because she&apos;s too disorganized.    她的项目已经晚了，因为她太没有条理了。\nShe&apos;s too negative. She thinks too much about problems.    她太消极了。 她想问题考虑得太多了。\n</code></pre><p>请用形容词 + enough 来描述当某件东西足够的，或让人满意的时候。</p>\n<pre><code>Carson is hardworking and efficient enough to be the new manager.    Carson够勤劳且够有效率，够格成为新经理。\n请用not + 形容词 + enough 来描述某件东西缺乏或不尽人意时。\nSally&apos;s not efficient enough.     Sally的效率还不够高。\nHe&apos;s not creative enough to work in marketing.       他没有足够的创造力做市场营销工作。\n</code></pre><h3 id=\"3-表达-2\"><a href=\"#3-表达-2\" class=\"headerlink\" title=\"3.表达\"></a>3.表达</h3><p>发表意见的时候用 ‘I think that’</p>\n<p>使用 I think that 来表示您在发表一个意见。 使用 so do I 来表示同意一个 I think that 和 I like 这样的短语所表达的意见. </p>\n<pre><code>A: I think that he does a really good job. 我觉得他干的不错。 \nB: So do I.      我也觉得。    \n\nA: I like them both.  我喜欢他俩。\nB: So do I.              我也觉得。\n\n使用neither do I 来赞成 I don&apos;t think that  这样句式所表达的意见, 或其他否定意见。\nA: I don&apos;t think she&apos;s lazy.  我并不觉得她懒。\nB: Neither do I.     我也不觉得。\n请注意 that 可以省掉且句子的含义没有受到影响。\n\n要征求别人的意见，您可以使用what do you think about 以及 do you think。\nA: What do you think about Denise?  您觉得Denise怎么样? 她很有效率。\nB: She&apos;s very efficient.         她非常有效率。\nA: Do you think Paul is too disorganized?  您觉不觉得Paul这个人太混乱了?\nB: No, not really.  不，不是的。    \n\n语言注释：neither有两种发音方法。在下面的例子中，第一个在美国比较普遍的；第二种多见于英国。但它们可以互换使用。\n\nA: I don&apos;t think he&apos;s disorganized. 我并不觉得他这个人没有调理。\nB: Neither do I.     我也不觉得。\n\nA: I don&apos;t think she&apos;s very efficient. 我并不觉得她很有效率。\nB: Neither do I.     我也不觉得。\n</code></pre><h2 id=\"2-3（给出推荐）\"><a href=\"#2-3（给出推荐）\" class=\"headerlink\" title=\"2-3（给出推荐）\"></a>2-3（给出推荐）</h2><h3 id=\"1-词汇-3\"><a href=\"#1-词汇-3\" class=\"headerlink\" title=\"1. 词汇\"></a>1. 词汇</h3><pre><code>learn it pretty quickly  学得很快\n</code></pre><p>副词解释how, when or where。它们可以修饰一个动词，形容词或另一个副词。许多副词以-ly 结尾的是最容易识别的和形成的。但是，许多副词是不以-ly 结尾的,识别它们的最好的方式是将它们连接到它们所修饰的动词，形容词或副词。</p>\n<p>使用状态副词加动词来表示完成某件事情的方式。</p>\n<pre><code>Martina works quickly.     Martina工作效率高。\nShe works well with the team.    她与团队合作得很愉快。\nI highly recommend Martina.    我强烈推荐Martina。\nI&apos;m going to miss her terribly.     我将会非常想念她。\n</code></pre><p>使用时间副词加动词来表示时间。</p>\n<pre><code>Her husband is already in New York.      她的丈夫已经在纽约了。\nShe&apos;s leaving that soon?    她这么快就走了?\n</code></pre><p>使用频率副词加动词来表示一个动作的频率。</p>\n<pre><code>She was always organized.         她一向都很有条理的。\n</code></pre><p>使用可能性副词加动词来表示一个行动的可能性。</p>\n<pre><code>She can probably learn that in one or two days.       她可能会在一或两天内知道。\n您可以使用 only 加动词来把注意力集中到信息上。\nThe project only took her one day.        她可以仅用一天时间完成此项目。\n</code></pre><p>您可以使用副词来修饰形容词。</p>\n<pre><code>The brochure was really beautiful.        这本小册子真的很漂亮。\nShe&apos;s so creative.         她真有创意。\n</code></pre><p>有些副词修饰其他副词. 请注意 pretty 和 so 是如何给这些句子添加额外的细节的。</p>\n<pre><code>She can learn that pretty quickly.    她能领悟得相当快。\nHe writes so well.     \n他写得真好。\n您可以使用副词honestly 在一个句子前边来强调强调某个要点。\nHonestly, what are we going to do?        说实话, 我们去干嘛?\n</code></pre><h3 id=\"2-语法-3\"><a href=\"#2-语法-3\" class=\"headerlink\" title=\"2. 语法\"></a>2. 语法</h3><font color=\"red\">‘So’ 和 ‘such’</font>\n\n<p>请用so + 形容词 或 so + 副词来强调个人品质。</p>\n<pre><code>Kyle is so disorganized.      Kyle 非常没有条理。\nShe works so quickly.       她做事很快。\n</code></pre><p>请用such + 名词来强调个人品质.</p>\n<pre><code>Debra is such a team player.     Debra 是非常具有团队精神的人。\nShe shows such creativity.      她表现出极大的创造力。\nOscar is such a hard worker.    Oscar 是工作非常努力的人。\n</code></pre><h3 id=\"3-表达-3\"><a href=\"#3-表达-3\" class=\"headerlink\" title=\"3. 表达\"></a>3. 表达</h3><p>作为工作面试流程的一部分，公司可能会电话联系推荐人并索要推荐。</p>\n<pre><code>We&apos;re interviewing Joe Wilson for a job at our company.  我们正在为我们公司的一个职位面试乔威尔逊。\nJoe gave us your name as a reference.   乔把您的名字给我们做为他的推荐人。\n</code></pre><p>在这些例子中，注意问题是如何用具体信息回答的。</p>\n<pre><code>A. Did you work together?  你们一共工作过吗？\nB. Yes. We worked together for two years at Sunset Computers.  是的。我们在Sunset Computers 公司一起工作过两年。\nA. Do you recommend him?  您推荐他吗？\nB. Yes. I highly recommend him. He&apos;s very intelligent. 是的。我强烈推荐他。他非常聪明。\nA. What else can you tell me about him?  关于他还有些别的什么您能告诉我的吗？\nB. Well, he was very organized. He worked well on a team.  嗯，他很有条理。他和团队工作和谐。\n</code></pre>","site":{"data":{}},"excerpt":"<blockquote>\n<p>4-unit-2，加入英孚，整理每个单元所学的重点词汇，语法，句子，以及各种阅读技巧和英语听力，汇总各个场合的口语。</p>\n</blockquote>","more":"<h2 id=\"2-1（描述他人）\"><a href=\"#2-1（描述他人）\" class=\"headerlink\" title=\"2-1（描述他人）\"></a>2-1（描述他人）</h2><h3 id=\"1-词汇\"><a href=\"#1-词汇\" class=\"headerlink\" title=\"1. 词汇\"></a>1. 词汇</h3><pre><code>tall    高\nmedium height    中等高度\nshort    矮\noverweight    超重\nfat    肥胖\nthin    瘦\nShe is tall and thin.    她又高又瘦。\nHe has a nice smile.    他拥有迷人的笑容。\nlong     长发\nmedium length    中长发\nshort    短发\ncurly    卷发\nstraight    直发\nblond    金发\nbald    秃顶\nShe has long, straight, brown hair.    她拥有一头棕色的长长的直发。\nMy father is bald.    \nold    老年\nmiddle-aged    中年\nyoung    年轻\n</code></pre><h3 id=\"2-语法\"><a href=\"#2-语法\" class=\"headerlink\" title=\"2. 语法\"></a>2. 语法</h3><p>当您使用一个以上的形容词进行描述时，一般的规则是把它们按大小，年龄，然后颜色的顺序排列。</p>\n<pre><code>He has big, brown eyes.    \n他长着一双大大的棕色眼睛。\nHer hair is shorter and grayer than before.    \n她的头发比以前更短了，也变得更灰白了。\nThat tall, young, blond man drives a truck.    \n那个高个儿的，金发碧眼的年轻男子开一辆卡车。形容词的排序\n</code></pre><h3 id=\"3-表达\"><a href=\"#3-表达\" class=\"headerlink\" title=\"3. 表达\"></a>3. 表达</h3><p>What is (person) like? 或者 What does (person) look like?是用来询问一个人的身材，形体，年龄或者整体的外貌。 使用动词 be 来描述整体的外貌。</p>\n<pre><code>A: What does he look like?    他长什么样？\nB: He is tall and middle-aged. He&apos;s very good-looking.    他高个子，中年人，样子很好看。\n</code></pre><p>您也可以使用像What’s his hair like? 或 What color are his eyes? 这样的疑问句去询问一个人的身体特定部位的描述。 使用动词have 来指身体的部位。</p>\n<pre><code>A: What color are his eyes?    他的眼睛是什么颜色的？\nB: They&apos;re brown.    它们是棕色的。\nA: How tall is she?    她有多高？\nB: She&apos;s very tall.    她很高。\nA: What do the children look like?    这些小孩看起来像什么？\nB: They have curly, red hair. Jasmine has big, brown eyes, and Jason has blue eyes.    他们的头发又红又卷，杰斯敏的眼睛大大的，是棕色的，而贾森的眼睛是蓝色的。\n</code></pre><h2 id=\"2-2（描述关系）\"><a href=\"#2-2（描述关系）\" class=\"headerlink\" title=\"2-2（描述关系）\"></a>2-2（描述关系）</h2><h3 id=\"1-词汇-1\"><a href=\"#1-词汇-1\" class=\"headerlink\" title=\"1. 词汇\"></a>1. 词汇</h3><pre><code>wife    妻子\nhusband    丈夫\ngranddaughter    孙女\ngrandson    孙子\naunt    阿姨\nuncle    叔叔\nniece    侄女\nnephew    侄子\ncousin    堂表兄弟姐妹\n</code></pre><h3 id=\"2-语法-1\"><a href=\"#2-语法-1\" class=\"headerlink\" title=\"2. 语法\"></a>2. 语法</h3><p>使用类似以下的表达来描述一段关系中正在发生的事情。注意，所有表达都后接动名词 (verb + -ing)。<br>表达式可以是肯定的：</p>\n<pre><code>We spend time watching movies.     我们看电影打发时间。\nI always have fun talking with him.    和他谈天我总是感到很开心。\n</code></pre><p>表达式可以是否定的：</p>\n<pre><code>We have a hard time getting together.    我们好不容易在一起。\nShe has trouble making money.    赚钱对她来说是件困难的事。\nThey often waste time fighting.    (他们常常浪费时间吵架。)\n</code></pre><h3 id=\"3-表达-1\"><a href=\"#3-表达-1\" class=\"headerlink\" title=\"3. 表达\"></a>3. 表达</h3><p>请使用类似以下的问题来询问别人一段关系。注意答复中表达式 +动名词的结构。</p>\n<pre><code>A: How are you and your brother doing?\nB: We&apos;re doing well, thanks. We spend time talking on the phone.    你和你哥哥（弟弟）关系还好吗？\n我们关系很好，谢谢。我们会花时间打电话聊天。\nA: What do you and Sylvia do for fun?\nB: Let&apos;s see … We have a lot of fun playing tennis together.    你和 Sylvia 都玩什么？\n让我想想……我们一起打网球，玩得很开心。\n您可以使用you two 表达密切的关系 - 例如，丈夫与妻子之间或母亲与孩子之前。\nA: Are you two having trouble?\nB: Yeah, we are. I am having trouble understanding her problems.\nA: I&apos;m sorry to hear that.    你们两人碰到什么难题了吗？\n是的，我们碰到了难题。我难以理解她的问题。\n听到这我很难过。\n</code></pre><h2 id=\"2-3（评估员工）\"><a href=\"#2-3（评估员工）\" class=\"headerlink\" title=\"2-3（评估员工）\"></a>2-3（评估员工）</h2><h3 id=\"1-词汇-2\"><a href=\"#1-词汇-2\" class=\"headerlink\" title=\"1. 词汇\"></a>1. 词汇</h3><pre><code>performance appraisals 绩效评估\nhardworking 勤奋的\ndoes a really good job 做得出色\nworked really well with the team 与团队合作融洽\nteam player 有团队精神的人\nnot efficient enough 不够高效的\norganized 有条理的\nlazy 懒惰的\ngood in meetings 在会议中表现出色\nhelpful 有帮助的\nefficient    有效率的\ncreative    富有创造性的\npositive    积极的\ndoes a good job     做得不错\nworks well with the team / team player    与团队/ 队员合作愉快\ngetting better    逐渐在改善\ngood in meetings    善于开会\n\ncould do better     可以做得更好\nlate     迟到\nnegative    消极的\ndisorganized    混乱的\nlazy    懒惰\n</code></pre><p>一种更积极的方式来应对员工的弱点即是给出建设性的批评，而不是简单地给出消极的评论。</p>\n<pre><code>She&apos;s so disorganized. &gt; She needs to be more organized.    她很混乱。 &gt; 她应该要更有条理些。\nHe&apos;s too negative. &gt; He should be more positive.    他太消极了。 &gt; 他应该积极些。\n</code></pre><h3 id=\"2-语法-2\"><a href=\"#2-语法-2\" class=\"headerlink\" title=\"2. 语法\"></a>2. 语法</h3><font color=\"red\">‘Too’ 和 ‘enough’</font>\n\n<p>请用 too + 形容词来描述某样东西超过必要，或超过所需时。</p>\n<pre><code>Her project is late because she&apos;s too disorganized.    她的项目已经晚了，因为她太没有条理了。\nShe&apos;s too negative. She thinks too much about problems.    她太消极了。 她想问题考虑得太多了。\n</code></pre><p>请用形容词 + enough 来描述当某件东西足够的，或让人满意的时候。</p>\n<pre><code>Carson is hardworking and efficient enough to be the new manager.    Carson够勤劳且够有效率，够格成为新经理。\n请用not + 形容词 + enough 来描述某件东西缺乏或不尽人意时。\nSally&apos;s not efficient enough.     Sally的效率还不够高。\nHe&apos;s not creative enough to work in marketing.       他没有足够的创造力做市场营销工作。\n</code></pre><h3 id=\"3-表达-2\"><a href=\"#3-表达-2\" class=\"headerlink\" title=\"3.表达\"></a>3.表达</h3><p>发表意见的时候用 ‘I think that’</p>\n<p>使用 I think that 来表示您在发表一个意见。 使用 so do I 来表示同意一个 I think that 和 I like 这样的短语所表达的意见. </p>\n<pre><code>A: I think that he does a really good job. 我觉得他干的不错。 \nB: So do I.      我也觉得。    \n\nA: I like them both.  我喜欢他俩。\nB: So do I.              我也觉得。\n\n使用neither do I 来赞成 I don&apos;t think that  这样句式所表达的意见, 或其他否定意见。\nA: I don&apos;t think she&apos;s lazy.  我并不觉得她懒。\nB: Neither do I.     我也不觉得。\n请注意 that 可以省掉且句子的含义没有受到影响。\n\n要征求别人的意见，您可以使用what do you think about 以及 do you think。\nA: What do you think about Denise?  您觉得Denise怎么样? 她很有效率。\nB: She&apos;s very efficient.         她非常有效率。\nA: Do you think Paul is too disorganized?  您觉不觉得Paul这个人太混乱了?\nB: No, not really.  不，不是的。    \n\n语言注释：neither有两种发音方法。在下面的例子中，第一个在美国比较普遍的；第二种多见于英国。但它们可以互换使用。\n\nA: I don&apos;t think he&apos;s disorganized. 我并不觉得他这个人没有调理。\nB: Neither do I.     我也不觉得。\n\nA: I don&apos;t think she&apos;s very efficient. 我并不觉得她很有效率。\nB: Neither do I.     我也不觉得。\n</code></pre><h2 id=\"2-3（给出推荐）\"><a href=\"#2-3（给出推荐）\" class=\"headerlink\" title=\"2-3（给出推荐）\"></a>2-3（给出推荐）</h2><h3 id=\"1-词汇-3\"><a href=\"#1-词汇-3\" class=\"headerlink\" title=\"1. 词汇\"></a>1. 词汇</h3><pre><code>learn it pretty quickly  学得很快\n</code></pre><p>副词解释how, when or where。它们可以修饰一个动词，形容词或另一个副词。许多副词以-ly 结尾的是最容易识别的和形成的。但是，许多副词是不以-ly 结尾的,识别它们的最好的方式是将它们连接到它们所修饰的动词，形容词或副词。</p>\n<p>使用状态副词加动词来表示完成某件事情的方式。</p>\n<pre><code>Martina works quickly.     Martina工作效率高。\nShe works well with the team.    她与团队合作得很愉快。\nI highly recommend Martina.    我强烈推荐Martina。\nI&apos;m going to miss her terribly.     我将会非常想念她。\n</code></pre><p>使用时间副词加动词来表示时间。</p>\n<pre><code>Her husband is already in New York.      她的丈夫已经在纽约了。\nShe&apos;s leaving that soon?    她这么快就走了?\n</code></pre><p>使用频率副词加动词来表示一个动作的频率。</p>\n<pre><code>She was always organized.         她一向都很有条理的。\n</code></pre><p>使用可能性副词加动词来表示一个行动的可能性。</p>\n<pre><code>She can probably learn that in one or two days.       她可能会在一或两天内知道。\n您可以使用 only 加动词来把注意力集中到信息上。\nThe project only took her one day.        她可以仅用一天时间完成此项目。\n</code></pre><p>您可以使用副词来修饰形容词。</p>\n<pre><code>The brochure was really beautiful.        这本小册子真的很漂亮。\nShe&apos;s so creative.         她真有创意。\n</code></pre><p>有些副词修饰其他副词. 请注意 pretty 和 so 是如何给这些句子添加额外的细节的。</p>\n<pre><code>She can learn that pretty quickly.    她能领悟得相当快。\nHe writes so well.     \n他写得真好。\n您可以使用副词honestly 在一个句子前边来强调强调某个要点。\nHonestly, what are we going to do?        说实话, 我们去干嘛?\n</code></pre><h3 id=\"2-语法-3\"><a href=\"#2-语法-3\" class=\"headerlink\" title=\"2. 语法\"></a>2. 语法</h3><font color=\"red\">‘So’ 和 ‘such’</font>\n\n<p>请用so + 形容词 或 so + 副词来强调个人品质。</p>\n<pre><code>Kyle is so disorganized.      Kyle 非常没有条理。\nShe works so quickly.       她做事很快。\n</code></pre><p>请用such + 名词来强调个人品质.</p>\n<pre><code>Debra is such a team player.     Debra 是非常具有团队精神的人。\nShe shows such creativity.      她表现出极大的创造力。\nOscar is such a hard worker.    Oscar 是工作非常努力的人。\n</code></pre><h3 id=\"3-表达-3\"><a href=\"#3-表达-3\" class=\"headerlink\" title=\"3. 表达\"></a>3. 表达</h3><p>作为工作面试流程的一部分，公司可能会电话联系推荐人并索要推荐。</p>\n<pre><code>We&apos;re interviewing Joe Wilson for a job at our company.  我们正在为我们公司的一个职位面试乔威尔逊。\nJoe gave us your name as a reference.   乔把您的名字给我们做为他的推荐人。\n</code></pre><p>在这些例子中，注意问题是如何用具体信息回答的。</p>\n<pre><code>A. Did you work together?  你们一共工作过吗？\nB. Yes. We worked together for two years at Sunset Computers.  是的。我们在Sunset Computers 公司一起工作过两年。\nA. Do you recommend him?  您推荐他吗？\nB. Yes. I highly recommend him. He&apos;s very intelligent. 是的。我强烈推荐他。他非常聪明。\nA. What else can you tell me about him?  关于他还有些别的什么您能告诉我的吗？\nB. Well, he was very organized. He worked well on a team.  嗯，他很有条理。他和团队工作和谐。\n</code></pre>"},{"title":"4-unit-3","date":"2017-01-10T05:59:58.000Z","_content":"\n> 4-unit-3，加入英孚，整理每个单元所学的重点词汇，语法，句子，以及各种阅读技巧和英语听力，汇总各个场合的口语。\n\n<!-- more -->\n\n## 3-1（询问别人一周的情况）\n\n### 1. 词汇\n\n\tI ironed my clothes.   我熨了衣服。\n\tI had a job interview. 我参加了一次工作面试。\n\n### 2. 语法\n\n许多动词过去时只用在动词词尾添加 -ed 即可。 \n\n\twalk - walked\n\tclean - cleaned   \n\n不规则动词 \n\n\thave - had\n\tmake - made\n\teat - ate\n\tdrink - drank\n\tlet - let      \n\nbe 动词的过去时否定式为 was not 和 were not，对应的缩写形式分别为 wasn't 和 weren't。\n\n\tFrank was not happy in Los Angeles. > Frank wasn't happy in Los Angeles.\t \tFrank 以前在洛杉矶过得不开心。\n\n\tOscar and Pam were not at home yesterday. > Oscar and Pam weren't at home yesterday.\t \tOscar 和 Pam 昨天不在家。\n \t \t \t \n在句首使用单词 did 来形成过去时疑问句。did 后使用主要动词的原形。不得在动词词尾后加 s。\n\n\tDid he go to Shanghai?        \t \t他去上海了吗？\n\tDid they eat dinner?                他们吃了吗？\n\n要使用 be 动词组成过去时疑问句，请将 was 或 were 置于问句之首。 \n\n\t陈述句：  He was happy.\t \t他以前很开心。\n\t疑问句：  Was he happy?     他以前很开心吗？\n\n### 3. 表达\n\n使用下列表达来谈论过去的事情。\n\n<font color=red>'Yesterday'</font>\n \t                        \n\tI visited Carol yesterday.\t我昨天拜访了 Carol。\n \t'The day before yesterday'\t \n\tJack and Nancy got back from Mexico the day before yesterday.\tJack 和 Nancy 前天从墨西哥回来了。\n \n<font color=red>数字 + 时间单词 + ago</font>\n\n\tWe went to that new restaurant two days ago.\t我们两天前去了那家新餐馆。\n \n<font color=red>last + 时间单词</font>\n\n\tI worked at a supermarket last year.\t我去年在一家超市上班。\n\n*** 开放式问题和封闭式问题 ***\n\n开放式问题是指答案不止一个的问题。比如，How was Paris? 有多种可能的回答。\n\n\tHow was Paris?\t\t巴黎怎么样？\n\tIt was great!\t\t太棒了！\n\tIt was terrible.\t很差。\n\tWe loved it.\t\t我们很喜欢。\n\tWe hated it.\t\t我们很讨厌。\n \n***封闭式问题则只有肯定和否定两种回答：yes 或 no。***\n \n\tDid you go to Paris?\t你去过巴黎吗？\n\tYes, I did.\t\t\t\t是的，我去过。  \n\tNo, I didn't.\t\t\t没，我没去过。\n \n***开放式问题一般更利于推动对话。它们让和你对话的人可以自由回答，回答方法也有多种。开放式问题主要分为两种：描述性问题和意见性问题。***\n \n描述性问题\n \n\tWhat was it like?\t（它什么样子？）\n\tWhat was the wedding like?\t婚礼是什么样子？\n\tWhat did he look like?\t他长什么样？\n \t \n意见性问题\n \t \n\tHow did you like Beijing?\t你有多喜欢北京？\n\tHow was your vacation?\t你的假期怎么样？\n\tHow was Russia?\t（俄罗斯怎么样？）\n \n语言点：谨慎使用单词 like，该词有两种不同的意思。\n\n\t描述： What was it like?\t（它是什么样子？）\n\t观点： How did you like it?\t（你有多喜欢它？）\n\n## 3-1（谈论你的周末）\n\n### 1. 词汇\n\n\tI ate some spaghetti.\n\tWe drove to Las Vegas.\n\tThey did yoga.\n\tShe brought a gift.\n\tI went jogging\n\tto cut a long story short  长话短说\n\n### 2. 语法\n\n不规则动词过去时态\n \n\tgo - went  \t\t\t去                                                            \n\teat - ate  \t\t\t吃\n\tbring - brought  \t带来\n\tleave - left    \t离开\n\tsell - sold         卖                \t\n\tmake - made\t\t\t做\n\trise - rose \t\t上升\n\tget - got        \t得到\n\tcut - cut   \t\t切割\n\tlet - let \t\t\t让\n\tshut - shut\t\t\t关闭\n\tread - read \t\t读\n\n### 3. 口语\n\n\tHow are you doing? \t你还好吗？\n\tHow are you today?  你今天怎么样？\n\tWhat's up?\t\t\t你好吗？\n\tWhat's happening?\t在忙什么呢？\n\tWhat's going on? \t发生什么事了？\n\tHow was your weekend?\t你周末过得怎么样？\n\n如果没有想要谈论的话题，问候完后你可以使用一个常见的一般性问题。\n \t \t \n\tHow are you doing? \t你还好吗？\n\tHow are you today?  \t你今天怎么样？\n\tWhat's up?\t你好吗？\n\tWhat's happening?\t在忙什么呢？\n\tWhat's going on? \t发生什么事了？\n\tHow was your weekend?\t你周末过得怎么样？\n\n你可以向你认识的人询问他们的生活。\n\n\tHow was Peru? \t秘鲁怎么样？\n\tHow is your mom feeling?     你妈妈感觉怎么样？\n\n在有些场合，你会有一个你想讨论的话题。你可以提出陈述，然后听众会对你的陈述发表意见。 \n\n\tA: Hey, there was a great movie on last night.\n\tB: Really? What was it? \t嗨，昨天晚上的电影很好看。\n\t真的吗？什么电影？\n\tA: That was a great game last night!\n\tB: Yeah, it was really exciting! \t昨天晚上的比赛非常精彩！\n\t是啊，真的令人兴奋！\n\n### 4. 表达\n\n对话从一个话题转到另一个话题，有一些表达可以帮助人们暗示他们要改变话题。\n\n<font color=red>'By the way'</font>\n\n使用表达 by the way 来引入新话题，它也表示你刚想起了某事。\n\n\tA: By the way, I saw Joe last night. He looked good.\n\tB: Really? I'm so glad!\t对了，我昨天晚上见到 Joe 了。他气色看起来不错。\n\t真的吗？我非常高兴！\n\n<font color=red>'That reminds me'</font>\n\n当你想起了想说的其他事情，使用 that reminds me 来转变话题。 \n\n\tA: There was a great baseball game on TV last night.\n\tB: Oh, that reminds me. I have two tickets to tonight's game. Do you want to go?\n\tA: Yeah!\t昨天晚上电视上有一场精彩的棒球比赛。\n\t哦，我想起来了。我有两张今天晚上比赛的票。你想去吗？\n\t是啊！\n\n<font color=red>'Anyway'</font>\n\n使用单词 anyway 来结束或总结话题，这样一来你可以开始一个新话题。当你听厌了某人谈论某事，非常想改变话题时，就可以使用这个词。\n\n\tA: That restaurant wasn't very good.\n\tB: No, it wasn't! The meat tasted bad, and the salad wasn't fresh. And the waiter was awful! His clothes were dirty!\n\tA: Anyway, we're not going there again. So, how's Jane?\t那家餐馆不是很好。\n\t是啊，不怎么好！肉有味道，沙拉也不新鲜。而且服务员也很差劲！他的衣服很脏！\n\t总之，我们不打算再去了。对了，Jane 还好吧？","source":"_posts/英语/4-unit-3.md","raw":"---\ntitle: 4-unit-3\ndate: 2017-01-10 13:59:58\ncategories:\n- 英语\ntags: 英语\n---\n\n> 4-unit-3，加入英孚，整理每个单元所学的重点词汇，语法，句子，以及各种阅读技巧和英语听力，汇总各个场合的口语。\n\n<!-- more -->\n\n## 3-1（询问别人一周的情况）\n\n### 1. 词汇\n\n\tI ironed my clothes.   我熨了衣服。\n\tI had a job interview. 我参加了一次工作面试。\n\n### 2. 语法\n\n许多动词过去时只用在动词词尾添加 -ed 即可。 \n\n\twalk - walked\n\tclean - cleaned   \n\n不规则动词 \n\n\thave - had\n\tmake - made\n\teat - ate\n\tdrink - drank\n\tlet - let      \n\nbe 动词的过去时否定式为 was not 和 were not，对应的缩写形式分别为 wasn't 和 weren't。\n\n\tFrank was not happy in Los Angeles. > Frank wasn't happy in Los Angeles.\t \tFrank 以前在洛杉矶过得不开心。\n\n\tOscar and Pam were not at home yesterday. > Oscar and Pam weren't at home yesterday.\t \tOscar 和 Pam 昨天不在家。\n \t \t \t \n在句首使用单词 did 来形成过去时疑问句。did 后使用主要动词的原形。不得在动词词尾后加 s。\n\n\tDid he go to Shanghai?        \t \t他去上海了吗？\n\tDid they eat dinner?                他们吃了吗？\n\n要使用 be 动词组成过去时疑问句，请将 was 或 were 置于问句之首。 \n\n\t陈述句：  He was happy.\t \t他以前很开心。\n\t疑问句：  Was he happy?     他以前很开心吗？\n\n### 3. 表达\n\n使用下列表达来谈论过去的事情。\n\n<font color=red>'Yesterday'</font>\n \t                        \n\tI visited Carol yesterday.\t我昨天拜访了 Carol。\n \t'The day before yesterday'\t \n\tJack and Nancy got back from Mexico the day before yesterday.\tJack 和 Nancy 前天从墨西哥回来了。\n \n<font color=red>数字 + 时间单词 + ago</font>\n\n\tWe went to that new restaurant two days ago.\t我们两天前去了那家新餐馆。\n \n<font color=red>last + 时间单词</font>\n\n\tI worked at a supermarket last year.\t我去年在一家超市上班。\n\n*** 开放式问题和封闭式问题 ***\n\n开放式问题是指答案不止一个的问题。比如，How was Paris? 有多种可能的回答。\n\n\tHow was Paris?\t\t巴黎怎么样？\n\tIt was great!\t\t太棒了！\n\tIt was terrible.\t很差。\n\tWe loved it.\t\t我们很喜欢。\n\tWe hated it.\t\t我们很讨厌。\n \n***封闭式问题则只有肯定和否定两种回答：yes 或 no。***\n \n\tDid you go to Paris?\t你去过巴黎吗？\n\tYes, I did.\t\t\t\t是的，我去过。  \n\tNo, I didn't.\t\t\t没，我没去过。\n \n***开放式问题一般更利于推动对话。它们让和你对话的人可以自由回答，回答方法也有多种。开放式问题主要分为两种：描述性问题和意见性问题。***\n \n描述性问题\n \n\tWhat was it like?\t（它什么样子？）\n\tWhat was the wedding like?\t婚礼是什么样子？\n\tWhat did he look like?\t他长什么样？\n \t \n意见性问题\n \t \n\tHow did you like Beijing?\t你有多喜欢北京？\n\tHow was your vacation?\t你的假期怎么样？\n\tHow was Russia?\t（俄罗斯怎么样？）\n \n语言点：谨慎使用单词 like，该词有两种不同的意思。\n\n\t描述： What was it like?\t（它是什么样子？）\n\t观点： How did you like it?\t（你有多喜欢它？）\n\n## 3-1（谈论你的周末）\n\n### 1. 词汇\n\n\tI ate some spaghetti.\n\tWe drove to Las Vegas.\n\tThey did yoga.\n\tShe brought a gift.\n\tI went jogging\n\tto cut a long story short  长话短说\n\n### 2. 语法\n\n不规则动词过去时态\n \n\tgo - went  \t\t\t去                                                            \n\teat - ate  \t\t\t吃\n\tbring - brought  \t带来\n\tleave - left    \t离开\n\tsell - sold         卖                \t\n\tmake - made\t\t\t做\n\trise - rose \t\t上升\n\tget - got        \t得到\n\tcut - cut   \t\t切割\n\tlet - let \t\t\t让\n\tshut - shut\t\t\t关闭\n\tread - read \t\t读\n\n### 3. 口语\n\n\tHow are you doing? \t你还好吗？\n\tHow are you today?  你今天怎么样？\n\tWhat's up?\t\t\t你好吗？\n\tWhat's happening?\t在忙什么呢？\n\tWhat's going on? \t发生什么事了？\n\tHow was your weekend?\t你周末过得怎么样？\n\n如果没有想要谈论的话题，问候完后你可以使用一个常见的一般性问题。\n \t \t \n\tHow are you doing? \t你还好吗？\n\tHow are you today?  \t你今天怎么样？\n\tWhat's up?\t你好吗？\n\tWhat's happening?\t在忙什么呢？\n\tWhat's going on? \t发生什么事了？\n\tHow was your weekend?\t你周末过得怎么样？\n\n你可以向你认识的人询问他们的生活。\n\n\tHow was Peru? \t秘鲁怎么样？\n\tHow is your mom feeling?     你妈妈感觉怎么样？\n\n在有些场合，你会有一个你想讨论的话题。你可以提出陈述，然后听众会对你的陈述发表意见。 \n\n\tA: Hey, there was a great movie on last night.\n\tB: Really? What was it? \t嗨，昨天晚上的电影很好看。\n\t真的吗？什么电影？\n\tA: That was a great game last night!\n\tB: Yeah, it was really exciting! \t昨天晚上的比赛非常精彩！\n\t是啊，真的令人兴奋！\n\n### 4. 表达\n\n对话从一个话题转到另一个话题，有一些表达可以帮助人们暗示他们要改变话题。\n\n<font color=red>'By the way'</font>\n\n使用表达 by the way 来引入新话题，它也表示你刚想起了某事。\n\n\tA: By the way, I saw Joe last night. He looked good.\n\tB: Really? I'm so glad!\t对了，我昨天晚上见到 Joe 了。他气色看起来不错。\n\t真的吗？我非常高兴！\n\n<font color=red>'That reminds me'</font>\n\n当你想起了想说的其他事情，使用 that reminds me 来转变话题。 \n\n\tA: There was a great baseball game on TV last night.\n\tB: Oh, that reminds me. I have two tickets to tonight's game. Do you want to go?\n\tA: Yeah!\t昨天晚上电视上有一场精彩的棒球比赛。\n\t哦，我想起来了。我有两张今天晚上比赛的票。你想去吗？\n\t是啊！\n\n<font color=red>'Anyway'</font>\n\n使用单词 anyway 来结束或总结话题，这样一来你可以开始一个新话题。当你听厌了某人谈论某事，非常想改变话题时，就可以使用这个词。\n\n\tA: That restaurant wasn't very good.\n\tB: No, it wasn't! The meat tasted bad, and the salad wasn't fresh. And the waiter was awful! His clothes were dirty!\n\tA: Anyway, we're not going there again. So, how's Jane?\t那家餐馆不是很好。\n\t是啊，不怎么好！肉有味道，沙拉也不新鲜。而且服务员也很差劲！他的衣服很脏！\n\t总之，我们不打算再去了。对了，Jane 还好吧？","slug":"英语/4-unit-3","published":1,"updated":"2018-05-31T10:27:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3di000ruox12d8e7cm2","content":"<blockquote>\n<p>4-unit-3，加入英孚，整理每个单元所学的重点词汇，语法，句子，以及各种阅读技巧和英语听力，汇总各个场合的口语。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"3-1（询问别人一周的情况）\"><a href=\"#3-1（询问别人一周的情况）\" class=\"headerlink\" title=\"3-1（询问别人一周的情况）\"></a>3-1（询问别人一周的情况）</h2><h3 id=\"1-词汇\"><a href=\"#1-词汇\" class=\"headerlink\" title=\"1. 词汇\"></a>1. 词汇</h3><pre><code>I ironed my clothes.   我熨了衣服。\nI had a job interview. 我参加了一次工作面试。\n</code></pre><h3 id=\"2-语法\"><a href=\"#2-语法\" class=\"headerlink\" title=\"2. 语法\"></a>2. 语法</h3><p>许多动词过去时只用在动词词尾添加 -ed 即可。 </p>\n<pre><code>walk - walked\nclean - cleaned   \n</code></pre><p>不规则动词 </p>\n<pre><code>have - had\nmake - made\neat - ate\ndrink - drank\nlet - let      \n</code></pre><p>be 动词的过去时否定式为 was not 和 were not，对应的缩写形式分别为 wasn’t 和 weren’t。</p>\n<pre><code>Frank was not happy in Los Angeles. &gt; Frank wasn&apos;t happy in Los Angeles.         Frank 以前在洛杉矶过得不开心。\n\nOscar and Pam were not at home yesterday. &gt; Oscar and Pam weren&apos;t at home yesterday.         Oscar 和 Pam 昨天不在家。\n</code></pre><p>在句首使用单词 did 来形成过去时疑问句。did 后使用主要动词的原形。不得在动词词尾后加 s。</p>\n<pre><code>Did he go to Shanghai?                 他去上海了吗？\nDid they eat dinner?                他们吃了吗？\n</code></pre><p>要使用 be 动词组成过去时疑问句，请将 was 或 were 置于问句之首。 </p>\n<pre><code>陈述句：  He was happy.         他以前很开心。\n疑问句：  Was he happy?     他以前很开心吗？\n</code></pre><h3 id=\"3-表达\"><a href=\"#3-表达\" class=\"headerlink\" title=\"3. 表达\"></a>3. 表达</h3><p>使用下列表达来谈论过去的事情。</p>\n<font color=\"red\">‘Yesterday’</font>\n\n<pre><code>I visited Carol yesterday.    我昨天拜访了 Carol。\n &apos;The day before yesterday&apos;     \nJack and Nancy got back from Mexico the day before yesterday.    Jack 和 Nancy 前天从墨西哥回来了。\n</code></pre><font color=\"red\">数字 + 时间单词 + ago</font>\n\n<pre><code>We went to that new restaurant two days ago.    我们两天前去了那家新餐馆。\n</code></pre><font color=\"red\">last + 时间单词</font>\n\n<pre><code>I worked at a supermarket last year.    我去年在一家超市上班。\n</code></pre><p><strong><em> 开放式问题和封闭式问题 </em></strong></p>\n<p>开放式问题是指答案不止一个的问题。比如，How was Paris? 有多种可能的回答。</p>\n<pre><code>How was Paris?        巴黎怎么样？\nIt was great!        太棒了！\nIt was terrible.    很差。\nWe loved it.        我们很喜欢。\nWe hated it.        我们很讨厌。\n</code></pre><p><strong><em>封闭式问题则只有肯定和否定两种回答：yes 或 no。</em></strong></p>\n<pre><code>Did you go to Paris?    你去过巴黎吗？\nYes, I did.                是的，我去过。  \nNo, I didn&apos;t.            没，我没去过。\n</code></pre><p><strong><em>开放式问题一般更利于推动对话。它们让和你对话的人可以自由回答，回答方法也有多种。开放式问题主要分为两种：描述性问题和意见性问题。</em></strong></p>\n<p>描述性问题</p>\n<pre><code>What was it like?    （它什么样子？）\nWhat was the wedding like?    婚礼是什么样子？\nWhat did he look like?    他长什么样？\n</code></pre><p>意见性问题</p>\n<pre><code>How did you like Beijing?    你有多喜欢北京？\nHow was your vacation?    你的假期怎么样？\nHow was Russia?    （俄罗斯怎么样？）\n</code></pre><p>语言点：谨慎使用单词 like，该词有两种不同的意思。</p>\n<pre><code>描述： What was it like?    （它是什么样子？）\n观点： How did you like it?    （你有多喜欢它？）\n</code></pre><h2 id=\"3-1（谈论你的周末）\"><a href=\"#3-1（谈论你的周末）\" class=\"headerlink\" title=\"3-1（谈论你的周末）\"></a>3-1（谈论你的周末）</h2><h3 id=\"1-词汇-1\"><a href=\"#1-词汇-1\" class=\"headerlink\" title=\"1. 词汇\"></a>1. 词汇</h3><pre><code>I ate some spaghetti.\nWe drove to Las Vegas.\nThey did yoga.\nShe brought a gift.\nI went jogging\nto cut a long story short  长话短说\n</code></pre><h3 id=\"2-语法-1\"><a href=\"#2-语法-1\" class=\"headerlink\" title=\"2. 语法\"></a>2. 语法</h3><p>不规则动词过去时态</p>\n<pre><code>go - went              去                                                            \neat - ate              吃\nbring - brought      带来\nleave - left        离开\nsell - sold         卖                    \nmake - made            做\nrise - rose         上升\nget - got            得到\ncut - cut           切割\nlet - let             让\nshut - shut            关闭\nread - read         读\n</code></pre><h3 id=\"3-口语\"><a href=\"#3-口语\" class=\"headerlink\" title=\"3. 口语\"></a>3. 口语</h3><pre><code>How are you doing?     你还好吗？\nHow are you today?  你今天怎么样？\nWhat&apos;s up?            你好吗？\nWhat&apos;s happening?    在忙什么呢？\nWhat&apos;s going on?     发生什么事了？\nHow was your weekend?    你周末过得怎么样？\n</code></pre><p>如果没有想要谈论的话题，问候完后你可以使用一个常见的一般性问题。</p>\n<pre><code>How are you doing?     你还好吗？\nHow are you today?      你今天怎么样？\nWhat&apos;s up?    你好吗？\nWhat&apos;s happening?    在忙什么呢？\nWhat&apos;s going on?     发生什么事了？\nHow was your weekend?    你周末过得怎么样？\n</code></pre><p>你可以向你认识的人询问他们的生活。</p>\n<pre><code>How was Peru?     秘鲁怎么样？\nHow is your mom feeling?     你妈妈感觉怎么样？\n</code></pre><p>在有些场合，你会有一个你想讨论的话题。你可以提出陈述，然后听众会对你的陈述发表意见。 </p>\n<pre><code>A: Hey, there was a great movie on last night.\nB: Really? What was it?     嗨，昨天晚上的电影很好看。\n真的吗？什么电影？\nA: That was a great game last night!\nB: Yeah, it was really exciting!     昨天晚上的比赛非常精彩！\n是啊，真的令人兴奋！\n</code></pre><h3 id=\"4-表达\"><a href=\"#4-表达\" class=\"headerlink\" title=\"4. 表达\"></a>4. 表达</h3><p>对话从一个话题转到另一个话题，有一些表达可以帮助人们暗示他们要改变话题。</p>\n<font color=\"red\">‘By the way’</font>\n\n<p>使用表达 by the way 来引入新话题，它也表示你刚想起了某事。</p>\n<pre><code>A: By the way, I saw Joe last night. He looked good.\nB: Really? I&apos;m so glad!    对了，我昨天晚上见到 Joe 了。他气色看起来不错。\n真的吗？我非常高兴！\n</code></pre><font color=\"red\">‘That reminds me’</font>\n\n<p>当你想起了想说的其他事情，使用 that reminds me 来转变话题。 </p>\n<pre><code>A: There was a great baseball game on TV last night.\nB: Oh, that reminds me. I have two tickets to tonight&apos;s game. Do you want to go?\nA: Yeah!    昨天晚上电视上有一场精彩的棒球比赛。\n哦，我想起来了。我有两张今天晚上比赛的票。你想去吗？\n是啊！\n</code></pre><font color=\"red\">‘Anyway’</font>\n\n<p>使用单词 anyway 来结束或总结话题，这样一来你可以开始一个新话题。当你听厌了某人谈论某事，非常想改变话题时，就可以使用这个词。</p>\n<pre><code>A: That restaurant wasn&apos;t very good.\nB: No, it wasn&apos;t! The meat tasted bad, and the salad wasn&apos;t fresh. And the waiter was awful! His clothes were dirty!\nA: Anyway, we&apos;re not going there again. So, how&apos;s Jane?    那家餐馆不是很好。\n是啊，不怎么好！肉有味道，沙拉也不新鲜。而且服务员也很差劲！他的衣服很脏！\n总之，我们不打算再去了。对了，Jane 还好吧？\n</code></pre>","site":{"data":{}},"excerpt":"<blockquote>\n<p>4-unit-3，加入英孚，整理每个单元所学的重点词汇，语法，句子，以及各种阅读技巧和英语听力，汇总各个场合的口语。</p>\n</blockquote>","more":"<h2 id=\"3-1（询问别人一周的情况）\"><a href=\"#3-1（询问别人一周的情况）\" class=\"headerlink\" title=\"3-1（询问别人一周的情况）\"></a>3-1（询问别人一周的情况）</h2><h3 id=\"1-词汇\"><a href=\"#1-词汇\" class=\"headerlink\" title=\"1. 词汇\"></a>1. 词汇</h3><pre><code>I ironed my clothes.   我熨了衣服。\nI had a job interview. 我参加了一次工作面试。\n</code></pre><h3 id=\"2-语法\"><a href=\"#2-语法\" class=\"headerlink\" title=\"2. 语法\"></a>2. 语法</h3><p>许多动词过去时只用在动词词尾添加 -ed 即可。 </p>\n<pre><code>walk - walked\nclean - cleaned   \n</code></pre><p>不规则动词 </p>\n<pre><code>have - had\nmake - made\neat - ate\ndrink - drank\nlet - let      \n</code></pre><p>be 动词的过去时否定式为 was not 和 were not，对应的缩写形式分别为 wasn’t 和 weren’t。</p>\n<pre><code>Frank was not happy in Los Angeles. &gt; Frank wasn&apos;t happy in Los Angeles.         Frank 以前在洛杉矶过得不开心。\n\nOscar and Pam were not at home yesterday. &gt; Oscar and Pam weren&apos;t at home yesterday.         Oscar 和 Pam 昨天不在家。\n</code></pre><p>在句首使用单词 did 来形成过去时疑问句。did 后使用主要动词的原形。不得在动词词尾后加 s。</p>\n<pre><code>Did he go to Shanghai?                 他去上海了吗？\nDid they eat dinner?                他们吃了吗？\n</code></pre><p>要使用 be 动词组成过去时疑问句，请将 was 或 were 置于问句之首。 </p>\n<pre><code>陈述句：  He was happy.         他以前很开心。\n疑问句：  Was he happy?     他以前很开心吗？\n</code></pre><h3 id=\"3-表达\"><a href=\"#3-表达\" class=\"headerlink\" title=\"3. 表达\"></a>3. 表达</h3><p>使用下列表达来谈论过去的事情。</p>\n<font color=\"red\">‘Yesterday’</font>\n\n<pre><code>I visited Carol yesterday.    我昨天拜访了 Carol。\n &apos;The day before yesterday&apos;     \nJack and Nancy got back from Mexico the day before yesterday.    Jack 和 Nancy 前天从墨西哥回来了。\n</code></pre><font color=\"red\">数字 + 时间单词 + ago</font>\n\n<pre><code>We went to that new restaurant two days ago.    我们两天前去了那家新餐馆。\n</code></pre><font color=\"red\">last + 时间单词</font>\n\n<pre><code>I worked at a supermarket last year.    我去年在一家超市上班。\n</code></pre><p><strong><em> 开放式问题和封闭式问题 </em></strong></p>\n<p>开放式问题是指答案不止一个的问题。比如，How was Paris? 有多种可能的回答。</p>\n<pre><code>How was Paris?        巴黎怎么样？\nIt was great!        太棒了！\nIt was terrible.    很差。\nWe loved it.        我们很喜欢。\nWe hated it.        我们很讨厌。\n</code></pre><p><strong><em>封闭式问题则只有肯定和否定两种回答：yes 或 no。</em></strong></p>\n<pre><code>Did you go to Paris?    你去过巴黎吗？\nYes, I did.                是的，我去过。  \nNo, I didn&apos;t.            没，我没去过。\n</code></pre><p><strong><em>开放式问题一般更利于推动对话。它们让和你对话的人可以自由回答，回答方法也有多种。开放式问题主要分为两种：描述性问题和意见性问题。</em></strong></p>\n<p>描述性问题</p>\n<pre><code>What was it like?    （它什么样子？）\nWhat was the wedding like?    婚礼是什么样子？\nWhat did he look like?    他长什么样？\n</code></pre><p>意见性问题</p>\n<pre><code>How did you like Beijing?    你有多喜欢北京？\nHow was your vacation?    你的假期怎么样？\nHow was Russia?    （俄罗斯怎么样？）\n</code></pre><p>语言点：谨慎使用单词 like，该词有两种不同的意思。</p>\n<pre><code>描述： What was it like?    （它是什么样子？）\n观点： How did you like it?    （你有多喜欢它？）\n</code></pre><h2 id=\"3-1（谈论你的周末）\"><a href=\"#3-1（谈论你的周末）\" class=\"headerlink\" title=\"3-1（谈论你的周末）\"></a>3-1（谈论你的周末）</h2><h3 id=\"1-词汇-1\"><a href=\"#1-词汇-1\" class=\"headerlink\" title=\"1. 词汇\"></a>1. 词汇</h3><pre><code>I ate some spaghetti.\nWe drove to Las Vegas.\nThey did yoga.\nShe brought a gift.\nI went jogging\nto cut a long story short  长话短说\n</code></pre><h3 id=\"2-语法-1\"><a href=\"#2-语法-1\" class=\"headerlink\" title=\"2. 语法\"></a>2. 语法</h3><p>不规则动词过去时态</p>\n<pre><code>go - went              去                                                            \neat - ate              吃\nbring - brought      带来\nleave - left        离开\nsell - sold         卖                    \nmake - made            做\nrise - rose         上升\nget - got            得到\ncut - cut           切割\nlet - let             让\nshut - shut            关闭\nread - read         读\n</code></pre><h3 id=\"3-口语\"><a href=\"#3-口语\" class=\"headerlink\" title=\"3. 口语\"></a>3. 口语</h3><pre><code>How are you doing?     你还好吗？\nHow are you today?  你今天怎么样？\nWhat&apos;s up?            你好吗？\nWhat&apos;s happening?    在忙什么呢？\nWhat&apos;s going on?     发生什么事了？\nHow was your weekend?    你周末过得怎么样？\n</code></pre><p>如果没有想要谈论的话题，问候完后你可以使用一个常见的一般性问题。</p>\n<pre><code>How are you doing?     你还好吗？\nHow are you today?      你今天怎么样？\nWhat&apos;s up?    你好吗？\nWhat&apos;s happening?    在忙什么呢？\nWhat&apos;s going on?     发生什么事了？\nHow was your weekend?    你周末过得怎么样？\n</code></pre><p>你可以向你认识的人询问他们的生活。</p>\n<pre><code>How was Peru?     秘鲁怎么样？\nHow is your mom feeling?     你妈妈感觉怎么样？\n</code></pre><p>在有些场合，你会有一个你想讨论的话题。你可以提出陈述，然后听众会对你的陈述发表意见。 </p>\n<pre><code>A: Hey, there was a great movie on last night.\nB: Really? What was it?     嗨，昨天晚上的电影很好看。\n真的吗？什么电影？\nA: That was a great game last night!\nB: Yeah, it was really exciting!     昨天晚上的比赛非常精彩！\n是啊，真的令人兴奋！\n</code></pre><h3 id=\"4-表达\"><a href=\"#4-表达\" class=\"headerlink\" title=\"4. 表达\"></a>4. 表达</h3><p>对话从一个话题转到另一个话题，有一些表达可以帮助人们暗示他们要改变话题。</p>\n<font color=\"red\">‘By the way’</font>\n\n<p>使用表达 by the way 来引入新话题，它也表示你刚想起了某事。</p>\n<pre><code>A: By the way, I saw Joe last night. He looked good.\nB: Really? I&apos;m so glad!    对了，我昨天晚上见到 Joe 了。他气色看起来不错。\n真的吗？我非常高兴！\n</code></pre><font color=\"red\">‘That reminds me’</font>\n\n<p>当你想起了想说的其他事情，使用 that reminds me 来转变话题。 </p>\n<pre><code>A: There was a great baseball game on TV last night.\nB: Oh, that reminds me. I have two tickets to tonight&apos;s game. Do you want to go?\nA: Yeah!    昨天晚上电视上有一场精彩的棒球比赛。\n哦，我想起来了。我有两张今天晚上比赛的票。你想去吗？\n是啊！\n</code></pre><font color=\"red\">‘Anyway’</font>\n\n<p>使用单词 anyway 来结束或总结话题，这样一来你可以开始一个新话题。当你听厌了某人谈论某事，非常想改变话题时，就可以使用这个词。</p>\n<pre><code>A: That restaurant wasn&apos;t very good.\nB: No, it wasn&apos;t! The meat tasted bad, and the salad wasn&apos;t fresh. And the waiter was awful! His clothes were dirty!\nA: Anyway, we&apos;re not going there again. So, how&apos;s Jane?    那家餐馆不是很好。\n是啊，不怎么好！肉有味道，沙拉也不新鲜。而且服务员也很差劲！他的衣服很脏！\n总之，我们不打算再去了。对了，Jane 还好吧？\n</code></pre>"},{"title":"定语","date":"2017-12-26T06:55:58.000Z","_content":"\n> 定语是用来修饰、限定、说明名词或代词的品质与特征的。 主要有形容词，此外还有名词、代词、数词、介词短语、动词不定式（短语）、分词、定语从句或相当于形容词的词、短语或句子都可以作定语。\n\n<!-- more -->\n\n 汉语中常用‘……的’表示，定语的位置一般有两种：用在所修饰词之前的叫前置定语(单词作定语)，用在所修饰词之后的叫后置定语(短语和从句作定语)，定语和中心语之间是修饰和被修饰、限制和被限制的关系。\n\n### 定语的位置\n\n > 定语前置：一般定语前置时的次序为：限定词，形容词、分词、动名词和名词性定语。但当几个形容词同时出现在名词短语之前，我们要注意其次序\n\n 限定词（一般指数量）；外观（美丽等）；形状（大小，高矮，肥瘦）；年龄；颜色；国籍；材料；用途。\n\n 1限定词 2 外观 3形状 4年龄 5颜色 6国籍 7材料 8用途\n　a famous American university\n　an interesting little red French oil painting\n　a new plastic bucket\n　a purple velvet curtains\n　an elegant German clock\n\n* 特殊形容词的特殊顺序，身体特征>情感和性格特征>颜色，little,old 和young 有时可以作为名词短语不可分割的一部分，所以可以直接放在名词之前，例如：a lovely little girl，表示性格特征的形容词可以放在old young 之前，也可放在old young 之后，例如：a young ambitious man （强调年龄），an ambitious young man（强调雄心勃勃）。\n\n* 数词作定语相当于形容词：Two boys need two pens.\n\n* 代词或名词所有格作定语：His son needs Tom's pen.（his为定语，修饰名词son；Tom’s为定语，修饰名词pen）\n\n> 定语后置\n\n* 短语作定语一般后置\n    * English is a language easy to learn but difficult to master. \n* 修饰some，any，no，every等词构成的不定代词的定语都后置\n    * There is nothing important in today's newspaper.\n* 副词做定语\n    * They lived in the room above.他们住在楼上的房间。\n* 动词、名词转化而来的以-able,-ible 结尾的形容词作定语\n    * He is a person dependable. 他是一个可以依靠的人\n* 起强调作用的单个分词\n    * Everybody involved should stay here.\n\n### 不同词性的定语\n\n* 介词短语定语\n    The boy in the classroom needs a pen of yours.（in the classroom 为定语，修饰名词boy；of yours为定语，修饰名词pen）/教室里的男孩需要你的一支钢笔。\n* 形容词定语\n    所有的形容词，只要后面加名词，都是定语\n* 名词定语 \n    The boy needs a ball pen.（ball为定语，修饰名词pen）/男孩需要一支圆珠笔。\n* 副词定语\n    The boy there needs a pen.（there为定语，修饰名词boy）/那儿的男孩需要一支钢笔。\n* 不定式定语\n    The boy to write this letter needs a pen.（ to write this letter 为定语，修饰名词boy）/写这封信的男孩需要一支钢笔。\n* 分词（短语）定语\n    The smiling boy needs a pen bought by his mother.（ smiling为定语， 修饰名词boy；bought by his mother为定语，修饰名词pen）/那个微笑的男孩需要一支他妈妈买的钢笔。\n    The pen bought by her is made in China.（bought by her 为定语，修饰名词pen）/她买的笔是中国产的。\n    There are five boys left.（five为定语，修饰名词boy；left为定语，修饰名词boy）/有五个留下的男孩。\n\n### 定语从句\n\n> 定语从句即指在主从复合句用作定语的从句。定语从句通常修饰名词或代词，对它进行限制、描绘和说明。受定语从句修饰的词语叫先行词，引导定语从句的词语叫关系词。关系词按其性质又分关系代词和关系副词。根据从句与主句关系的紧密程度，定语从句又分为限制性定语从句和非限制性定语从句。\n\n关系代词有：who,whom,whose,that,which等。\n关系副词有：when,where,why等。\n\n关系代词引导的定语从句\n\n关系代词所代替的先行词是人或物的名词或代词，并在句中充当主语、宾语、定语等成分。关系代词在定语从句中作主语时，从句谓语动词的人称和数要和先行词保持一致。\n1）who,whom,that\n　　这些词代替的先行词是人的名词或代词，在从句中所起作用如下：\n　　Is he the man （who/that） wants to see you？\n　　他就是想见你的那个人吗？（who/that在从句中作主语）\n　　He is the man （whom/ that ）I saw yesterday.\n　　他就是我昨天见的那个人。（whom/that在从句中作宾语）\n2）Whose 用来指人或物，（只用作定语，若指物，它还可以同of which互换），例如：\n　　They rushed over to help the man whose car had broken down.　 那人车坏了，大家都跑过去帮忙。\n　　Please pass me the book whose (of which) cover is green.　请递给我那本绿皮的书。\n3）which,that\n　　它们所代替的先行词是事物的名词或代词，在从句中可作主语、宾语等，例如：\n　　A prosperity which / that had never been seen before appears in the countryside. 农村出现了前所未有的繁荣。（which / that在句中作主语）\n　　The package (which / that) you are carrying is about to come unwrapped. 你拿的包快散了。（which / that在句中作宾语）","source":"_posts/英语/定语.md","raw":"---\ntitle: 定语\ndate: 2017-12-26 14:55:58\ncategories:\n- 英语\ntags: 英语\n---\n\n> 定语是用来修饰、限定、说明名词或代词的品质与特征的。 主要有形容词，此外还有名词、代词、数词、介词短语、动词不定式（短语）、分词、定语从句或相当于形容词的词、短语或句子都可以作定语。\n\n<!-- more -->\n\n 汉语中常用‘……的’表示，定语的位置一般有两种：用在所修饰词之前的叫前置定语(单词作定语)，用在所修饰词之后的叫后置定语(短语和从句作定语)，定语和中心语之间是修饰和被修饰、限制和被限制的关系。\n\n### 定语的位置\n\n > 定语前置：一般定语前置时的次序为：限定词，形容词、分词、动名词和名词性定语。但当几个形容词同时出现在名词短语之前，我们要注意其次序\n\n 限定词（一般指数量）；外观（美丽等）；形状（大小，高矮，肥瘦）；年龄；颜色；国籍；材料；用途。\n\n 1限定词 2 外观 3形状 4年龄 5颜色 6国籍 7材料 8用途\n　a famous American university\n　an interesting little red French oil painting\n　a new plastic bucket\n　a purple velvet curtains\n　an elegant German clock\n\n* 特殊形容词的特殊顺序，身体特征>情感和性格特征>颜色，little,old 和young 有时可以作为名词短语不可分割的一部分，所以可以直接放在名词之前，例如：a lovely little girl，表示性格特征的形容词可以放在old young 之前，也可放在old young 之后，例如：a young ambitious man （强调年龄），an ambitious young man（强调雄心勃勃）。\n\n* 数词作定语相当于形容词：Two boys need two pens.\n\n* 代词或名词所有格作定语：His son needs Tom's pen.（his为定语，修饰名词son；Tom’s为定语，修饰名词pen）\n\n> 定语后置\n\n* 短语作定语一般后置\n    * English is a language easy to learn but difficult to master. \n* 修饰some，any，no，every等词构成的不定代词的定语都后置\n    * There is nothing important in today's newspaper.\n* 副词做定语\n    * They lived in the room above.他们住在楼上的房间。\n* 动词、名词转化而来的以-able,-ible 结尾的形容词作定语\n    * He is a person dependable. 他是一个可以依靠的人\n* 起强调作用的单个分词\n    * Everybody involved should stay here.\n\n### 不同词性的定语\n\n* 介词短语定语\n    The boy in the classroom needs a pen of yours.（in the classroom 为定语，修饰名词boy；of yours为定语，修饰名词pen）/教室里的男孩需要你的一支钢笔。\n* 形容词定语\n    所有的形容词，只要后面加名词，都是定语\n* 名词定语 \n    The boy needs a ball pen.（ball为定语，修饰名词pen）/男孩需要一支圆珠笔。\n* 副词定语\n    The boy there needs a pen.（there为定语，修饰名词boy）/那儿的男孩需要一支钢笔。\n* 不定式定语\n    The boy to write this letter needs a pen.（ to write this letter 为定语，修饰名词boy）/写这封信的男孩需要一支钢笔。\n* 分词（短语）定语\n    The smiling boy needs a pen bought by his mother.（ smiling为定语， 修饰名词boy；bought by his mother为定语，修饰名词pen）/那个微笑的男孩需要一支他妈妈买的钢笔。\n    The pen bought by her is made in China.（bought by her 为定语，修饰名词pen）/她买的笔是中国产的。\n    There are five boys left.（five为定语，修饰名词boy；left为定语，修饰名词boy）/有五个留下的男孩。\n\n### 定语从句\n\n> 定语从句即指在主从复合句用作定语的从句。定语从句通常修饰名词或代词，对它进行限制、描绘和说明。受定语从句修饰的词语叫先行词，引导定语从句的词语叫关系词。关系词按其性质又分关系代词和关系副词。根据从句与主句关系的紧密程度，定语从句又分为限制性定语从句和非限制性定语从句。\n\n关系代词有：who,whom,whose,that,which等。\n关系副词有：when,where,why等。\n\n关系代词引导的定语从句\n\n关系代词所代替的先行词是人或物的名词或代词，并在句中充当主语、宾语、定语等成分。关系代词在定语从句中作主语时，从句谓语动词的人称和数要和先行词保持一致。\n1）who,whom,that\n　　这些词代替的先行词是人的名词或代词，在从句中所起作用如下：\n　　Is he the man （who/that） wants to see you？\n　　他就是想见你的那个人吗？（who/that在从句中作主语）\n　　He is the man （whom/ that ）I saw yesterday.\n　　他就是我昨天见的那个人。（whom/that在从句中作宾语）\n2）Whose 用来指人或物，（只用作定语，若指物，它还可以同of which互换），例如：\n　　They rushed over to help the man whose car had broken down.　 那人车坏了，大家都跑过去帮忙。\n　　Please pass me the book whose (of which) cover is green.　请递给我那本绿皮的书。\n3）which,that\n　　它们所代替的先行词是事物的名词或代词，在从句中可作主语、宾语等，例如：\n　　A prosperity which / that had never been seen before appears in the countryside. 农村出现了前所未有的繁荣。（which / that在句中作主语）\n　　The package (which / that) you are carrying is about to come unwrapped. 你拿的包快散了。（which / that在句中作宾语）","slug":"英语/定语","published":1,"updated":"2018-05-31T10:27:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3dj000suox117gum2d7","content":"<blockquote>\n<p>定语是用来修饰、限定、说明名词或代词的品质与特征的。 主要有形容词，此外还有名词、代词、数词、介词短语、动词不定式（短语）、分词、定语从句或相当于形容词的词、短语或句子都可以作定语。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p> 汉语中常用‘……的’表示，定语的位置一般有两种：用在所修饰词之前的叫前置定语(单词作定语)，用在所修饰词之后的叫后置定语(短语和从句作定语)，定语和中心语之间是修饰和被修饰、限制和被限制的关系。</p>\n<h3 id=\"定语的位置\"><a href=\"#定语的位置\" class=\"headerlink\" title=\"定语的位置\"></a>定语的位置</h3><blockquote>\n<p>定语前置：一般定语前置时的次序为：限定词，形容词、分词、动名词和名词性定语。但当几个形容词同时出现在名词短语之前，我们要注意其次序</p>\n</blockquote>\n<p> 限定词（一般指数量）；外观（美丽等）；形状（大小，高矮，肥瘦）；年龄；颜色；国籍；材料；用途。</p>\n<p> 1限定词 2 外观 3形状 4年龄 5颜色 6国籍 7材料 8用途<br>　a famous American university<br>　an interesting little red French oil painting<br>　a new plastic bucket<br>　a purple velvet curtains<br>　an elegant German clock</p>\n<ul>\n<li><p>特殊形容词的特殊顺序，身体特征&gt;情感和性格特征&gt;颜色，little,old 和young 有时可以作为名词短语不可分割的一部分，所以可以直接放在名词之前，例如：a lovely little girl，表示性格特征的形容词可以放在old young 之前，也可放在old young 之后，例如：a young ambitious man （强调年龄），an ambitious young man（强调雄心勃勃）。</p>\n</li>\n<li><p>数词作定语相当于形容词：Two boys need two pens.</p>\n</li>\n<li><p>代词或名词所有格作定语：His son needs Tom’s pen.（his为定语，修饰名词son；Tom’s为定语，修饰名词pen）</p>\n</li>\n</ul>\n<blockquote>\n<p>定语后置</p>\n</blockquote>\n<ul>\n<li>短语作定语一般后置<ul>\n<li>English is a language easy to learn but difficult to master. </li>\n</ul>\n</li>\n<li>修饰some，any，no，every等词构成的不定代词的定语都后置<ul>\n<li>There is nothing important in today’s newspaper.</li>\n</ul>\n</li>\n<li>副词做定语<ul>\n<li>They lived in the room above.他们住在楼上的房间。</li>\n</ul>\n</li>\n<li>动词、名词转化而来的以-able,-ible 结尾的形容词作定语<ul>\n<li>He is a person dependable. 他是一个可以依靠的人</li>\n</ul>\n</li>\n<li>起强调作用的单个分词<ul>\n<li>Everybody involved should stay here.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"不同词性的定语\"><a href=\"#不同词性的定语\" class=\"headerlink\" title=\"不同词性的定语\"></a>不同词性的定语</h3><ul>\n<li>介词短语定语<br>  The boy in the classroom needs a pen of yours.（in the classroom 为定语，修饰名词boy；of yours为定语，修饰名词pen）/教室里的男孩需要你的一支钢笔。</li>\n<li>形容词定语<br>  所有的形容词，只要后面加名词，都是定语</li>\n<li>名词定语<br>  The boy needs a ball pen.（ball为定语，修饰名词pen）/男孩需要一支圆珠笔。</li>\n<li>副词定语<br>  The boy there needs a pen.（there为定语，修饰名词boy）/那儿的男孩需要一支钢笔。</li>\n<li>不定式定语<br>  The boy to write this letter needs a pen.（ to write this letter 为定语，修饰名词boy）/写这封信的男孩需要一支钢笔。</li>\n<li>分词（短语）定语<br>  The smiling boy needs a pen bought by his mother.（ smiling为定语， 修饰名词boy；bought by his mother为定语，修饰名词pen）/那个微笑的男孩需要一支他妈妈买的钢笔。<br>  The pen bought by her is made in China.（bought by her 为定语，修饰名词pen）/她买的笔是中国产的。<br>  There are five boys left.（five为定语，修饰名词boy；left为定语，修饰名词boy）/有五个留下的男孩。</li>\n</ul>\n<h3 id=\"定语从句\"><a href=\"#定语从句\" class=\"headerlink\" title=\"定语从句\"></a>定语从句</h3><blockquote>\n<p>定语从句即指在主从复合句用作定语的从句。定语从句通常修饰名词或代词，对它进行限制、描绘和说明。受定语从句修饰的词语叫先行词，引导定语从句的词语叫关系词。关系词按其性质又分关系代词和关系副词。根据从句与主句关系的紧密程度，定语从句又分为限制性定语从句和非限制性定语从句。</p>\n</blockquote>\n<p>关系代词有：who,whom,whose,that,which等。<br>关系副词有：when,where,why等。</p>\n<p>关系代词引导的定语从句</p>\n<p>关系代词所代替的先行词是人或物的名词或代词，并在句中充当主语、宾语、定语等成分。关系代词在定语从句中作主语时，从句谓语动词的人称和数要和先行词保持一致。<br>1）who,whom,that<br>　　这些词代替的先行词是人的名词或代词，在从句中所起作用如下：<br>　　Is he the man （who/that） wants to see you？<br>　　他就是想见你的那个人吗？（who/that在从句中作主语）<br>　　He is the man （whom/ that ）I saw yesterday.<br>　　他就是我昨天见的那个人。（whom/that在从句中作宾语）<br>2）Whose 用来指人或物，（只用作定语，若指物，它还可以同of which互换），例如：<br>　　They rushed over to help the man whose car had broken down.　 那人车坏了，大家都跑过去帮忙。<br>　　Please pass me the book whose (of which) cover is green.　请递给我那本绿皮的书。<br>3）which,that<br>　　它们所代替的先行词是事物的名词或代词，在从句中可作主语、宾语等，例如：<br>　　A prosperity which / that had never been seen before appears in the countryside. 农村出现了前所未有的繁荣。（which / that在句中作主语）<br>　　The package (which / that) you are carrying is about to come unwrapped. 你拿的包快散了。（which / that在句中作宾语）</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>定语是用来修饰、限定、说明名词或代词的品质与特征的。 主要有形容词，此外还有名词、代词、数词、介词短语、动词不定式（短语）、分词、定语从句或相当于形容词的词、短语或句子都可以作定语。</p>\n</blockquote>","more":"<p> 汉语中常用‘……的’表示，定语的位置一般有两种：用在所修饰词之前的叫前置定语(单词作定语)，用在所修饰词之后的叫后置定语(短语和从句作定语)，定语和中心语之间是修饰和被修饰、限制和被限制的关系。</p>\n<h3 id=\"定语的位置\"><a href=\"#定语的位置\" class=\"headerlink\" title=\"定语的位置\"></a>定语的位置</h3><blockquote>\n<p>定语前置：一般定语前置时的次序为：限定词，形容词、分词、动名词和名词性定语。但当几个形容词同时出现在名词短语之前，我们要注意其次序</p>\n</blockquote>\n<p> 限定词（一般指数量）；外观（美丽等）；形状（大小，高矮，肥瘦）；年龄；颜色；国籍；材料；用途。</p>\n<p> 1限定词 2 外观 3形状 4年龄 5颜色 6国籍 7材料 8用途<br>　a famous American university<br>　an interesting little red French oil painting<br>　a new plastic bucket<br>　a purple velvet curtains<br>　an elegant German clock</p>\n<ul>\n<li><p>特殊形容词的特殊顺序，身体特征&gt;情感和性格特征&gt;颜色，little,old 和young 有时可以作为名词短语不可分割的一部分，所以可以直接放在名词之前，例如：a lovely little girl，表示性格特征的形容词可以放在old young 之前，也可放在old young 之后，例如：a young ambitious man （强调年龄），an ambitious young man（强调雄心勃勃）。</p>\n</li>\n<li><p>数词作定语相当于形容词：Two boys need two pens.</p>\n</li>\n<li><p>代词或名词所有格作定语：His son needs Tom’s pen.（his为定语，修饰名词son；Tom’s为定语，修饰名词pen）</p>\n</li>\n</ul>\n<blockquote>\n<p>定语后置</p>\n</blockquote>\n<ul>\n<li>短语作定语一般后置<ul>\n<li>English is a language easy to learn but difficult to master. </li>\n</ul>\n</li>\n<li>修饰some，any，no，every等词构成的不定代词的定语都后置<ul>\n<li>There is nothing important in today’s newspaper.</li>\n</ul>\n</li>\n<li>副词做定语<ul>\n<li>They lived in the room above.他们住在楼上的房间。</li>\n</ul>\n</li>\n<li>动词、名词转化而来的以-able,-ible 结尾的形容词作定语<ul>\n<li>He is a person dependable. 他是一个可以依靠的人</li>\n</ul>\n</li>\n<li>起强调作用的单个分词<ul>\n<li>Everybody involved should stay here.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"不同词性的定语\"><a href=\"#不同词性的定语\" class=\"headerlink\" title=\"不同词性的定语\"></a>不同词性的定语</h3><ul>\n<li>介词短语定语<br>  The boy in the classroom needs a pen of yours.（in the classroom 为定语，修饰名词boy；of yours为定语，修饰名词pen）/教室里的男孩需要你的一支钢笔。</li>\n<li>形容词定语<br>  所有的形容词，只要后面加名词，都是定语</li>\n<li>名词定语<br>  The boy needs a ball pen.（ball为定语，修饰名词pen）/男孩需要一支圆珠笔。</li>\n<li>副词定语<br>  The boy there needs a pen.（there为定语，修饰名词boy）/那儿的男孩需要一支钢笔。</li>\n<li>不定式定语<br>  The boy to write this letter needs a pen.（ to write this letter 为定语，修饰名词boy）/写这封信的男孩需要一支钢笔。</li>\n<li>分词（短语）定语<br>  The smiling boy needs a pen bought by his mother.（ smiling为定语， 修饰名词boy；bought by his mother为定语，修饰名词pen）/那个微笑的男孩需要一支他妈妈买的钢笔。<br>  The pen bought by her is made in China.（bought by her 为定语，修饰名词pen）/她买的笔是中国产的。<br>  There are five boys left.（five为定语，修饰名词boy；left为定语，修饰名词boy）/有五个留下的男孩。</li>\n</ul>\n<h3 id=\"定语从句\"><a href=\"#定语从句\" class=\"headerlink\" title=\"定语从句\"></a>定语从句</h3><blockquote>\n<p>定语从句即指在主从复合句用作定语的从句。定语从句通常修饰名词或代词，对它进行限制、描绘和说明。受定语从句修饰的词语叫先行词，引导定语从句的词语叫关系词。关系词按其性质又分关系代词和关系副词。根据从句与主句关系的紧密程度，定语从句又分为限制性定语从句和非限制性定语从句。</p>\n</blockquote>\n<p>关系代词有：who,whom,whose,that,which等。<br>关系副词有：when,where,why等。</p>\n<p>关系代词引导的定语从句</p>\n<p>关系代词所代替的先行词是人或物的名词或代词，并在句中充当主语、宾语、定语等成分。关系代词在定语从句中作主语时，从句谓语动词的人称和数要和先行词保持一致。<br>1）who,whom,that<br>　　这些词代替的先行词是人的名词或代词，在从句中所起作用如下：<br>　　Is he the man （who/that） wants to see you？<br>　　他就是想见你的那个人吗？（who/that在从句中作主语）<br>　　He is the man （whom/ that ）I saw yesterday.<br>　　他就是我昨天见的那个人。（whom/that在从句中作宾语）<br>2）Whose 用来指人或物，（只用作定语，若指物，它还可以同of which互换），例如：<br>　　They rushed over to help the man whose car had broken down.　 那人车坏了，大家都跑过去帮忙。<br>　　Please pass me the book whose (of which) cover is green.　请递给我那本绿皮的书。<br>3）which,that<br>　　它们所代替的先行词是事物的名词或代词，在从句中可作主语、宾语等，例如：<br>　　A prosperity which / that had never been seen before appears in the countryside. 农村出现了前所未有的繁荣。（which / that在句中作主语）<br>　　The package (which / that) you are carrying is about to come unwrapped. 你拿的包快散了。（which / that在句中作宾语）</p>"},{"title":"音标学习","date":"2017-12-22T06:20:58.000Z","_content":"\n> 音标是英语最小的语音单位。最新版的英语音标表共48个英语音标，其中20个元音音标，28个辅音音标。\n\n元音的发音特点是气流通过口腔时，不受任何阻碍，声带振动。学习元音时，最主要的是掌握舌、唇、牙床三者的位置。\n\n辅音的发音特点是气流通过口腔或鼻腔时，受到舌、唇、齿等发音器官的阻碍。发音时声带不振动的是清辅音；声带振动的是浊辅音。发辅音时，要注意不可加入元音成分。\n\n\n\n\n","source":"_posts/英语/音标.md","raw":"---\ntitle: 音标学习\ndate: 2017-12-22 14:20:58\ncategories:\n- 英语\ntags: 英语\n---\n\n> 音标是英语最小的语音单位。最新版的英语音标表共48个英语音标，其中20个元音音标，28个辅音音标。\n\n元音的发音特点是气流通过口腔时，不受任何阻碍，声带振动。学习元音时，最主要的是掌握舌、唇、牙床三者的位置。\n\n辅音的发音特点是气流通过口腔或鼻腔时，受到舌、唇、齿等发音器官的阻碍。发音时声带不振动的是清辅音；声带振动的是浊辅音。发辅音时，要注意不可加入元音成分。\n\n\n\n\n","slug":"英语/音标","published":1,"updated":"2018-05-31T10:27:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3dk000tuox1gpks3esd","content":"<blockquote>\n<p>音标是英语最小的语音单位。最新版的英语音标表共48个英语音标，其中20个元音音标，28个辅音音标。</p>\n</blockquote>\n<p>元音的发音特点是气流通过口腔时，不受任何阻碍，声带振动。学习元音时，最主要的是掌握舌、唇、牙床三者的位置。</p>\n<p>辅音的发音特点是气流通过口腔或鼻腔时，受到舌、唇、齿等发音器官的阻碍。发音时声带不振动的是清辅音；声带振动的是浊辅音。发辅音时，要注意不可加入元音成分。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>音标是英语最小的语音单位。最新版的英语音标表共48个英语音标，其中20个元音音标，28个辅音音标。</p>\n</blockquote>\n<p>元音的发音特点是气流通过口腔时，不受任何阻碍，声带振动。学习元音时，最主要的是掌握舌、唇、牙床三者的位置。</p>\n<p>辅音的发音特点是气流通过口腔或鼻腔时，受到舌、唇、齿等发音器官的阻碍。发音时声带不振动的是清辅音；声带振动的是浊辅音。发辅音时，要注意不可加入元音成分。</p>\n"},{"title":"英语语法","date":"2017-12-25T07:46:58.000Z","_content":"\n> 英语语法大全，整理语法学习资料\n\n[可可英语语法大全](http://www.kekenet.com/grammar/)\n[英语语法网，语法大全](http://www.yingyuyufa.com/)\n\n\n\n\n","source":"_posts/英语/语法.md","raw":"---\ntitle: 英语语法\ndate: 2017-12-25 15:46:58\ncategories:\n- 英语\ntags: 英语\n---\n\n> 英语语法大全，整理语法学习资料\n\n[可可英语语法大全](http://www.kekenet.com/grammar/)\n[英语语法网，语法大全](http://www.yingyuyufa.com/)\n\n\n\n\n","slug":"英语/语法","published":1,"updated":"2018-05-31T10:27:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3dk000uuox1egg5epjx","content":"<blockquote>\n<p>英语语法大全，整理语法学习资料</p>\n</blockquote>\n<p><a href=\"http://www.kekenet.com/grammar/\" target=\"_blank\" rel=\"noopener\">可可英语语法大全</a><br><a href=\"http://www.yingyuyufa.com/\" target=\"_blank\" rel=\"noopener\">英语语法网，语法大全</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>英语语法大全，整理语法学习资料</p>\n</blockquote>\n<p><a href=\"http://www.kekenet.com/grammar/\" target=\"_blank\" rel=\"noopener\">可可英语语法大全</a><br><a href=\"http://www.yingyuyufa.com/\" target=\"_blank\" rel=\"noopener\">英语语法网，语法大全</a></p>\n"},{"title":"前端框架","date":"2019-02-24T10:51:20.000Z","_content":"\n> 前端三大框架概念区别简总（angular,react,vue）\n\n<!--- more -->\n\n**MVX 框架模式：MVC+MVP+MVVM**\n\n1. MVC：Model+View+controller（M 和 V 的协调者），主要是基于分层的目的，让彼此的职责分开。\n\n   用户 User 通过控制器 Controller 来操作模板 Model 从而达到视图 View 的变化。数据直接从数据库读取\n\n2. MVP：是从 MVC 模式演变而来的，都是通过 Controller/Presenter 负责逻辑的处理+Model 提供数据+View 负责显示。\n\n在 MVP 中，Presenter 完全把 View 和 Model 进行了分离，主要的程序逻辑在 Presenter 里实现。\n并且，Presenter 和 View 是没有直接关联的，是通过定义好的接口进行交互，从而使得在变更 View 的时候可以保持 Presenter 不变。\n\n3. MVVM：MVVM 是把 MVC 里的 Controller 和 MVP 里的 Presenter 改成了 ViewModel。Model+View+ViewModel。\n\n   MVVM 的界面与 viewmodel 是松耦合，界面数据从 viewmodel 中获取\n   View 的变化会自动更新到 ViewModel,ViewModel 的变化也会自动同步到 View 上显示。\n   这种自动同步是因为 ViewModel 中的属性实现了 Observer，当属性变更时都能触发对应的操作。\n\n### 三大框架概述\n\n- vue: 构建用户界面的渐进式、轻量级框架,插件化, 倾向于（html+css+js）,易上手，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染，开发者不需要考虑组件是否需要重新渲染之类的优化。\n\n  ```js\n  //<div id=\"app\">\n  //    <!--html中修改的-->\n  //  <h1>{{message + '这是在outer HTML中的'}}</h1>\n  //</div>\n  var vm = new Vue({\n    el: \"#app\",\n    template: \"<h1>{{message +'这是在template中的'}}</h1>\",\n    //有template 作为模板编译成render函数，优先级高于外部HTML，页面显示\n    render: function(createElement) {\n      return createElement(\"h1\", \"this is createElement\");\n    },\n    // 它是以createElement作为参数，然后做渲染操作，而且我们可以直接嵌入JSX\n    // render函数选项 > template选项 > outer HTML.\n    data: {\n      message: \"Vue的生命周期\"\n    },\n    //  this.$el   this.$data(数据双向绑定的表示)   this.message\n    beforeCreate: function() {\n      // vm实例 创建前状态\n      // 初始化事件，进行数据的观测\n      // this.$el     undefined\n      // this.$data   undefined\n      // this.message undefined\n    },\n    created: function() {\n      //创建完毕状态(已进行数据绑定)\n      // this.$el     undefined\n      // this.$data   [obiect object] 已进行数据绑定\n      // this.message Vue的生命周期\n    },\n    beforeMount: function() {\n      // 挂载前状态\n      // 首先判断对象是否有el选项。如果有的话就继续向下编译，如果没有el选项，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)。\n      //可以看到此时是给vue实例对象添加$el成员，并且替换掉挂在的DOM元素.此时是虚拟dom的形式\n      // this.$el\n      // [object HTMLDivElement]  <div id='app'><h1>{{message}}用此占位</h1></div>\n      // this.$data   [obiect object]\n      // this.message Vue的生命周期\n    },\n    mounted: function() {\n      vm.message = \"触发组件更新\";\n      // 挂载结束状态\n      // this.$el\n      // [object HTMLDivElement]  <div id='app'><h1>Vue的生命周期</h1></div>\n      // this.$data   [obiect object]\n      // this.message Vue的生命周期\n    },\n    beforeUpdate: function() {\n      // 更新前状态 当vue发现data中的数据发生了改变，会触发对应组件的重新渲染\n      // this.$el     [object HTMLDivElement]\n      // this.$data   [obiect object]\n      // this.message Vue的生命周期(此时view层还未改变，但课监听到data的变化)\n    },\n    updated: function() {\n      // 更新完成状态\n      // this.$el     undefined\n      // this.$data   [obiect object] 已进行数据绑定\n      // this.message 触发组件更新\n    },\n    beforeDestroy: function() {\n      // 销毁前状态\n      // 实例销毁之前调用。在这一步，实例仍然完全可用\n    },\n    destroyed: function() {\n      // 销毁完成状态\n      // Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。\n    }\n  });\n  ```\n\n  总结：\n\n  1. **首先创建一个实例，new vue 过程中执行 init（vue 组件默认执行），init 过程中调用 beforeCreate**\n  2. **后在 injections（注射）和 reactivity（反应性）的时候，调用 created，created 完成之后，此时已经完成了双向数据绑定**\n  3. **beforeMount 中，去判断实例里面是否含有“el”选项，若无，调用 vm.$mount(el)方法，若有，去判断是否有“template”，若有，它会把template解析成一个render function，(其实这个hook function中就是相关的render函数被调用，此时$el 还只是我们在 HTML 里面写的节点)，**\n     `render函数选项 > template选项 > outer HTML.（render函数优先级）`\n  4. **之后 mounted，就把渲染出来的内容挂载到了 DOM 节点上**\n  5. **当数据变化的时候，调用 beforeUpdate，经过 Virtual DOM，之后调用 updated 更新 dom，**\n  6. **beforeDestroy，实例销毁之前，这个 hook 实例仍可用**\n  7. **destroyed 实例销毁后调用。实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。**\n\n- react(UI 库): 构建用户界面的 Js 库，JSX 语法，无指令，组件化（state,props），某个组件的状态发生变化时，以该组件为根，重新渲染整个组件子树\n\n```js\nimport React, { Component } from \"react\";\nclass Test extends Component {\n  // 类的构造方法( constructor() )，继承了react Component这个基类，也就继承这个react的基类，才能有render(),生命周期等方法可以使用，这也说明为什么函数组件不能使用这些方法的原因。\n  constructor(props) {\n    //   super(props)用来调用基类的构造方法( constructor() ), 也将父组件的props注入给子组件\n    super(props);\n  }\n  componentWillMount() {\n    // 在组件挂载到DOM前调用，且只会被调用一次，在这边调用this.setState不会引起组件重新渲染，也可以把写在这边的内容提前到constructor()中，所以项目中很少用。\n  }\n\n  componentDidMount() {\n    //   组件挂载到DOM后调用，且只会被调用一次\n  }\n  //   父组件重新render引起子组件重新render的情况有两种，\n  //   1.  每当父组件重新render导致的重传props，子组件将直接跟着重新渲染，无论props是否有变化。可通过shouldComponentUpdate方法优化。\n  // 2. 在componentWillReceiveProps方法中，将props转换成自己的state\n  componentWillReceiveProps(nextProps) {\n    //   此方法只调用于props引起的组件更新过程中，参数nextProps是父组件传给当前组件的新props。但父组件render方法的调用不能保证重传给当前组件的props是有变化的，所以在此方法中根据nextProps和this.props来查明重传的props是否改变，以及如果改变了要执行啥，比如根据新的props调用this.setState出发当前组件的重新render\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    // 应该使用这个方法，否则无论props是否有变化都将会导致组件跟着重新渲染\n    // 此方法通过比较nextProps，nextState及当前组件的this.props，this.state，返回true时当前组件将继续执行更新过程，返回false则当前组件更新停止，以此可用来减少组件的不必要渲染，优化组件性能。\n    if (nextProps.someThings === this.props.someThings) {\n      return false;\n    }\n  }\n  componentWillUpdate(nextProps, nextState) {\n    //   此方法在调用render方法前执行，在这边可执行一些组件更新发生前的工作，一般较少用。\n  }\n  componentDidUpdate(prevProps, prevState) {\n    //   此方法在组件更新后被调用，可以操作组件更新的DOM，prevProps和prevState这两个参数指的是组件更新前的props和state\n  }\n  render() {\n    //   根据组件的props和state，return 一个React元素，不负责组件实际渲染工作，之后由React自身根据此元素去渲染出页面DOM。render是纯函数，不能在里面执行this.setState，会有改变组件状态的副作用。\n    // 反复调用\n  }\n  componentWillUnmount() {\n    //   此方法在组件被卸载前调用，可以在这里执行一些清理工作，比如清楚组件中使用的定时器，清楚componentDidMount中手动创建的DOM元素等，以避免引起内存泄漏。\n  }\n}\n```\n\n只执行一次： constructor、componentWillMount、componentDidMount\n\n执行多次：render 、子组件的 componentWillReceiveProps、componentWillUpdate、componentDidUpdate\n\n有条件的执行：componentWillUnmount（页面离开，组件销毁时）\n\n不执行的：根组件（ReactDOM.render 在 DOM 上的组件）的 componentWillReceiveProps（因为压根没有父组件给传递 props）\n\n- react & vue: 组件化，钩子函数（生命周期），使用 Virtual DOM,不内置 ajax，route 核心包，以插件形式加载\n\n- vue & angular(MVVM): 双向数据绑定,支持指令（内置和自定义指令），内置过滤器和自定义过滤器,不支持低端浏览器\n\n![三大框架](/img/interview/react-ag-vue.png \"三大框架\")\n","source":"_posts/面试/react-vue-angular.md","raw":"---\ntitle: 前端框架\ncategories:\n  - 前端技术\ntags:\n  - 前端框架\ndate: 2019-02-24 18:51:20\n---\n\n> 前端三大框架概念区别简总（angular,react,vue）\n\n<!--- more -->\n\n**MVX 框架模式：MVC+MVP+MVVM**\n\n1. MVC：Model+View+controller（M 和 V 的协调者），主要是基于分层的目的，让彼此的职责分开。\n\n   用户 User 通过控制器 Controller 来操作模板 Model 从而达到视图 View 的变化。数据直接从数据库读取\n\n2. MVP：是从 MVC 模式演变而来的，都是通过 Controller/Presenter 负责逻辑的处理+Model 提供数据+View 负责显示。\n\n在 MVP 中，Presenter 完全把 View 和 Model 进行了分离，主要的程序逻辑在 Presenter 里实现。\n并且，Presenter 和 View 是没有直接关联的，是通过定义好的接口进行交互，从而使得在变更 View 的时候可以保持 Presenter 不变。\n\n3. MVVM：MVVM 是把 MVC 里的 Controller 和 MVP 里的 Presenter 改成了 ViewModel。Model+View+ViewModel。\n\n   MVVM 的界面与 viewmodel 是松耦合，界面数据从 viewmodel 中获取\n   View 的变化会自动更新到 ViewModel,ViewModel 的变化也会自动同步到 View 上显示。\n   这种自动同步是因为 ViewModel 中的属性实现了 Observer，当属性变更时都能触发对应的操作。\n\n### 三大框架概述\n\n- vue: 构建用户界面的渐进式、轻量级框架,插件化, 倾向于（html+css+js）,易上手，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染，开发者不需要考虑组件是否需要重新渲染之类的优化。\n\n  ```js\n  //<div id=\"app\">\n  //    <!--html中修改的-->\n  //  <h1>{{message + '这是在outer HTML中的'}}</h1>\n  //</div>\n  var vm = new Vue({\n    el: \"#app\",\n    template: \"<h1>{{message +'这是在template中的'}}</h1>\",\n    //有template 作为模板编译成render函数，优先级高于外部HTML，页面显示\n    render: function(createElement) {\n      return createElement(\"h1\", \"this is createElement\");\n    },\n    // 它是以createElement作为参数，然后做渲染操作，而且我们可以直接嵌入JSX\n    // render函数选项 > template选项 > outer HTML.\n    data: {\n      message: \"Vue的生命周期\"\n    },\n    //  this.$el   this.$data(数据双向绑定的表示)   this.message\n    beforeCreate: function() {\n      // vm实例 创建前状态\n      // 初始化事件，进行数据的观测\n      // this.$el     undefined\n      // this.$data   undefined\n      // this.message undefined\n    },\n    created: function() {\n      //创建完毕状态(已进行数据绑定)\n      // this.$el     undefined\n      // this.$data   [obiect object] 已进行数据绑定\n      // this.message Vue的生命周期\n    },\n    beforeMount: function() {\n      // 挂载前状态\n      // 首先判断对象是否有el选项。如果有的话就继续向下编译，如果没有el选项，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)。\n      //可以看到此时是给vue实例对象添加$el成员，并且替换掉挂在的DOM元素.此时是虚拟dom的形式\n      // this.$el\n      // [object HTMLDivElement]  <div id='app'><h1>{{message}}用此占位</h1></div>\n      // this.$data   [obiect object]\n      // this.message Vue的生命周期\n    },\n    mounted: function() {\n      vm.message = \"触发组件更新\";\n      // 挂载结束状态\n      // this.$el\n      // [object HTMLDivElement]  <div id='app'><h1>Vue的生命周期</h1></div>\n      // this.$data   [obiect object]\n      // this.message Vue的生命周期\n    },\n    beforeUpdate: function() {\n      // 更新前状态 当vue发现data中的数据发生了改变，会触发对应组件的重新渲染\n      // this.$el     [object HTMLDivElement]\n      // this.$data   [obiect object]\n      // this.message Vue的生命周期(此时view层还未改变，但课监听到data的变化)\n    },\n    updated: function() {\n      // 更新完成状态\n      // this.$el     undefined\n      // this.$data   [obiect object] 已进行数据绑定\n      // this.message 触发组件更新\n    },\n    beforeDestroy: function() {\n      // 销毁前状态\n      // 实例销毁之前调用。在这一步，实例仍然完全可用\n    },\n    destroyed: function() {\n      // 销毁完成状态\n      // Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。\n    }\n  });\n  ```\n\n  总结：\n\n  1. **首先创建一个实例，new vue 过程中执行 init（vue 组件默认执行），init 过程中调用 beforeCreate**\n  2. **后在 injections（注射）和 reactivity（反应性）的时候，调用 created，created 完成之后，此时已经完成了双向数据绑定**\n  3. **beforeMount 中，去判断实例里面是否含有“el”选项，若无，调用 vm.$mount(el)方法，若有，去判断是否有“template”，若有，它会把template解析成一个render function，(其实这个hook function中就是相关的render函数被调用，此时$el 还只是我们在 HTML 里面写的节点)，**\n     `render函数选项 > template选项 > outer HTML.（render函数优先级）`\n  4. **之后 mounted，就把渲染出来的内容挂载到了 DOM 节点上**\n  5. **当数据变化的时候，调用 beforeUpdate，经过 Virtual DOM，之后调用 updated 更新 dom，**\n  6. **beforeDestroy，实例销毁之前，这个 hook 实例仍可用**\n  7. **destroyed 实例销毁后调用。实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。**\n\n- react(UI 库): 构建用户界面的 Js 库，JSX 语法，无指令，组件化（state,props），某个组件的状态发生变化时，以该组件为根，重新渲染整个组件子树\n\n```js\nimport React, { Component } from \"react\";\nclass Test extends Component {\n  // 类的构造方法( constructor() )，继承了react Component这个基类，也就继承这个react的基类，才能有render(),生命周期等方法可以使用，这也说明为什么函数组件不能使用这些方法的原因。\n  constructor(props) {\n    //   super(props)用来调用基类的构造方法( constructor() ), 也将父组件的props注入给子组件\n    super(props);\n  }\n  componentWillMount() {\n    // 在组件挂载到DOM前调用，且只会被调用一次，在这边调用this.setState不会引起组件重新渲染，也可以把写在这边的内容提前到constructor()中，所以项目中很少用。\n  }\n\n  componentDidMount() {\n    //   组件挂载到DOM后调用，且只会被调用一次\n  }\n  //   父组件重新render引起子组件重新render的情况有两种，\n  //   1.  每当父组件重新render导致的重传props，子组件将直接跟着重新渲染，无论props是否有变化。可通过shouldComponentUpdate方法优化。\n  // 2. 在componentWillReceiveProps方法中，将props转换成自己的state\n  componentWillReceiveProps(nextProps) {\n    //   此方法只调用于props引起的组件更新过程中，参数nextProps是父组件传给当前组件的新props。但父组件render方法的调用不能保证重传给当前组件的props是有变化的，所以在此方法中根据nextProps和this.props来查明重传的props是否改变，以及如果改变了要执行啥，比如根据新的props调用this.setState出发当前组件的重新render\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    // 应该使用这个方法，否则无论props是否有变化都将会导致组件跟着重新渲染\n    // 此方法通过比较nextProps，nextState及当前组件的this.props，this.state，返回true时当前组件将继续执行更新过程，返回false则当前组件更新停止，以此可用来减少组件的不必要渲染，优化组件性能。\n    if (nextProps.someThings === this.props.someThings) {\n      return false;\n    }\n  }\n  componentWillUpdate(nextProps, nextState) {\n    //   此方法在调用render方法前执行，在这边可执行一些组件更新发生前的工作，一般较少用。\n  }\n  componentDidUpdate(prevProps, prevState) {\n    //   此方法在组件更新后被调用，可以操作组件更新的DOM，prevProps和prevState这两个参数指的是组件更新前的props和state\n  }\n  render() {\n    //   根据组件的props和state，return 一个React元素，不负责组件实际渲染工作，之后由React自身根据此元素去渲染出页面DOM。render是纯函数，不能在里面执行this.setState，会有改变组件状态的副作用。\n    // 反复调用\n  }\n  componentWillUnmount() {\n    //   此方法在组件被卸载前调用，可以在这里执行一些清理工作，比如清楚组件中使用的定时器，清楚componentDidMount中手动创建的DOM元素等，以避免引起内存泄漏。\n  }\n}\n```\n\n只执行一次： constructor、componentWillMount、componentDidMount\n\n执行多次：render 、子组件的 componentWillReceiveProps、componentWillUpdate、componentDidUpdate\n\n有条件的执行：componentWillUnmount（页面离开，组件销毁时）\n\n不执行的：根组件（ReactDOM.render 在 DOM 上的组件）的 componentWillReceiveProps（因为压根没有父组件给传递 props）\n\n- react & vue: 组件化，钩子函数（生命周期），使用 Virtual DOM,不内置 ajax，route 核心包，以插件形式加载\n\n- vue & angular(MVVM): 双向数据绑定,支持指令（内置和自定义指令），内置过滤器和自定义过滤器,不支持低端浏览器\n\n![三大框架](/img/interview/react-ag-vue.png \"三大框架\")\n","slug":"面试/react-vue-angular","published":1,"updated":"2019-02-26T10:14:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3dl000vuox17f9wx83q","content":"<blockquote>\n<p>前端三大框架概念区别简总（angular,react,vue）</p>\n</blockquote>\n<a id=\"more\"></a>\n<p><strong>MVX 框架模式：MVC+MVP+MVVM</strong></p>\n<ol>\n<li><p>MVC：Model+View+controller（M 和 V 的协调者），主要是基于分层的目的，让彼此的职责分开。</p>\n<p>用户 User 通过控制器 Controller 来操作模板 Model 从而达到视图 View 的变化。数据直接从数据库读取</p>\n</li>\n<li><p>MVP：是从 MVC 模式演变而来的，都是通过 Controller/Presenter 负责逻辑的处理+Model 提供数据+View 负责显示。</p>\n</li>\n</ol>\n<p>在 MVP 中，Presenter 完全把 View 和 Model 进行了分离，主要的程序逻辑在 Presenter 里实现。<br>并且，Presenter 和 View 是没有直接关联的，是通过定义好的接口进行交互，从而使得在变更 View 的时候可以保持 Presenter 不变。</p>\n<ol>\n<li><p>MVVM：MVVM 是把 MVC 里的 Controller 和 MVP 里的 Presenter 改成了 ViewModel。Model+View+ViewModel。</p>\n<p>MVVM 的界面与 viewmodel 是松耦合，界面数据从 viewmodel 中获取<br>View 的变化会自动更新到 ViewModel,ViewModel 的变化也会自动同步到 View 上显示。<br>这种自动同步是因为 ViewModel 中的属性实现了 Observer，当属性变更时都能触发对应的操作。</p>\n</li>\n</ol>\n<h3 id=\"三大框架概述\"><a href=\"#三大框架概述\" class=\"headerlink\" title=\"三大框架概述\"></a>三大框架概述</h3><ul>\n<li><p>vue: 构建用户界面的渐进式、轻量级框架,插件化, 倾向于（html+css+js）,易上手，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染，开发者不需要考虑组件是否需要重新渲染之类的优化。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//&lt;div id=\"app\"&gt;</span></span><br><span class=\"line\"><span class=\"comment\">//    &lt;!--html中修改的--&gt;</span></span><br><span class=\"line\"><span class=\"comment\">//  &lt;h1&gt;&#123;&#123;message + '这是在outer HTML中的'&#125;&#125;&lt;/h1&gt;</span></span><br><span class=\"line\"><span class=\"comment\">//&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">\"#app\"</span>,</span><br><span class=\"line\">  template: <span class=\"string\">\"&lt;h1&gt;&#123;&#123;message +'这是在template中的'&#125;&#125;&lt;/h1&gt;\"</span>,</span><br><span class=\"line\">  <span class=\"comment\">//有template 作为模板编译成render函数，优先级高于外部HTML，页面显示</span></span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">createElement</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> createElement(<span class=\"string\">\"h1\"</span>, <span class=\"string\">\"this is createElement\"</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 它是以createElement作为参数，然后做渲染操作，而且我们可以直接嵌入JSX</span></span><br><span class=\"line\">  <span class=\"comment\">// render函数选项 &gt; template选项 &gt; outer HTML.</span></span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    message: <span class=\"string\">\"Vue的生命周期\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//  this.$el   this.$data(数据双向绑定的表示)   this.message</span></span><br><span class=\"line\">  beforeCreate: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// vm实例 创建前状态</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化事件，进行数据的观测</span></span><br><span class=\"line\">    <span class=\"comment\">// this.$el     undefined</span></span><br><span class=\"line\">    <span class=\"comment\">// this.$data   undefined</span></span><br><span class=\"line\">    <span class=\"comment\">// this.message undefined</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  created: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建完毕状态(已进行数据绑定)</span></span><br><span class=\"line\">    <span class=\"comment\">// this.$el     undefined</span></span><br><span class=\"line\">    <span class=\"comment\">// this.$data   [obiect object] 已进行数据绑定</span></span><br><span class=\"line\">    <span class=\"comment\">// this.message Vue的生命周期</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  beforeMount: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 挂载前状态</span></span><br><span class=\"line\">    <span class=\"comment\">// 首先判断对象是否有el选项。如果有的话就继续向下编译，如果没有el选项，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)。</span></span><br><span class=\"line\">    <span class=\"comment\">//可以看到此时是给vue实例对象添加$el成员，并且替换掉挂在的DOM元素.此时是虚拟dom的形式</span></span><br><span class=\"line\">    <span class=\"comment\">// this.$el</span></span><br><span class=\"line\">    <span class=\"comment\">// [object HTMLDivElement]  &lt;div id='app'&gt;&lt;h1&gt;&#123;&#123;message&#125;&#125;用此占位&lt;/h1&gt;&lt;/div&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">// this.$data   [obiect object]</span></span><br><span class=\"line\">    <span class=\"comment\">// this.message Vue的生命周期</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    vm.message = <span class=\"string\">\"触发组件更新\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 挂载结束状态</span></span><br><span class=\"line\">    <span class=\"comment\">// this.$el</span></span><br><span class=\"line\">    <span class=\"comment\">// [object HTMLDivElement]  &lt;div id='app'&gt;&lt;h1&gt;Vue的生命周期&lt;/h1&gt;&lt;/div&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">// this.$data   [obiect object]</span></span><br><span class=\"line\">    <span class=\"comment\">// this.message Vue的生命周期</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  beforeUpdate: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 更新前状态 当vue发现data中的数据发生了改变，会触发对应组件的重新渲染</span></span><br><span class=\"line\">    <span class=\"comment\">// this.$el     [object HTMLDivElement]</span></span><br><span class=\"line\">    <span class=\"comment\">// this.$data   [obiect object]</span></span><br><span class=\"line\">    <span class=\"comment\">// this.message Vue的生命周期(此时view层还未改变，但课监听到data的变化)</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  updated: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 更新完成状态</span></span><br><span class=\"line\">    <span class=\"comment\">// this.$el     undefined</span></span><br><span class=\"line\">    <span class=\"comment\">// this.$data   [obiect object] 已进行数据绑定</span></span><br><span class=\"line\">    <span class=\"comment\">// this.message 触发组件更新</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  beforeDestroy: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 销毁前状态</span></span><br><span class=\"line\">    <span class=\"comment\">// 实例销毁之前调用。在这一步，实例仍然完全可用</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  destroyed: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 销毁完成状态</span></span><br><span class=\"line\">    <span class=\"comment\">// Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>总结：</p>\n<ol>\n<li><strong>首先创建一个实例，new vue 过程中执行 init（vue 组件默认执行），init 过程中调用 beforeCreate</strong></li>\n<li><strong>后在 injections（注射）和 reactivity（反应性）的时候，调用 created，created 完成之后，此时已经完成了双向数据绑定</strong></li>\n<li><strong>beforeMount 中，去判断实例里面是否含有“el”选项，若无，调用 vm.$mount(el)方法，若有，去判断是否有“template”，若有，它会把template解析成一个render function，(其实这个hook function中就是相关的render函数被调用，此时$el 还只是我们在 HTML 里面写的节点)，</strong><br><code>render函数选项 &gt; template选项 &gt; outer HTML.（render函数优先级）</code></li>\n<li><strong>之后 mounted，就把渲染出来的内容挂载到了 DOM 节点上</strong></li>\n<li><strong>当数据变化的时候，调用 beforeUpdate，经过 Virtual DOM，之后调用 updated 更新 dom，</strong></li>\n<li><strong>beforeDestroy，实例销毁之前，这个 hook 实例仍可用</strong></li>\n<li><strong>destroyed 实例销毁后调用。实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</strong></li>\n</ol>\n</li>\n<li><p>react(UI 库): 构建用户界面的 Js 库，JSX 语法，无指令，组件化（state,props），某个组件的状态发生变化时，以该组件为根，重新渲染整个组件子树</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 类的构造方法( constructor() )，继承了react Component这个基类，也就继承这个react的基类，才能有render(),生命周期等方法可以使用，这也说明为什么函数组件不能使用这些方法的原因。</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//   super(props)用来调用基类的构造方法( constructor() ), 也将父组件的props注入给子组件</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentWillMount() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在组件挂载到DOM前调用，且只会被调用一次，在这边调用this.setState不会引起组件重新渲染，也可以把写在这边的内容提前到constructor()中，所以项目中很少用。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"comment\">//   组件挂载到DOM后调用，且只会被调用一次</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//   父组件重新render引起子组件重新render的情况有两种，</span></span><br><span class=\"line\">  <span class=\"comment\">//   1.  每当父组件重新render导致的重传props，子组件将直接跟着重新渲染，无论props是否有变化。可通过shouldComponentUpdate方法优化。</span></span><br><span class=\"line\">  <span class=\"comment\">// 2. 在componentWillReceiveProps方法中，将props转换成自己的state</span></span><br><span class=\"line\">  componentWillReceiveProps(nextProps) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//   此方法只调用于props引起的组件更新过程中，参数nextProps是父组件传给当前组件的新props。但父组件render方法的调用不能保证重传给当前组件的props是有变化的，所以在此方法中根据nextProps和this.props来查明重传的props是否改变，以及如果改变了要执行啥，比如根据新的props调用this.setState出发当前组件的重新render</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 应该使用这个方法，否则无论props是否有变化都将会导致组件跟着重新渲染</span></span><br><span class=\"line\">    <span class=\"comment\">// 此方法通过比较nextProps，nextState及当前组件的this.props，this.state，返回true时当前组件将继续执行更新过程，返回false则当前组件更新停止，以此可用来减少组件的不必要渲染，优化组件性能。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextProps.someThings === <span class=\"keyword\">this</span>.props.someThings) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentWillUpdate(nextProps, nextState) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//   此方法在调用render方法前执行，在这边可执行一些组件更新发生前的工作，一般较少用。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentDidUpdate(prevProps, prevState) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//   此方法在组件更新后被调用，可以操作组件更新的DOM，prevProps和prevState这两个参数指的是组件更新前的props和state</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"comment\">//   根据组件的props和state，return 一个React元素，不负责组件实际渲染工作，之后由React自身根据此元素去渲染出页面DOM。render是纯函数，不能在里面执行this.setState，会有改变组件状态的副作用。</span></span><br><span class=\"line\">    <span class=\"comment\">// 反复调用</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentWillUnmount() &#123;</span><br><span class=\"line\">    <span class=\"comment\">//   此方法在组件被卸载前调用，可以在这里执行一些清理工作，比如清楚组件中使用的定时器，清楚componentDidMount中手动创建的DOM元素等，以避免引起内存泄漏。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只执行一次： constructor、componentWillMount、componentDidMount</p>\n<p>执行多次：render 、子组件的 componentWillReceiveProps、componentWillUpdate、componentDidUpdate</p>\n<p>有条件的执行：componentWillUnmount（页面离开，组件销毁时）</p>\n<p>不执行的：根组件（ReactDOM.render 在 DOM 上的组件）的 componentWillReceiveProps（因为压根没有父组件给传递 props）</p>\n<ul>\n<li><p>react &amp; vue: 组件化，钩子函数（生命周期），使用 Virtual DOM,不内置 ajax，route 核心包，以插件形式加载</p>\n</li>\n<li><p>vue &amp; angular(MVVM): 双向数据绑定,支持指令（内置和自定义指令），内置过滤器和自定义过滤器,不支持低端浏览器</p>\n</li>\n</ul>\n<p><img src=\"/img/interview/react-ag-vue.png\" alt=\"三大框架\" title=\"三大框架\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>前端三大框架概念区别简总（angular,react,vue）</p>\n</blockquote>","more":"<p><strong>MVX 框架模式：MVC+MVP+MVVM</strong></p>\n<ol>\n<li><p>MVC：Model+View+controller（M 和 V 的协调者），主要是基于分层的目的，让彼此的职责分开。</p>\n<p>用户 User 通过控制器 Controller 来操作模板 Model 从而达到视图 View 的变化。数据直接从数据库读取</p>\n</li>\n<li><p>MVP：是从 MVC 模式演变而来的，都是通过 Controller/Presenter 负责逻辑的处理+Model 提供数据+View 负责显示。</p>\n</li>\n</ol>\n<p>在 MVP 中，Presenter 完全把 View 和 Model 进行了分离，主要的程序逻辑在 Presenter 里实现。<br>并且，Presenter 和 View 是没有直接关联的，是通过定义好的接口进行交互，从而使得在变更 View 的时候可以保持 Presenter 不变。</p>\n<ol>\n<li><p>MVVM：MVVM 是把 MVC 里的 Controller 和 MVP 里的 Presenter 改成了 ViewModel。Model+View+ViewModel。</p>\n<p>MVVM 的界面与 viewmodel 是松耦合，界面数据从 viewmodel 中获取<br>View 的变化会自动更新到 ViewModel,ViewModel 的变化也会自动同步到 View 上显示。<br>这种自动同步是因为 ViewModel 中的属性实现了 Observer，当属性变更时都能触发对应的操作。</p>\n</li>\n</ol>\n<h3 id=\"三大框架概述\"><a href=\"#三大框架概述\" class=\"headerlink\" title=\"三大框架概述\"></a>三大框架概述</h3><ul>\n<li><p>vue: 构建用户界面的渐进式、轻量级框架,插件化, 倾向于（html+css+js）,易上手，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染，开发者不需要考虑组件是否需要重新渲染之类的优化。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//&lt;div id=\"app\"&gt;</span></span><br><span class=\"line\"><span class=\"comment\">//    &lt;!--html中修改的--&gt;</span></span><br><span class=\"line\"><span class=\"comment\">//  &lt;h1&gt;&#123;&#123;message + '这是在outer HTML中的'&#125;&#125;&lt;/h1&gt;</span></span><br><span class=\"line\"><span class=\"comment\">//&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">\"#app\"</span>,</span><br><span class=\"line\">  template: <span class=\"string\">\"&lt;h1&gt;&#123;&#123;message +'这是在template中的'&#125;&#125;&lt;/h1&gt;\"</span>,</span><br><span class=\"line\">  <span class=\"comment\">//有template 作为模板编译成render函数，优先级高于外部HTML，页面显示</span></span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">createElement</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> createElement(<span class=\"string\">\"h1\"</span>, <span class=\"string\">\"this is createElement\"</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 它是以createElement作为参数，然后做渲染操作，而且我们可以直接嵌入JSX</span></span><br><span class=\"line\">  <span class=\"comment\">// render函数选项 &gt; template选项 &gt; outer HTML.</span></span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    message: <span class=\"string\">\"Vue的生命周期\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//  this.$el   this.$data(数据双向绑定的表示)   this.message</span></span><br><span class=\"line\">  beforeCreate: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// vm实例 创建前状态</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化事件，进行数据的观测</span></span><br><span class=\"line\">    <span class=\"comment\">// this.$el     undefined</span></span><br><span class=\"line\">    <span class=\"comment\">// this.$data   undefined</span></span><br><span class=\"line\">    <span class=\"comment\">// this.message undefined</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  created: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建完毕状态(已进行数据绑定)</span></span><br><span class=\"line\">    <span class=\"comment\">// this.$el     undefined</span></span><br><span class=\"line\">    <span class=\"comment\">// this.$data   [obiect object] 已进行数据绑定</span></span><br><span class=\"line\">    <span class=\"comment\">// this.message Vue的生命周期</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  beforeMount: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 挂载前状态</span></span><br><span class=\"line\">    <span class=\"comment\">// 首先判断对象是否有el选项。如果有的话就继续向下编译，如果没有el选项，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)。</span></span><br><span class=\"line\">    <span class=\"comment\">//可以看到此时是给vue实例对象添加$el成员，并且替换掉挂在的DOM元素.此时是虚拟dom的形式</span></span><br><span class=\"line\">    <span class=\"comment\">// this.$el</span></span><br><span class=\"line\">    <span class=\"comment\">// [object HTMLDivElement]  &lt;div id='app'&gt;&lt;h1&gt;&#123;&#123;message&#125;&#125;用此占位&lt;/h1&gt;&lt;/div&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">// this.$data   [obiect object]</span></span><br><span class=\"line\">    <span class=\"comment\">// this.message Vue的生命周期</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    vm.message = <span class=\"string\">\"触发组件更新\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 挂载结束状态</span></span><br><span class=\"line\">    <span class=\"comment\">// this.$el</span></span><br><span class=\"line\">    <span class=\"comment\">// [object HTMLDivElement]  &lt;div id='app'&gt;&lt;h1&gt;Vue的生命周期&lt;/h1&gt;&lt;/div&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">// this.$data   [obiect object]</span></span><br><span class=\"line\">    <span class=\"comment\">// this.message Vue的生命周期</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  beforeUpdate: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 更新前状态 当vue发现data中的数据发生了改变，会触发对应组件的重新渲染</span></span><br><span class=\"line\">    <span class=\"comment\">// this.$el     [object HTMLDivElement]</span></span><br><span class=\"line\">    <span class=\"comment\">// this.$data   [obiect object]</span></span><br><span class=\"line\">    <span class=\"comment\">// this.message Vue的生命周期(此时view层还未改变，但课监听到data的变化)</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  updated: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 更新完成状态</span></span><br><span class=\"line\">    <span class=\"comment\">// this.$el     undefined</span></span><br><span class=\"line\">    <span class=\"comment\">// this.$data   [obiect object] 已进行数据绑定</span></span><br><span class=\"line\">    <span class=\"comment\">// this.message 触发组件更新</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  beforeDestroy: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 销毁前状态</span></span><br><span class=\"line\">    <span class=\"comment\">// 实例销毁之前调用。在这一步，实例仍然完全可用</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  destroyed: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 销毁完成状态</span></span><br><span class=\"line\">    <span class=\"comment\">// Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>总结：</p>\n<ol>\n<li><strong>首先创建一个实例，new vue 过程中执行 init（vue 组件默认执行），init 过程中调用 beforeCreate</strong></li>\n<li><strong>后在 injections（注射）和 reactivity（反应性）的时候，调用 created，created 完成之后，此时已经完成了双向数据绑定</strong></li>\n<li><strong>beforeMount 中，去判断实例里面是否含有“el”选项，若无，调用 vm.$mount(el)方法，若有，去判断是否有“template”，若有，它会把template解析成一个render function，(其实这个hook function中就是相关的render函数被调用，此时$el 还只是我们在 HTML 里面写的节点)，</strong><br><code>render函数选项 &gt; template选项 &gt; outer HTML.（render函数优先级）</code></li>\n<li><strong>之后 mounted，就把渲染出来的内容挂载到了 DOM 节点上</strong></li>\n<li><strong>当数据变化的时候，调用 beforeUpdate，经过 Virtual DOM，之后调用 updated 更新 dom，</strong></li>\n<li><strong>beforeDestroy，实例销毁之前，这个 hook 实例仍可用</strong></li>\n<li><strong>destroyed 实例销毁后调用。实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</strong></li>\n</ol>\n</li>\n<li><p>react(UI 库): 构建用户界面的 Js 库，JSX 语法，无指令，组件化（state,props），某个组件的状态发生变化时，以该组件为根，重新渲染整个组件子树</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 类的构造方法( constructor() )，继承了react Component这个基类，也就继承这个react的基类，才能有render(),生命周期等方法可以使用，这也说明为什么函数组件不能使用这些方法的原因。</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//   super(props)用来调用基类的构造方法( constructor() ), 也将父组件的props注入给子组件</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentWillMount() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在组件挂载到DOM前调用，且只会被调用一次，在这边调用this.setState不会引起组件重新渲染，也可以把写在这边的内容提前到constructor()中，所以项目中很少用。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"comment\">//   组件挂载到DOM后调用，且只会被调用一次</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//   父组件重新render引起子组件重新render的情况有两种，</span></span><br><span class=\"line\">  <span class=\"comment\">//   1.  每当父组件重新render导致的重传props，子组件将直接跟着重新渲染，无论props是否有变化。可通过shouldComponentUpdate方法优化。</span></span><br><span class=\"line\">  <span class=\"comment\">// 2. 在componentWillReceiveProps方法中，将props转换成自己的state</span></span><br><span class=\"line\">  componentWillReceiveProps(nextProps) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//   此方法只调用于props引起的组件更新过程中，参数nextProps是父组件传给当前组件的新props。但父组件render方法的调用不能保证重传给当前组件的props是有变化的，所以在此方法中根据nextProps和this.props来查明重传的props是否改变，以及如果改变了要执行啥，比如根据新的props调用this.setState出发当前组件的重新render</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 应该使用这个方法，否则无论props是否有变化都将会导致组件跟着重新渲染</span></span><br><span class=\"line\">    <span class=\"comment\">// 此方法通过比较nextProps，nextState及当前组件的this.props，this.state，返回true时当前组件将继续执行更新过程，返回false则当前组件更新停止，以此可用来减少组件的不必要渲染，优化组件性能。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextProps.someThings === <span class=\"keyword\">this</span>.props.someThings) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentWillUpdate(nextProps, nextState) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//   此方法在调用render方法前执行，在这边可执行一些组件更新发生前的工作，一般较少用。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentDidUpdate(prevProps, prevState) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//   此方法在组件更新后被调用，可以操作组件更新的DOM，prevProps和prevState这两个参数指的是组件更新前的props和state</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"comment\">//   根据组件的props和state，return 一个React元素，不负责组件实际渲染工作，之后由React自身根据此元素去渲染出页面DOM。render是纯函数，不能在里面执行this.setState，会有改变组件状态的副作用。</span></span><br><span class=\"line\">    <span class=\"comment\">// 反复调用</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentWillUnmount() &#123;</span><br><span class=\"line\">    <span class=\"comment\">//   此方法在组件被卸载前调用，可以在这里执行一些清理工作，比如清楚组件中使用的定时器，清楚componentDidMount中手动创建的DOM元素等，以避免引起内存泄漏。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只执行一次： constructor、componentWillMount、componentDidMount</p>\n<p>执行多次：render 、子组件的 componentWillReceiveProps、componentWillUpdate、componentDidUpdate</p>\n<p>有条件的执行：componentWillUnmount（页面离开，组件销毁时）</p>\n<p>不执行的：根组件（ReactDOM.render 在 DOM 上的组件）的 componentWillReceiveProps（因为压根没有父组件给传递 props）</p>\n<ul>\n<li><p>react &amp; vue: 组件化，钩子函数（生命周期），使用 Virtual DOM,不内置 ajax，route 核心包，以插件形式加载</p>\n</li>\n<li><p>vue &amp; angular(MVVM): 双向数据绑定,支持指令（内置和自定义指令），内置过滤器和自定义过滤器,不支持低端浏览器</p>\n</li>\n</ul>\n<p><img src=\"/img/interview/react-ag-vue.png\" alt=\"三大框架\" title=\"三大框架\"></p>"},{"title":"face-to-face预习","date":"2017-12-29T14:47:58.000Z","_content":"\n> 小班面授课，face-to-face\n\n<!-- more -->\n\n## One：English for work · Talking about work\n\n1. ***key vocabulary***\n\n    <font color=red>punctual &nbsp;&nbsp;&nbsp;&nbsp;准时</font>\n    <font color=red>unreliable &nbsp;&nbsp;&nbsp;&nbsp;靠不住</font>\n    <font color=red>team player &nbsp;&nbsp;&nbsp;&nbsp;有团队精神的人</font>\n    <font color=red>fast worker&nbsp;&nbsp;&nbsp;&nbsp;快速的工人</font>\n    <font color=red>ambitious &nbsp;&nbsp;&nbsp;&nbsp;抱负不凡的, 有雄心</font>\n    <font color=red>clever &nbsp;&nbsp;&nbsp;&nbsp;聪明, 巧妙, 高明, 机灵</font>\n\n    mentally quick and resourceful\n    精神上快速、应变能力强\n    acting or arriving exactly at the appointed time\n    按约定时间行事或到达\n    lacking a sense of responsibility\n    缺乏责任感\n    having a strong desire for success or achievement\n    对成功或成就有强烈的渴望\n    a person who works well with others in order to achieve things\n    一个人为了达到目的而与他人良好合作\n    someone who finishes tasks quickly\n    快速完成任务的人\n\n2. ***key grammar and vocabulary***\n\n    it is not surprising that she is been她的出现也就不足为奇了\n\n\n\n\n\n","source":"_posts/英语/预习face-to-face.md","raw":"---\ntitle: face-to-face预习\ndate: 2017-12-29 22:47:58\ncategories:\n- 英语\ntags: 英语\n---\n\n> 小班面授课，face-to-face\n\n<!-- more -->\n\n## One：English for work · Talking about work\n\n1. ***key vocabulary***\n\n    <font color=red>punctual &nbsp;&nbsp;&nbsp;&nbsp;准时</font>\n    <font color=red>unreliable &nbsp;&nbsp;&nbsp;&nbsp;靠不住</font>\n    <font color=red>team player &nbsp;&nbsp;&nbsp;&nbsp;有团队精神的人</font>\n    <font color=red>fast worker&nbsp;&nbsp;&nbsp;&nbsp;快速的工人</font>\n    <font color=red>ambitious &nbsp;&nbsp;&nbsp;&nbsp;抱负不凡的, 有雄心</font>\n    <font color=red>clever &nbsp;&nbsp;&nbsp;&nbsp;聪明, 巧妙, 高明, 机灵</font>\n\n    mentally quick and resourceful\n    精神上快速、应变能力强\n    acting or arriving exactly at the appointed time\n    按约定时间行事或到达\n    lacking a sense of responsibility\n    缺乏责任感\n    having a strong desire for success or achievement\n    对成功或成就有强烈的渴望\n    a person who works well with others in order to achieve things\n    一个人为了达到目的而与他人良好合作\n    someone who finishes tasks quickly\n    快速完成任务的人\n\n2. ***key grammar and vocabulary***\n\n    it is not surprising that she is been她的出现也就不足为奇了\n\n\n\n\n\n","slug":"英语/预习face-to-face","published":1,"updated":"2018-05-31T10:27:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3dm000wuox1mc247610","content":"<blockquote>\n<p>小班面授课，face-to-face</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"One：English-for-work-·-Talking-about-work\"><a href=\"#One：English-for-work-·-Talking-about-work\" class=\"headerlink\" title=\"One：English for work · Talking about work\"></a>One：English for work · Talking about work</h2><ol>\n<li><p><strong><em>key vocabulary</em></strong></p>\n <font color=\"red\">punctual &nbsp;&nbsp;&nbsp;&nbsp;准时</font><br> <font color=\"red\">unreliable &nbsp;&nbsp;&nbsp;&nbsp;靠不住</font><br> <font color=\"red\">team player &nbsp;&nbsp;&nbsp;&nbsp;有团队精神的人</font><br> <font color=\"red\">fast worker&nbsp;&nbsp;&nbsp;&nbsp;快速的工人</font><br> <font color=\"red\">ambitious &nbsp;&nbsp;&nbsp;&nbsp;抱负不凡的, 有雄心</font><br> <font color=\"red\">clever &nbsp;&nbsp;&nbsp;&nbsp;聪明, 巧妙, 高明, 机灵</font>\n\n<p> mentally quick and resourceful<br> 精神上快速、应变能力强<br> acting or arriving exactly at the appointed time<br> 按约定时间行事或到达<br> lacking a sense of responsibility<br> 缺乏责任感<br> having a strong desire for success or achievement<br> 对成功或成就有强烈的渴望<br> a person who works well with others in order to achieve things<br> 一个人为了达到目的而与他人良好合作<br> someone who finishes tasks quickly<br> 快速完成任务的人</p>\n</li>\n<li><p><strong><em>key grammar and vocabulary</em></strong></p>\n<p> it is not surprising that she is been她的出现也就不足为奇了</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>小班面授课，face-to-face</p>\n</blockquote>","more":"<h2 id=\"One：English-for-work-·-Talking-about-work\"><a href=\"#One：English-for-work-·-Talking-about-work\" class=\"headerlink\" title=\"One：English for work · Talking about work\"></a>One：English for work · Talking about work</h2><ol>\n<li><p><strong><em>key vocabulary</em></strong></p>\n <font color=\"red\">punctual &nbsp;&nbsp;&nbsp;&nbsp;准时</font><br> <font color=\"red\">unreliable &nbsp;&nbsp;&nbsp;&nbsp;靠不住</font><br> <font color=\"red\">team player &nbsp;&nbsp;&nbsp;&nbsp;有团队精神的人</font><br> <font color=\"red\">fast worker&nbsp;&nbsp;&nbsp;&nbsp;快速的工人</font><br> <font color=\"red\">ambitious &nbsp;&nbsp;&nbsp;&nbsp;抱负不凡的, 有雄心</font><br> <font color=\"red\">clever &nbsp;&nbsp;&nbsp;&nbsp;聪明, 巧妙, 高明, 机灵</font>\n\n<p> mentally quick and resourceful<br> 精神上快速、应变能力强<br> acting or arriving exactly at the appointed time<br> 按约定时间行事或到达<br> lacking a sense of responsibility<br> 缺乏责任感<br> having a strong desire for success or achievement<br> 对成功或成就有强烈的渴望<br> a person who works well with others in order to achieve things<br> 一个人为了达到目的而与他人良好合作<br> someone who finishes tasks quickly<br> 快速完成任务的人</p>\n</li>\n<li><p><strong><em>key grammar and vocabulary</em></strong></p>\n<p> it is not surprising that she is been她的出现也就不足为奇了</p>\n</li>\n</ol>"},{"title":"前端面试","date":"2018-08-23T07:52:40.000Z","_content":"\n> 2108 前端面试题整理\n\n<!--- more -->\n\n- [请写出一种实现深拷贝的方法？](#1)\n\n- [JQ 链式调用的实现方法？](#2)\n\n- [有 arr = [{a:1,{b:2},{c:3}}] obj={d:4} 请使用 es6 写出一种方法实现,得到对象{a:1,b:2,c:3,d:4}](#3)\n\n- [Javascript 垃圾收集方法？](#4)\n\n- [简单写出 vue 的 MVVM 实现原理](#5)\n\n- [实现 es5reduce 的方法](#6)\n\n- [使用 es5 实现 Promise](#7)\n\n- [什么是单线程和异步有何关系](#8)\n\n- [JavaScript 中的 Currying(柯里化) 和 Partial Application(偏函数应用)](#9)\n\n### <span id='1'>1. 请写出一种实现深拷贝的方法？</span>\n\n```js\nvar objDeepCopy = function(source) {\n  var sourceCopy = source instanceof Array ? [] : {};\n  for (var item in source) {\n    sourceCopy[item] =\n      typeof source[item] === \"object\"\n        ? objDeepCopy(source[item])\n        : source[item];\n  }\n  return sourceCopy;\n};\n```\n\n### <span id='2'>2. JQ 链式调用的实现方法？</span>\n\n```js\n    aQuery.prototype = {\n        init: function() {\n            alert(1);\n            return this;\n        },\n        name: function() {\n            alert(2);\n            return this\n        }\n    aQuery.init().name()\n```\n\n### <span id='3'>3. 有 arr = [{a:1,{b:2},{c:3}}] obj={d:4} 请使用 es6 写出一种方法实现,得到对象{a:1,b:2,c:3,d:4}</span>\n\n```js\n.........\n```\n\n### <span id='4'>4. Javascript 垃圾收集方法？</span>\n\n```\n回收机制方式\n1、定义和用法：垃圾回收机制(GC:Garbage Collection),执行环境负责管理代码执行过程中使用的内存。\n\n2、原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。\n\n3. 垃圾回收策略：标记清除(较为常用)和引用计数。\n\n标记清除：\n\n　　定义和用法：当变量进入环境时，将变量标记\"进入环境\"，当变量离开环境时，标记为：\"离开环境\"。某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。\n\n　　到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。\n\n引用计数：\n\n　　定义和用法：引用计数是跟踪记录每个值被引用的次数。\n\n　　基本原理：就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象。\n```\n\n### <span id='5'>5. 简单写出 vue 的 MVVM 实现原理</span>\n\n[vue 双向绑定原理](https://juejin.im/entry/5923973da22b9d005893805a)\n\n### <span id='6'>6. 实现 es5reduce 的方法</span>\n\n```js\n// reduce() 从数组第一项开始，逐个遍历到最后\n// reduceRight() 从数组的最后一项开始，向前遍历到第一项\n// 都支持4个参数。(prev【前一个值】,cur【当前值】,index【项的索引】,array【数组对象】)\n// reduce()和reduceRight()的差别在于从哪头开始遍历数组。除此之外都一样。\n// 【兼容性】IE9+,Chrome,Firefox 3+,Safari 4+,Opera 10.5支持\n// 这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代从数组的第二项开始。\n//利用reduce求数组中所有值的和\nvar values = [1, 2, 3, 4, 5];\nvar sum = values.reduce(function(prev, cur, index, array) {\n  return prev + cur;\n});\n//sum的值为15;\n```\n\n### <span id='7'>7. 使用 es5 实现 Promise</span>\n\n[实现一个自己的 promise](https://blog.csdn.net/yibingxiong1/article/details/68075416)\n\n### <span id='8'>8. 什么是单线程,和异步有何关系</span>\n\n[异步和单线程](https://blog.csdn.net/ll_0801xyz/article/details/78232621)\n[JavaScript 运行机制详解：再谈 Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)\n\n### <span id='9'>9. JavaScript 中的 Currying(柯里化) 和 Partial Application(偏函数应用)</span>\n\n[css88](http://www.css88.com/archives/7781)\n\n[2018 最新 Web 前端经典面试试题及答案](https://blog.csdn.net/wdlhao/article/details/79079660)\n","source":"_posts/面试/interview.md","raw":"---\ntitle: 前端面试\ncategories:\n  - 前端技术\ntags:\n  - 前端面试\ndate: 2018-08-23 15:52:40\n---\n\n> 2108 前端面试题整理\n\n<!--- more -->\n\n- [请写出一种实现深拷贝的方法？](#1)\n\n- [JQ 链式调用的实现方法？](#2)\n\n- [有 arr = [{a:1,{b:2},{c:3}}] obj={d:4} 请使用 es6 写出一种方法实现,得到对象{a:1,b:2,c:3,d:4}](#3)\n\n- [Javascript 垃圾收集方法？](#4)\n\n- [简单写出 vue 的 MVVM 实现原理](#5)\n\n- [实现 es5reduce 的方法](#6)\n\n- [使用 es5 实现 Promise](#7)\n\n- [什么是单线程和异步有何关系](#8)\n\n- [JavaScript 中的 Currying(柯里化) 和 Partial Application(偏函数应用)](#9)\n\n### <span id='1'>1. 请写出一种实现深拷贝的方法？</span>\n\n```js\nvar objDeepCopy = function(source) {\n  var sourceCopy = source instanceof Array ? [] : {};\n  for (var item in source) {\n    sourceCopy[item] =\n      typeof source[item] === \"object\"\n        ? objDeepCopy(source[item])\n        : source[item];\n  }\n  return sourceCopy;\n};\n```\n\n### <span id='2'>2. JQ 链式调用的实现方法？</span>\n\n```js\n    aQuery.prototype = {\n        init: function() {\n            alert(1);\n            return this;\n        },\n        name: function() {\n            alert(2);\n            return this\n        }\n    aQuery.init().name()\n```\n\n### <span id='3'>3. 有 arr = [{a:1,{b:2},{c:3}}] obj={d:4} 请使用 es6 写出一种方法实现,得到对象{a:1,b:2,c:3,d:4}</span>\n\n```js\n.........\n```\n\n### <span id='4'>4. Javascript 垃圾收集方法？</span>\n\n```\n回收机制方式\n1、定义和用法：垃圾回收机制(GC:Garbage Collection),执行环境负责管理代码执行过程中使用的内存。\n\n2、原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。\n\n3. 垃圾回收策略：标记清除(较为常用)和引用计数。\n\n标记清除：\n\n　　定义和用法：当变量进入环境时，将变量标记\"进入环境\"，当变量离开环境时，标记为：\"离开环境\"。某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。\n\n　　到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。\n\n引用计数：\n\n　　定义和用法：引用计数是跟踪记录每个值被引用的次数。\n\n　　基本原理：就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象。\n```\n\n### <span id='5'>5. 简单写出 vue 的 MVVM 实现原理</span>\n\n[vue 双向绑定原理](https://juejin.im/entry/5923973da22b9d005893805a)\n\n### <span id='6'>6. 实现 es5reduce 的方法</span>\n\n```js\n// reduce() 从数组第一项开始，逐个遍历到最后\n// reduceRight() 从数组的最后一项开始，向前遍历到第一项\n// 都支持4个参数。(prev【前一个值】,cur【当前值】,index【项的索引】,array【数组对象】)\n// reduce()和reduceRight()的差别在于从哪头开始遍历数组。除此之外都一样。\n// 【兼容性】IE9+,Chrome,Firefox 3+,Safari 4+,Opera 10.5支持\n// 这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代从数组的第二项开始。\n//利用reduce求数组中所有值的和\nvar values = [1, 2, 3, 4, 5];\nvar sum = values.reduce(function(prev, cur, index, array) {\n  return prev + cur;\n});\n//sum的值为15;\n```\n\n### <span id='7'>7. 使用 es5 实现 Promise</span>\n\n[实现一个自己的 promise](https://blog.csdn.net/yibingxiong1/article/details/68075416)\n\n### <span id='8'>8. 什么是单线程,和异步有何关系</span>\n\n[异步和单线程](https://blog.csdn.net/ll_0801xyz/article/details/78232621)\n[JavaScript 运行机制详解：再谈 Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)\n\n### <span id='9'>9. JavaScript 中的 Currying(柯里化) 和 Partial Application(偏函数应用)</span>\n\n[css88](http://www.css88.com/archives/7781)\n\n[2018 最新 Web 前端经典面试试题及答案](https://blog.csdn.net/wdlhao/article/details/79079660)\n","slug":"面试/interview","published":1,"updated":"2019-02-26T05:41:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3dm000xuox1bkndxaps","content":"<blockquote>\n<p>2108 前端面试题整理</p>\n</blockquote>\n<a id=\"more\"></a>\n<ul>\n<li><p><a href=\"#1\">请写出一种实现深拷贝的方法？</a></p>\n</li>\n<li><p><a href=\"#2\">JQ 链式调用的实现方法？</a></p>\n</li>\n<li><p><a href=\"#3\">有 arr = [{a:1,{b:2},{c:3}}] obj={d:4} 请使用 es6 写出一种方法实现,得到对象{a:1,b:2,c:3,d:4}</a></p>\n</li>\n<li><p><a href=\"#4\">Javascript 垃圾收集方法？</a></p>\n</li>\n<li><p><a href=\"#5\">简单写出 vue 的 MVVM 实现原理</a></p>\n</li>\n<li><p><a href=\"#6\">实现 es5reduce 的方法</a></p>\n</li>\n<li><p><a href=\"#7\">使用 es5 实现 Promise</a></p>\n</li>\n<li><p><a href=\"#8\">什么是单线程和异步有何关系</a></p>\n</li>\n<li><p><a href=\"#9\">JavaScript 中的 Currying(柯里化) 和 Partial Application(偏函数应用)</a></p>\n</li>\n</ul>\n<h3 id=\"1-请写出一种实现深拷贝的方法？\"><a href=\"#1-请写出一种实现深拷贝的方法？\" class=\"headerlink\" title=\"1. 请写出一种实现深拷贝的方法？\"></a><span id=\"1\">1. 请写出一种实现深拷贝的方法？</span></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> objDeepCopy = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">source</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sourceCopy = source <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span> ? [] : &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> item <span class=\"keyword\">in</span> source) &#123;</span><br><span class=\"line\">    sourceCopy[item] =</span><br><span class=\"line\">      <span class=\"keyword\">typeof</span> source[item] === <span class=\"string\">\"object\"</span></span><br><span class=\"line\">        ? objDeepCopy(source[item])</span><br><span class=\"line\">        : source[item];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sourceCopy;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-JQ-链式调用的实现方法？\"><a href=\"#2-JQ-链式调用的实现方法？\" class=\"headerlink\" title=\"2. JQ 链式调用的实现方法？\"></a><span id=\"2\">2. JQ 链式调用的实现方法？</span></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aQuery.prototype = &#123;</span><br><span class=\"line\">    init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    name: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">aQuery.init().name()</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-有-arr-a-1-b-2-c-3-obj-d-4-请使用-es6-写出一种方法实现-得到对象-a-1-b-2-c-3-d-4\"><a href=\"#3-有-arr-a-1-b-2-c-3-obj-d-4-请使用-es6-写出一种方法实现-得到对象-a-1-b-2-c-3-d-4\" class=\"headerlink\" title=\"3. 有 arr = [{a:1,{b:2},{c:3}}] obj={d:4} 请使用 es6 写出一种方法实现,得到对象{a:1,b:2,c:3,d:4}\"></a><span id=\"3\">3. 有 arr = [{a:1,{b:2},{c:3}}] obj={d:4} 请使用 es6 写出一种方法实现,得到对象{a:1,b:2,c:3,d:4}</span></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.........</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-Javascript-垃圾收集方法？\"><a href=\"#4-Javascript-垃圾收集方法？\" class=\"headerlink\" title=\"4. Javascript 垃圾收集方法？\"></a><span id=\"4\">4. Javascript 垃圾收集方法？</span></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">回收机制方式</span><br><span class=\"line\">1、定义和用法：垃圾回收机制(GC:Garbage Collection),执行环境负责管理代码执行过程中使用的内存。</span><br><span class=\"line\"></span><br><span class=\"line\">2、原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。</span><br><span class=\"line\"></span><br><span class=\"line\">3. 垃圾回收策略：标记清除(较为常用)和引用计数。</span><br><span class=\"line\"></span><br><span class=\"line\">标记清除：</span><br><span class=\"line\"></span><br><span class=\"line\">　　定义和用法：当变量进入环境时，将变量标记&quot;进入环境&quot;，当变量离开环境时，标记为：&quot;离开环境&quot;。某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。</span><br><span class=\"line\"></span><br><span class=\"line\">　　到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。</span><br><span class=\"line\"></span><br><span class=\"line\">引用计数：</span><br><span class=\"line\"></span><br><span class=\"line\">　　定义和用法：引用计数是跟踪记录每个值被引用的次数。</span><br><span class=\"line\"></span><br><span class=\"line\">　　基本原理：就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象。</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-简单写出-vue-的-MVVM-实现原理\"><a href=\"#5-简单写出-vue-的-MVVM-实现原理\" class=\"headerlink\" title=\"5. 简单写出 vue 的 MVVM 实现原理\"></a><span id=\"5\">5. 简单写出 vue 的 MVVM 实现原理</span></h3><p><a href=\"https://juejin.im/entry/5923973da22b9d005893805a\" target=\"_blank\" rel=\"noopener\">vue 双向绑定原理</a></p>\n<h3 id=\"6-实现-es5reduce-的方法\"><a href=\"#6-实现-es5reduce-的方法\" class=\"headerlink\" title=\"6. 实现 es5reduce 的方法\"></a><span id=\"6\">6. 实现 es5reduce 的方法</span></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// reduce() 从数组第一项开始，逐个遍历到最后</span></span><br><span class=\"line\"><span class=\"comment\">// reduceRight() 从数组的最后一项开始，向前遍历到第一项</span></span><br><span class=\"line\"><span class=\"comment\">// 都支持4个参数。(prev【前一个值】,cur【当前值】,index【项的索引】,array【数组对象】)</span></span><br><span class=\"line\"><span class=\"comment\">// reduce()和reduceRight()的差别在于从哪头开始遍历数组。除此之外都一样。</span></span><br><span class=\"line\"><span class=\"comment\">// 【兼容性】IE9+,Chrome,Firefox 3+,Safari 4+,Opera 10.5支持</span></span><br><span class=\"line\"><span class=\"comment\">// 这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代从数组的第二项开始。</span></span><br><span class=\"line\"><span class=\"comment\">//利用reduce求数组中所有值的和</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> values = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = values.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prev, cur, index, array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> prev + cur;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//sum的值为15;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"7-使用-es5-实现-Promise\"><a href=\"#7-使用-es5-实现-Promise\" class=\"headerlink\" title=\"7. 使用 es5 实现 Promise\"></a><span id=\"7\">7. 使用 es5 实现 Promise</span></h3><p><a href=\"https://blog.csdn.net/yibingxiong1/article/details/68075416\" target=\"_blank\" rel=\"noopener\">实现一个自己的 promise</a></p>\n<h3 id=\"8-什么是单线程-和异步有何关系\"><a href=\"#8-什么是单线程-和异步有何关系\" class=\"headerlink\" title=\"8. 什么是单线程,和异步有何关系\"></a><span id=\"8\">8. 什么是单线程,和异步有何关系</span></h3><p><a href=\"https://blog.csdn.net/ll_0801xyz/article/details/78232621\" target=\"_blank\" rel=\"noopener\">异步和单线程</a><br><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\" target=\"_blank\" rel=\"noopener\">JavaScript 运行机制详解：再谈 Event Loop</a></p>\n<h3 id=\"9-JavaScript-中的-Currying-柯里化-和-Partial-Application-偏函数应用\"><a href=\"#9-JavaScript-中的-Currying-柯里化-和-Partial-Application-偏函数应用\" class=\"headerlink\" title=\"9. JavaScript 中的 Currying(柯里化) 和 Partial Application(偏函数应用)\"></a><span id=\"9\">9. JavaScript 中的 Currying(柯里化) 和 Partial Application(偏函数应用)</span></h3><p><a href=\"http://www.css88.com/archives/7781\" target=\"_blank\" rel=\"noopener\">css88</a></p>\n<p><a href=\"https://blog.csdn.net/wdlhao/article/details/79079660\" target=\"_blank\" rel=\"noopener\">2018 最新 Web 前端经典面试试题及答案</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>2108 前端面试题整理</p>\n</blockquote>","more":"<ul>\n<li><p><a href=\"#1\">请写出一种实现深拷贝的方法？</a></p>\n</li>\n<li><p><a href=\"#2\">JQ 链式调用的实现方法？</a></p>\n</li>\n<li><p><a href=\"#3\">有 arr = [{a:1,{b:2},{c:3}}] obj={d:4} 请使用 es6 写出一种方法实现,得到对象{a:1,b:2,c:3,d:4}</a></p>\n</li>\n<li><p><a href=\"#4\">Javascript 垃圾收集方法？</a></p>\n</li>\n<li><p><a href=\"#5\">简单写出 vue 的 MVVM 实现原理</a></p>\n</li>\n<li><p><a href=\"#6\">实现 es5reduce 的方法</a></p>\n</li>\n<li><p><a href=\"#7\">使用 es5 实现 Promise</a></p>\n</li>\n<li><p><a href=\"#8\">什么是单线程和异步有何关系</a></p>\n</li>\n<li><p><a href=\"#9\">JavaScript 中的 Currying(柯里化) 和 Partial Application(偏函数应用)</a></p>\n</li>\n</ul>\n<h3 id=\"1-请写出一种实现深拷贝的方法？\"><a href=\"#1-请写出一种实现深拷贝的方法？\" class=\"headerlink\" title=\"1. 请写出一种实现深拷贝的方法？\"></a><span id=\"1\">1. 请写出一种实现深拷贝的方法？</span></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> objDeepCopy = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">source</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sourceCopy = source <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span> ? [] : &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> item <span class=\"keyword\">in</span> source) &#123;</span><br><span class=\"line\">    sourceCopy[item] =</span><br><span class=\"line\">      <span class=\"keyword\">typeof</span> source[item] === <span class=\"string\">\"object\"</span></span><br><span class=\"line\">        ? objDeepCopy(source[item])</span><br><span class=\"line\">        : source[item];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sourceCopy;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-JQ-链式调用的实现方法？\"><a href=\"#2-JQ-链式调用的实现方法？\" class=\"headerlink\" title=\"2. JQ 链式调用的实现方法？\"></a><span id=\"2\">2. JQ 链式调用的实现方法？</span></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aQuery.prototype = &#123;</span><br><span class=\"line\">    init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    name: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">aQuery.init().name()</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-有-arr-a-1-b-2-c-3-obj-d-4-请使用-es6-写出一种方法实现-得到对象-a-1-b-2-c-3-d-4\"><a href=\"#3-有-arr-a-1-b-2-c-3-obj-d-4-请使用-es6-写出一种方法实现-得到对象-a-1-b-2-c-3-d-4\" class=\"headerlink\" title=\"3. 有 arr = [{a:1,{b:2},{c:3}}] obj={d:4} 请使用 es6 写出一种方法实现,得到对象{a:1,b:2,c:3,d:4}\"></a><span id=\"3\">3. 有 arr = [{a:1,{b:2},{c:3}}] obj={d:4} 请使用 es6 写出一种方法实现,得到对象{a:1,b:2,c:3,d:4}</span></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.........</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-Javascript-垃圾收集方法？\"><a href=\"#4-Javascript-垃圾收集方法？\" class=\"headerlink\" title=\"4. Javascript 垃圾收集方法？\"></a><span id=\"4\">4. Javascript 垃圾收集方法？</span></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">回收机制方式</span><br><span class=\"line\">1、定义和用法：垃圾回收机制(GC:Garbage Collection),执行环境负责管理代码执行过程中使用的内存。</span><br><span class=\"line\"></span><br><span class=\"line\">2、原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。</span><br><span class=\"line\"></span><br><span class=\"line\">3. 垃圾回收策略：标记清除(较为常用)和引用计数。</span><br><span class=\"line\"></span><br><span class=\"line\">标记清除：</span><br><span class=\"line\"></span><br><span class=\"line\">　　定义和用法：当变量进入环境时，将变量标记&quot;进入环境&quot;，当变量离开环境时，标记为：&quot;离开环境&quot;。某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。</span><br><span class=\"line\"></span><br><span class=\"line\">　　到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。</span><br><span class=\"line\"></span><br><span class=\"line\">引用计数：</span><br><span class=\"line\"></span><br><span class=\"line\">　　定义和用法：引用计数是跟踪记录每个值被引用的次数。</span><br><span class=\"line\"></span><br><span class=\"line\">　　基本原理：就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象。</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-简单写出-vue-的-MVVM-实现原理\"><a href=\"#5-简单写出-vue-的-MVVM-实现原理\" class=\"headerlink\" title=\"5. 简单写出 vue 的 MVVM 实现原理\"></a><span id=\"5\">5. 简单写出 vue 的 MVVM 实现原理</span></h3><p><a href=\"https://juejin.im/entry/5923973da22b9d005893805a\" target=\"_blank\" rel=\"noopener\">vue 双向绑定原理</a></p>\n<h3 id=\"6-实现-es5reduce-的方法\"><a href=\"#6-实现-es5reduce-的方法\" class=\"headerlink\" title=\"6. 实现 es5reduce 的方法\"></a><span id=\"6\">6. 实现 es5reduce 的方法</span></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// reduce() 从数组第一项开始，逐个遍历到最后</span></span><br><span class=\"line\"><span class=\"comment\">// reduceRight() 从数组的最后一项开始，向前遍历到第一项</span></span><br><span class=\"line\"><span class=\"comment\">// 都支持4个参数。(prev【前一个值】,cur【当前值】,index【项的索引】,array【数组对象】)</span></span><br><span class=\"line\"><span class=\"comment\">// reduce()和reduceRight()的差别在于从哪头开始遍历数组。除此之外都一样。</span></span><br><span class=\"line\"><span class=\"comment\">// 【兼容性】IE9+,Chrome,Firefox 3+,Safari 4+,Opera 10.5支持</span></span><br><span class=\"line\"><span class=\"comment\">// 这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代从数组的第二项开始。</span></span><br><span class=\"line\"><span class=\"comment\">//利用reduce求数组中所有值的和</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> values = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = values.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prev, cur, index, array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> prev + cur;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//sum的值为15;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"7-使用-es5-实现-Promise\"><a href=\"#7-使用-es5-实现-Promise\" class=\"headerlink\" title=\"7. 使用 es5 实现 Promise\"></a><span id=\"7\">7. 使用 es5 实现 Promise</span></h3><p><a href=\"https://blog.csdn.net/yibingxiong1/article/details/68075416\" target=\"_blank\" rel=\"noopener\">实现一个自己的 promise</a></p>\n<h3 id=\"8-什么是单线程-和异步有何关系\"><a href=\"#8-什么是单线程-和异步有何关系\" class=\"headerlink\" title=\"8. 什么是单线程,和异步有何关系\"></a><span id=\"8\">8. 什么是单线程,和异步有何关系</span></h3><p><a href=\"https://blog.csdn.net/ll_0801xyz/article/details/78232621\" target=\"_blank\" rel=\"noopener\">异步和单线程</a><br><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\" target=\"_blank\" rel=\"noopener\">JavaScript 运行机制详解：再谈 Event Loop</a></p>\n<h3 id=\"9-JavaScript-中的-Currying-柯里化-和-Partial-Application-偏函数应用\"><a href=\"#9-JavaScript-中的-Currying-柯里化-和-Partial-Application-偏函数应用\" class=\"headerlink\" title=\"9. JavaScript 中的 Currying(柯里化) 和 Partial Application(偏函数应用)\"></a><span id=\"9\">9. JavaScript 中的 Currying(柯里化) 和 Partial Application(偏函数应用)</span></h3><p><a href=\"http://www.css88.com/archives/7781\" target=\"_blank\" rel=\"noopener\">css88</a></p>\n<p><a href=\"https://blog.csdn.net/wdlhao/article/details/79079660\" target=\"_blank\" rel=\"noopener\">2018 最新 Web 前端经典面试试题及答案</a></p>"},{"title":"前端面试","date":"2019-02-22T01:44:20.000Z","_content":"\n> 前端知识点 summarize\n\n<!--- more -->\n\n### 一、JavaScript 运行机制详解：谈 Event Loop\n\n js 特点单线程，作为浏览器脚本语言，用途是与用户交互操作 dom，若有多个线程，一个线程在某个 dom 添加内容，另一个在删除内容，浏览器不知以哪个为准，所以单线程，为了利用多核 cpu 的计算能力，HTML5 提出 Web Worker 标准，允许 js 脚本创建多个线程，但子线程完全受主线程控制，且不得操作 DOM。因此新标准并未改变 js 单线程的本质。\n\n单线程必须前一个任务完成才能执行下一个，出现等待很长的问题，很多时候 cpu 是空着的，由于 IO 设备（ajax 网络读数据）很慢，js 语言的设计者意识到，这时主线程完全可以不管 IO 设备，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 设备返回了结果，再回过头把挂起的任务继续执行下去。\n\n任务分为 同步任务（在主线程执行）和异步任务（挂起，进入任务队列），只有\"任务队列\"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行\n\n---\n\n**异步执行的运行机制**\n\n    1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。\n\n    2）主线程之外，还存在一个\"任务队列\"（task queue）。只要异步任务有了运行结果，就在\"任务队列\"之中放置一个事件。\n\n    3）一旦\"执行栈\"中的所有同步任务执行完毕，系统就会读取\"任务队列\"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。\n\n       除了 IO 设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入\"任务队列\"，等待主线程读取。\n\n    4）主线程不断重复上面的第三步。\n\n所谓\"回调函数\"（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。\n\n主线程从\"任务队列\"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）。\n\n#### 定时器\n\n除了放置异步任务的事件，\"任务队列\"还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做\"定时器\"（timer）功能，也就是定时执行的代码。\n\n### 二、浏览器多进程到 JS 单线程\n\n1. 浏览器是多进程的\n2. 各个进程之间相互独立（可通讯，代价大）\n3. 一个进程由一个或多个线程组成，多个线程在进程中协作完成任务\n4. 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）\n\n---\n\n> 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存（独立的））\n\n  - . Browser 进程：浏览器的主进程（负责协调、主控），只有一个\n      ```\n       负责浏览器界面显示，与用户交互。如前进，后退等\n       负责各个页面的管理，创建和销毁其他进程\n       将 Renderer 进程得到的内存中的 Bitmap，绘制到用户界面上\n       网络资源的管理，下载等\n      ```\n  - . 浏览器渲染进程（浏览器内核）（Renderer 进程，内部多线程）\n      ```\n       默认每个 Tab 页面一个进程，互不影响（有时打开多个 tab 页后，可在 Chrome 任务管理器中看到，有些进程被合并了 （所以每一个 Tab 标签对应一个进程并不一定是绝对的，浏览器优化机制））\n       主要作用为页面渲染，脚本执行，事件处理等\n      ```\n  - . 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建\n  - . GPU 进程：最多一个，用于 3D 绘制等\n\n**_进程是 cpu 资源分配的最小单位（是能拥有资源和独立运行的最小单位）_**\n**_线程是 cpu 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）_**\n\n#### 浏览器多进程的优势\n\n1. 避免单个 page crash 影响整个浏览器\n2. 避免第三方插件 crash 影响整个浏览器\n3. 多进程充分利用多核优势\n4. 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性\n\n**内存等资源消耗也会更大，有点空间换时间的意思。**\n\n#### 重点renderer，Browser进程，以及相互之间的通讯\n\n***GUI渲染线程与JS引擎线程互斥，JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞***\n\n> 为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起， GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。\n\n  1. GUI渲染线程\n\n        负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。\n        当页面Repaint或reflow，该线程就会执行\n\n  2. JS引擎线程（JS内核）\n\n        负责解析Javascript脚本，运行代码，一个renderer进程只有一个js线程\n\n  3. 事件触发线程\n\n        属于浏览器而不是JS引擎，来控制事件循环（需浏览器另开线程协助），将异步任务添至任务队列\n\n  4. 定时触发器线程（setInterval与setTimeout所在线程）\n  \n        浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）\n        因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）\n\n  5. 异步http请求线程\n\n        在XMLHttpRequest在连接后是通过浏览器新开一个线程请求\n        将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。\n\n##### 过程：首先Browser进程收到用户请求，通过RendererHost接口传递给render进程，render进程交给GUI渲染线程，GUI加载并渲染网页（可能有JS线程操作DOM，会造成回流并重绘），最后 Render进程将结果传递给Browser进程，Browser进程接收到结果并将结果绘制出来\n\n##### 详解\n\n    1. 浏览器输入url，浏览器主进程接管，开一个下载线程，\n    2. 然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，\n    3. 随后将内容通过RendererHost接口转交给Renderer进程\n    4. 浏览器渲染流程开始\n\n        * 解析html建立dom树\n        * 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）\n        * 布局render树（Layout/reflow），负责各元素尺寸、位置的计算\n        * 绘制render树（paint），绘制页面像素信息\n        * 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。\n        * 渲染完毕后就是load事件，之后就是自己的JS逻辑处理了，当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。 （渲染完毕了）\n\n注： css加载不会阻塞DOM树解析，但会阻塞render树渲染\n\n来源：https://juejin.im/post/5a6547d0f265da3e283a1df7\n\n","source":"_posts/面试/summary.md","raw":"---\ntitle: 前端面试\ncategories:\n  - 前端技术\ntags:\n  - 前端面试\ndate: 2019-02-22 09:44:20\n---\n\n> 前端知识点 summarize\n\n<!--- more -->\n\n### 一、JavaScript 运行机制详解：谈 Event Loop\n\n js 特点单线程，作为浏览器脚本语言，用途是与用户交互操作 dom，若有多个线程，一个线程在某个 dom 添加内容，另一个在删除内容，浏览器不知以哪个为准，所以单线程，为了利用多核 cpu 的计算能力，HTML5 提出 Web Worker 标准，允许 js 脚本创建多个线程，但子线程完全受主线程控制，且不得操作 DOM。因此新标准并未改变 js 单线程的本质。\n\n单线程必须前一个任务完成才能执行下一个，出现等待很长的问题，很多时候 cpu 是空着的，由于 IO 设备（ajax 网络读数据）很慢，js 语言的设计者意识到，这时主线程完全可以不管 IO 设备，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 设备返回了结果，再回过头把挂起的任务继续执行下去。\n\n任务分为 同步任务（在主线程执行）和异步任务（挂起，进入任务队列），只有\"任务队列\"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行\n\n---\n\n**异步执行的运行机制**\n\n    1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。\n\n    2）主线程之外，还存在一个\"任务队列\"（task queue）。只要异步任务有了运行结果，就在\"任务队列\"之中放置一个事件。\n\n    3）一旦\"执行栈\"中的所有同步任务执行完毕，系统就会读取\"任务队列\"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。\n\n       除了 IO 设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入\"任务队列\"，等待主线程读取。\n\n    4）主线程不断重复上面的第三步。\n\n所谓\"回调函数\"（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。\n\n主线程从\"任务队列\"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）。\n\n#### 定时器\n\n除了放置异步任务的事件，\"任务队列\"还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做\"定时器\"（timer）功能，也就是定时执行的代码。\n\n### 二、浏览器多进程到 JS 单线程\n\n1. 浏览器是多进程的\n2. 各个进程之间相互独立（可通讯，代价大）\n3. 一个进程由一个或多个线程组成，多个线程在进程中协作完成任务\n4. 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）\n\n---\n\n> 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存（独立的））\n\n  - . Browser 进程：浏览器的主进程（负责协调、主控），只有一个\n      ```\n       负责浏览器界面显示，与用户交互。如前进，后退等\n       负责各个页面的管理，创建和销毁其他进程\n       将 Renderer 进程得到的内存中的 Bitmap，绘制到用户界面上\n       网络资源的管理，下载等\n      ```\n  - . 浏览器渲染进程（浏览器内核）（Renderer 进程，内部多线程）\n      ```\n       默认每个 Tab 页面一个进程，互不影响（有时打开多个 tab 页后，可在 Chrome 任务管理器中看到，有些进程被合并了 （所以每一个 Tab 标签对应一个进程并不一定是绝对的，浏览器优化机制））\n       主要作用为页面渲染，脚本执行，事件处理等\n      ```\n  - . 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建\n  - . GPU 进程：最多一个，用于 3D 绘制等\n\n**_进程是 cpu 资源分配的最小单位（是能拥有资源和独立运行的最小单位）_**\n**_线程是 cpu 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）_**\n\n#### 浏览器多进程的优势\n\n1. 避免单个 page crash 影响整个浏览器\n2. 避免第三方插件 crash 影响整个浏览器\n3. 多进程充分利用多核优势\n4. 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性\n\n**内存等资源消耗也会更大，有点空间换时间的意思。**\n\n#### 重点renderer，Browser进程，以及相互之间的通讯\n\n***GUI渲染线程与JS引擎线程互斥，JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞***\n\n> 为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起， GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。\n\n  1. GUI渲染线程\n\n        负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。\n        当页面Repaint或reflow，该线程就会执行\n\n  2. JS引擎线程（JS内核）\n\n        负责解析Javascript脚本，运行代码，一个renderer进程只有一个js线程\n\n  3. 事件触发线程\n\n        属于浏览器而不是JS引擎，来控制事件循环（需浏览器另开线程协助），将异步任务添至任务队列\n\n  4. 定时触发器线程（setInterval与setTimeout所在线程）\n  \n        浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）\n        因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）\n\n  5. 异步http请求线程\n\n        在XMLHttpRequest在连接后是通过浏览器新开一个线程请求\n        将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。\n\n##### 过程：首先Browser进程收到用户请求，通过RendererHost接口传递给render进程，render进程交给GUI渲染线程，GUI加载并渲染网页（可能有JS线程操作DOM，会造成回流并重绘），最后 Render进程将结果传递给Browser进程，Browser进程接收到结果并将结果绘制出来\n\n##### 详解\n\n    1. 浏览器输入url，浏览器主进程接管，开一个下载线程，\n    2. 然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，\n    3. 随后将内容通过RendererHost接口转交给Renderer进程\n    4. 浏览器渲染流程开始\n\n        * 解析html建立dom树\n        * 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）\n        * 布局render树（Layout/reflow），负责各元素尺寸、位置的计算\n        * 绘制render树（paint），绘制页面像素信息\n        * 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。\n        * 渲染完毕后就是load事件，之后就是自己的JS逻辑处理了，当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。 （渲染完毕了）\n\n注： css加载不会阻塞DOM树解析，但会阻塞render树渲染\n\n来源：https://juejin.im/post/5a6547d0f265da3e283a1df7\n\n","slug":"面试/summary","published":1,"updated":"2019-02-26T05:41:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3dn000yuox1t759h1vn","content":"<blockquote>\n<p>前端知识点 summarize</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"一、JavaScript-运行机制详解：谈-Event-Loop\"><a href=\"#一、JavaScript-运行机制详解：谈-Event-Loop\" class=\"headerlink\" title=\"一、JavaScript 运行机制详解：谈 Event Loop\"></a>一、JavaScript 运行机制详解：谈 Event Loop</h3><p> js 特点单线程，作为浏览器脚本语言，用途是与用户交互操作 dom，若有多个线程，一个线程在某个 dom 添加内容，另一个在删除内容，浏览器不知以哪个为准，所以单线程，为了利用多核 cpu 的计算能力，HTML5 提出 Web Worker 标准，允许 js 脚本创建多个线程，但子线程完全受主线程控制，且不得操作 DOM。因此新标准并未改变 js 单线程的本质。</p>\n<p>单线程必须前一个任务完成才能执行下一个，出现等待很长的问题，很多时候 cpu 是空着的，由于 IO 设备（ajax 网络读数据）很慢，js 语言的设计者意识到，这时主线程完全可以不管 IO 设备，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 设备返回了结果，再回过头把挂起的任务继续执行下去。</p>\n<p>任务分为 同步任务（在主线程执行）和异步任务（挂起，进入任务队列），只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行</p>\n<hr>\n<p><strong>异步执行的运行机制</strong></p>\n<pre><code>1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。\n\n2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。\n\n3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。\n\n   除了 IO 设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入&quot;任务队列&quot;，等待主线程读取。\n\n4）主线程不断重复上面的第三步。\n</code></pre><p>所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。</p>\n<p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）。</p>\n<h4 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h4><p>除了放置异步任务的事件，”任务队列”还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做”定时器”（timer）功能，也就是定时执行的代码。</p>\n<h3 id=\"二、浏览器多进程到-JS-单线程\"><a href=\"#二、浏览器多进程到-JS-单线程\" class=\"headerlink\" title=\"二、浏览器多进程到 JS 单线程\"></a>二、浏览器多进程到 JS 单线程</h3><ol>\n<li>浏览器是多进程的</li>\n<li>各个进程之间相互独立（可通讯，代价大）</li>\n<li>一个进程由一个或多个线程组成，多个线程在进程中协作完成任务</li>\n<li>同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）</li>\n</ol>\n<hr>\n<blockquote>\n<p>浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存（独立的））</p>\n</blockquote>\n<ul>\n<li><p>. Browser 进程：浏览器的主进程（负责协调、主控），只有一个</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">负责浏览器界面显示，与用户交互。如前进，后退等</span><br><span class=\"line\">负责各个页面的管理，创建和销毁其他进程</span><br><span class=\"line\">将 Renderer 进程得到的内存中的 Bitmap，绘制到用户界面上</span><br><span class=\"line\">网络资源的管理，下载等</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>. 浏览器渲染进程（浏览器内核）（Renderer 进程，内部多线程）</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">默认每个 Tab 页面一个进程，互不影响（有时打开多个 tab 页后，可在 Chrome 任务管理器中看到，有些进程被合并了 （所以每一个 Tab 标签对应一个进程并不一定是绝对的，浏览器优化机制））</span><br><span class=\"line\">主要作用为页面渲染，脚本执行，事件处理等</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>. 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</p>\n</li>\n<li>. GPU 进程：最多一个，用于 3D 绘制等</li>\n</ul>\n<p><strong><em>进程是 cpu 资源分配的最小单位（是能拥有资源和独立运行的最小单位）</em></strong><br><strong><em>线程是 cpu 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</em></strong></p>\n<h4 id=\"浏览器多进程的优势\"><a href=\"#浏览器多进程的优势\" class=\"headerlink\" title=\"浏览器多进程的优势\"></a>浏览器多进程的优势</h4><ol>\n<li>避免单个 page crash 影响整个浏览器</li>\n<li>避免第三方插件 crash 影响整个浏览器</li>\n<li>多进程充分利用多核优势</li>\n<li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</li>\n</ol>\n<p><strong>内存等资源消耗也会更大，有点空间换时间的意思。</strong></p>\n<h4 id=\"重点renderer，Browser进程，以及相互之间的通讯\"><a href=\"#重点renderer，Browser进程，以及相互之间的通讯\" class=\"headerlink\" title=\"重点renderer，Browser进程，以及相互之间的通讯\"></a>重点renderer，Browser进程，以及相互之间的通讯</h4><p><strong><em>GUI渲染线程与JS引擎线程互斥，JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞</em></strong></p>\n<blockquote>\n<p>为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起， GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。</p>\n</blockquote>\n<ol>\n<li><p>GUI渲染线程</p>\n<p>   负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。<br>   当页面Repaint或reflow，该线程就会执行</p>\n</li>\n<li><p>JS引擎线程（JS内核）</p>\n<p>   负责解析Javascript脚本，运行代码，一个renderer进程只有一个js线程</p>\n</li>\n<li><p>事件触发线程</p>\n<p>   属于浏览器而不是JS引擎，来控制事件循环（需浏览器另开线程协助），将异步任务添至任务队列</p>\n</li>\n<li><p>定时触发器线程（setInterval与setTimeout所在线程）</p>\n<p>   浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）<br>   因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</p>\n</li>\n<li><p>异步http请求线程</p>\n<p>   在XMLHttpRequest在连接后是通过浏览器新开一个线程请求<br>   将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。</p>\n</li>\n</ol>\n<h5 id=\"过程：首先Browser进程收到用户请求，通过RendererHost接口传递给render进程，render进程交给GUI渲染线程，GUI加载并渲染网页（可能有JS线程操作DOM，会造成回流并重绘），最后-Render进程将结果传递给Browser进程，Browser进程接收到结果并将结果绘制出来\"><a href=\"#过程：首先Browser进程收到用户请求，通过RendererHost接口传递给render进程，render进程交给GUI渲染线程，GUI加载并渲染网页（可能有JS线程操作DOM，会造成回流并重绘），最后-Render进程将结果传递给Browser进程，Browser进程接收到结果并将结果绘制出来\" class=\"headerlink\" title=\"过程：首先Browser进程收到用户请求，通过RendererHost接口传递给render进程，render进程交给GUI渲染线程，GUI加载并渲染网页（可能有JS线程操作DOM，会造成回流并重绘），最后 Render进程将结果传递给Browser进程，Browser进程接收到结果并将结果绘制出来\"></a>过程：首先Browser进程收到用户请求，通过RendererHost接口传递给render进程，render进程交给GUI渲染线程，GUI加载并渲染网页（可能有JS线程操作DOM，会造成回流并重绘），最后 Render进程将结果传递给Browser进程，Browser进程接收到结果并将结果绘制出来</h5><h5 id=\"详解\"><a href=\"#详解\" class=\"headerlink\" title=\"详解\"></a>详解</h5><pre><code>1. 浏览器输入url，浏览器主进程接管，开一个下载线程，\n2. 然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，\n3. 随后将内容通过RendererHost接口转交给Renderer进程\n4. 浏览器渲染流程开始\n\n    * 解析html建立dom树\n    * 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）\n    * 布局render树（Layout/reflow），负责各元素尺寸、位置的计算\n    * 绘制render树（paint），绘制页面像素信息\n    * 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。\n    * 渲染完毕后就是load事件，之后就是自己的JS逻辑处理了，当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。 （渲染完毕了）\n</code></pre><p>注： css加载不会阻塞DOM树解析，但会阻塞render树渲染</p>\n<p>来源：<a href=\"https://juejin.im/post/5a6547d0f265da3e283a1df7\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5a6547d0f265da3e283a1df7</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>前端知识点 summarize</p>\n</blockquote>","more":"<h3 id=\"一、JavaScript-运行机制详解：谈-Event-Loop\"><a href=\"#一、JavaScript-运行机制详解：谈-Event-Loop\" class=\"headerlink\" title=\"一、JavaScript 运行机制详解：谈 Event Loop\"></a>一、JavaScript 运行机制详解：谈 Event Loop</h3><p> js 特点单线程，作为浏览器脚本语言，用途是与用户交互操作 dom，若有多个线程，一个线程在某个 dom 添加内容，另一个在删除内容，浏览器不知以哪个为准，所以单线程，为了利用多核 cpu 的计算能力，HTML5 提出 Web Worker 标准，允许 js 脚本创建多个线程，但子线程完全受主线程控制，且不得操作 DOM。因此新标准并未改变 js 单线程的本质。</p>\n<p>单线程必须前一个任务完成才能执行下一个，出现等待很长的问题，很多时候 cpu 是空着的，由于 IO 设备（ajax 网络读数据）很慢，js 语言的设计者意识到，这时主线程完全可以不管 IO 设备，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 设备返回了结果，再回过头把挂起的任务继续执行下去。</p>\n<p>任务分为 同步任务（在主线程执行）和异步任务（挂起，进入任务队列），只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行</p>\n<hr>\n<p><strong>异步执行的运行机制</strong></p>\n<pre><code>1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。\n\n2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。\n\n3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。\n\n   除了 IO 设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入&quot;任务队列&quot;，等待主线程读取。\n\n4）主线程不断重复上面的第三步。\n</code></pre><p>所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。</p>\n<p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）。</p>\n<h4 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h4><p>除了放置异步任务的事件，”任务队列”还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做”定时器”（timer）功能，也就是定时执行的代码。</p>\n<h3 id=\"二、浏览器多进程到-JS-单线程\"><a href=\"#二、浏览器多进程到-JS-单线程\" class=\"headerlink\" title=\"二、浏览器多进程到 JS 单线程\"></a>二、浏览器多进程到 JS 单线程</h3><ol>\n<li>浏览器是多进程的</li>\n<li>各个进程之间相互独立（可通讯，代价大）</li>\n<li>一个进程由一个或多个线程组成，多个线程在进程中协作完成任务</li>\n<li>同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）</li>\n</ol>\n<hr>\n<blockquote>\n<p>浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存（独立的））</p>\n</blockquote>\n<ul>\n<li><p>. Browser 进程：浏览器的主进程（负责协调、主控），只有一个</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">负责浏览器界面显示，与用户交互。如前进，后退等</span><br><span class=\"line\">负责各个页面的管理，创建和销毁其他进程</span><br><span class=\"line\">将 Renderer 进程得到的内存中的 Bitmap，绘制到用户界面上</span><br><span class=\"line\">网络资源的管理，下载等</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>. 浏览器渲染进程（浏览器内核）（Renderer 进程，内部多线程）</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">默认每个 Tab 页面一个进程，互不影响（有时打开多个 tab 页后，可在 Chrome 任务管理器中看到，有些进程被合并了 （所以每一个 Tab 标签对应一个进程并不一定是绝对的，浏览器优化机制））</span><br><span class=\"line\">主要作用为页面渲染，脚本执行，事件处理等</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>. 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</p>\n</li>\n<li>. GPU 进程：最多一个，用于 3D 绘制等</li>\n</ul>\n<p><strong><em>进程是 cpu 资源分配的最小单位（是能拥有资源和独立运行的最小单位）</em></strong><br><strong><em>线程是 cpu 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</em></strong></p>\n<h4 id=\"浏览器多进程的优势\"><a href=\"#浏览器多进程的优势\" class=\"headerlink\" title=\"浏览器多进程的优势\"></a>浏览器多进程的优势</h4><ol>\n<li>避免单个 page crash 影响整个浏览器</li>\n<li>避免第三方插件 crash 影响整个浏览器</li>\n<li>多进程充分利用多核优势</li>\n<li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</li>\n</ol>\n<p><strong>内存等资源消耗也会更大，有点空间换时间的意思。</strong></p>\n<h4 id=\"重点renderer，Browser进程，以及相互之间的通讯\"><a href=\"#重点renderer，Browser进程，以及相互之间的通讯\" class=\"headerlink\" title=\"重点renderer，Browser进程，以及相互之间的通讯\"></a>重点renderer，Browser进程，以及相互之间的通讯</h4><p><strong><em>GUI渲染线程与JS引擎线程互斥，JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞</em></strong></p>\n<blockquote>\n<p>为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起， GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。</p>\n</blockquote>\n<ol>\n<li><p>GUI渲染线程</p>\n<p>   负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。<br>   当页面Repaint或reflow，该线程就会执行</p>\n</li>\n<li><p>JS引擎线程（JS内核）</p>\n<p>   负责解析Javascript脚本，运行代码，一个renderer进程只有一个js线程</p>\n</li>\n<li><p>事件触发线程</p>\n<p>   属于浏览器而不是JS引擎，来控制事件循环（需浏览器另开线程协助），将异步任务添至任务队列</p>\n</li>\n<li><p>定时触发器线程（setInterval与setTimeout所在线程）</p>\n<p>   浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）<br>   因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</p>\n</li>\n<li><p>异步http请求线程</p>\n<p>   在XMLHttpRequest在连接后是通过浏览器新开一个线程请求<br>   将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。</p>\n</li>\n</ol>\n<h5 id=\"过程：首先Browser进程收到用户请求，通过RendererHost接口传递给render进程，render进程交给GUI渲染线程，GUI加载并渲染网页（可能有JS线程操作DOM，会造成回流并重绘），最后-Render进程将结果传递给Browser进程，Browser进程接收到结果并将结果绘制出来\"><a href=\"#过程：首先Browser进程收到用户请求，通过RendererHost接口传递给render进程，render进程交给GUI渲染线程，GUI加载并渲染网页（可能有JS线程操作DOM，会造成回流并重绘），最后-Render进程将结果传递给Browser进程，Browser进程接收到结果并将结果绘制出来\" class=\"headerlink\" title=\"过程：首先Browser进程收到用户请求，通过RendererHost接口传递给render进程，render进程交给GUI渲染线程，GUI加载并渲染网页（可能有JS线程操作DOM，会造成回流并重绘），最后 Render进程将结果传递给Browser进程，Browser进程接收到结果并将结果绘制出来\"></a>过程：首先Browser进程收到用户请求，通过RendererHost接口传递给render进程，render进程交给GUI渲染线程，GUI加载并渲染网页（可能有JS线程操作DOM，会造成回流并重绘），最后 Render进程将结果传递给Browser进程，Browser进程接收到结果并将结果绘制出来</h5><h5 id=\"详解\"><a href=\"#详解\" class=\"headerlink\" title=\"详解\"></a>详解</h5><pre><code>1. 浏览器输入url，浏览器主进程接管，开一个下载线程，\n2. 然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，\n3. 随后将内容通过RendererHost接口转交给Renderer进程\n4. 浏览器渲染流程开始\n\n    * 解析html建立dom树\n    * 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）\n    * 布局render树（Layout/reflow），负责各元素尺寸、位置的计算\n    * 绘制render树（paint），绘制页面像素信息\n    * 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。\n    * 渲染完毕后就是load事件，之后就是自己的JS逻辑处理了，当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。 （渲染完毕了）\n</code></pre><p>注： css加载不会阻塞DOM树解析，但会阻塞render树渲染</p>\n<p>来源：<a href=\"https://juejin.im/post/5a6547d0f265da3e283a1df7\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5a6547d0f265da3e283a1df7</a></p>"},{"title":"前端面试","date":"2018-04-12T02:03:20.000Z","_content":"\n> 总结网易前端面试的一些题目，做准备， I will go to work in big wangyi company next year，Wish myself good luck.\n\n<!--- more -->\n\n* [=＝和===的区别？＝＝怎么进行类型转换的，说说有哪几种情况？](#0)\n\n* [布局：一个 div(200px*200px)在左侧，另一个 div 自适应在右侧](#1)\n\n* [给 Object 扩展一个方法 clone，实现深度克隆对象](#2)\n\n* [px、em、rem](#3)\n\n* [用 html,css 实现一个 div 居中在窗口](#4)\n\n* [用css实现，两行文本，间距10px,字体是14px,距顶端和底端15px,拒左边10px](#5)\n\n* [扩展Date的format方法](#6)\n\n* [写出下面结果](#7)\n\n* [alert(1&&2),alert(1||0)](#8)\n\n* [mouseenter和mouseover的区别](#9)\n\n* [js字符串两边截取空白的trim的原型方法的实现](#10)\n\n* [三道判断输出的题都是经典的题](#11)\n\n* [position不同值和区别](#12)\n\n* [讲述你对reflow和repaint的理解](#13)\n\n* [讲述你对reflow和repaint的理解](#14)\n\n\n\n### <span id='0'>1. =＝和===的区别？＝＝怎么进行类型转换的，说说有哪几种情况？</span>\n\n    ==匹配两个变量的的值，如果类型不匹配，会强制类型转换，\n    ===不但匹配两个变量的值，还会匹配两个变量的数据类型是否相同，如果其中有一项不相同，匹配失败。\n    ===不会类型转换，执行效率高。\n\n### <span id='1'>2. 布局：一个 div(200px*200px)在左侧，另一个 div 自适应在右侧</span>\n\n1.  如果不考虑浏览器的兼容问题的话，可以使用 css3 的新增属性 calc();calc 是 calculate 的简写，汉语为计算的意思。\n```css\n  .left {\n    width: 200px;\n    float: left;\n    height: 200px;\n    background: pink;\n  }\n  .right {\n    float: left;\n    width: calc(100% - 200px);\n    height: 200px;\n    background: yellow;\n  }\n```\n2.  可以使用百分比进行布局，该方法不需考虑浏览器的兼容性.但与第一种进行比较， 右侧 div 的宽度百分比需要自己去进行计算。\n```css\n  // 要依赖父元素\n  .left {\n    width: 200px;\n    float: left;\n    height: 200px;\n    background: pink;\n  }\n  .right {\n    float: left;\n    width: 85%;\n    height: 200px;\n    background: yellow;\n  }\n```\n\n3.  使用绝对元素进行定位\n\n\n```css\n.left {\n  width: 200px;\n  height: 200px;\n  position: absolute;\n  background: pink;\n}\n.right {\n  left: 200px;\n  right: 0;\n  height: 200px;\n  position: absolute;\n  background: yellow;\n}\n```\n\n4.  div 的宽度在不进行设置的情况下会自动填满父标签的宽度。所以我们可以并不对右侧 div 的宽度进行设置\n\n\n```css\n.left {\n  width: 200px;\n  height: 300px;\n  float: left;\n  background: pink;\n}\n.right {\n  height: 300px;\n  margin-left: 200px;\n  background: yellow;\n}\n```\n\n5.  flex 布局\n\n\n```css\n// 要依赖父元素\n.container {\n  width: 1000px;\n  height: 400px;\n  border: 1px solid red;\n  display: flex; /*flex布局*/\n}\n.left {\n  width: 200px;\n  height: 100%;\n  background: gray;\n  flex: none;\n}\n.right {\n  height: 100%;\n  background: green;\n  flex: 1; /*flex布局*/\n}\n```\n\n6.  table 布局\n    // 要依赖父元素\n\n\n```css\n.container {\n  width: 1000px;\n  height: 400px;\n  border: 1px solid red;\n  display: table; /*table布局*/\n}\n.left {\n  width: 200px;\n  height: 100%;\n  background: gray;\n  display: table-cell;\n}\n.right {\n  height: 100%;\n  background: green;\n  display: table-cell;\n}\n```\n7.  BFC(块级格式化上下文)\n```css\n.container {\n  width: 1000px;\n  height: 400px;\n  border: 1px solid red;\n}\n.left {\n  width: 200px;\n  height: 100%;\n  background: gray;\n  float: left;\n}\n.rigth {\n  overflow: hidden; /* 触发bfc */\n  background: green;\n}\n```\n\n### <span id='2'>3. 给 Object 扩展一个方法 clone，实现深度克隆对象</span>\n\n[javaScript 中浅拷贝和深拷贝的实现](javaScript中浅拷贝和深拷贝的实现)\n\n### <span id='3'>4. px、em、rem</span>\n\n> 有何区别\n\n* px 在缩放页面时无法调整那些使用它作为单位的字体、按钮等的大小；\n* em 的值并不是固定的，会继承父级元素的字体大小，代表倍数；\n* rem 的值并不是固定的，始终是基于根元素 html 的，也代表倍数。\n\n> em\n\nem 的使用是相对于其父级的字体大小的，即倍数。浏览器的默认字体高都是 16px，未经调整的浏览器显示 1em = 16px。但是有一个问题，如果设置 1.2em 则变成 19.2px，问题是 px 表示大小时数值会忽略掉小数位的（你想像不出来半个像素吧）。而且 1em = 16px 的关系不好转换，因此，常常人为地使 1em = 10px。这里要借助字体的 % 来作为桥梁。\n\n因为默认时字体 16px = 100%，则有 10px = 62.5%。所以首先在 body 中全局声明 font-size=62.5%=10px，也就是定义了网页 body 默认字体大小为 10px，由于 em 有继承父级元素字体大小的特性，如果某元素的父级没有设定字体大小，那么它就继续了 body 默认字体大小 1em = 10px。\n\n但是由于 em 是相对于其父级字体的倍数的，当出现有多重嵌套内容时，使用 em 分别给它们设置字体的大小往往要重新计算。比如说你在父级中声明了字体大小为 1.2em，那么在声明子元素的字体大小时设置 1em 才能和父级元素内容字体大小一致，而不是 1.2em（避免 1.2\\*1.2=1.44em）, 因为此 em 非彼 em。再举个例子：\n\n`<span>Outer <span>inner</span> outer</span>`\n\n```css\nbody {\n  font-size: 62.5%;\n}\nspan {\n  font-size: 1.6em;\n}\n```\n\n> rem\n\nrem 的出现再也不用担心还要根据父级元素的 font-size 计算 em 值了，因为它始终是基于根元素（<html>）的。比如默认的 html font-size=16px，那么想设置 12px 的文字就是：12÷16=0.75(rem)\n仍然是上面的例子，CSS 改为：\n\n```css\nhtml {\n  font-size: 62.5%;\n}\nspan {\n  font-size: 16px;\n  font-size: 1.6rem;\n}\n```\n\n结果：内外 <span> 的内容均为 16px。\n\n> 需要注意的是，为了兼容不支持 rem 的浏览器，我们需要在各个使用了 rem 地方前面写上对应的 px 值，这样不支持的浏览器可以优雅降级。\n\n### <span id='4'>5. 用 html,css 实现一个 div 居中在窗口</span>\n\n  1. Flex 布局, 不考虑兼容老式浏览器的话，用Flex布局简单直观一劳永逸\n\n  ```css\n      .out{\n          width: 200px;\n          height: 200px;\n          background: pink;\n          display: flex;\n          display: -webkit-flex; /* Safari */\n          /*align-items:center;    /* 处理垂直居中 */\n      }\n      .in {\n          width: 100px;\n          height: 100px;\n          background: blue;\n          margin: auto;           /* 水平垂直居中 */\n          word-wrap: break-word;  /*如果是字母数字， 处理换行 */\n      }\n  ```\n\n  2. 不知道自己高度的情况下, 利用绝对定位，结合transform: translate（）属性。\n\n    ```css\n        .out{\n        width: 200px; \n        height: 200px;\n        background: pink;\n        position: relative;\n        }\n        .in {\n        background: blue;\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        }\n    ```\n  3. 已知容器高度的情况下，利用定位\n\n    ```css\n        .out {\n            width: 200px; \n            height: 200px;\n            background: pink;\n            position: relative;\n        }\n        .in {\n            width: 100px;\n            height: 100px;\n            background: blue;\n            position: absolute;\n            /*第一种*/\n            top: 50%;\n            left: 50%;\n            margin-top:-50px;\n            margin-left:-50px;\n            /*第二种*/\n            top:0;\n            right:0;\n            bottom:0;\n            left:0;\n            margin:auto;\n        }\n    ```\n\n  4. 已知容器高度， 利用display: table-cell;\n\n    ```css\n        .out{\n            width: 200px;\n            height: 200px;\n            background: pink;\n            display:table-cell;\n            vertical-align:middle;\n        }\n\n        .in {\n            width: 100px;\n            height: 100px;\n            background: blue;\n            margin: 0 auto;\n        }\n    ```\n\n### <span id='5'>6. 用css实现，两行文本，间距10px,字体是14px,距顶端和底端15px,拒左边10px</span>\n\n> word-spacing 对中文没有作用， 对字母有作用，从空格隔那开始起作用，而letter-spacing对两者都有作用，是字间的距离，包括空格哪里的也会隔开\n\n    ```css\n    .out{\n        font-size: 14px;\n        letter-spacing: 10px;\n        padding: 15px 0 15px 10px;\n    }\n    ```\n\n### <span id='6'>7. 扩展Date的format方法</span>\n\n```js\nDate.prototype.format = function (format) {\n    var o = {\n        \"M+\": this.getMonth() + 1,\n        \"d+\": this.getDate(),\n        \"h+\": this.getHours(),\n        \"m+\": this.getMinutes(),\n        \"s+\": this.getSeconds(),\n        \"q+\": Math.floor((this.getMonth() + 3) / 3),\n        \"S\": this.getMilliseconds()\n    };\n    if (/(y+)/.test(format)) {\n        format = format.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n    }\n    for (var k in o) {\n        if (new RegExp(\"(\" + k + \")\").test(format)) {\n            format = format.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : (\"00\" + o[k]).substr((\"\" + o[k]).length));\n        }\n    }\n    return format;\n};\n```\n### <span id='7'>8. 写出下面结果</spanid>\n\n```js\n　　function b(c){\n　　　　console.log(c);\n　　　　function c(){\n　　　　　　　console.log(\"d\");\n　　　　}\n　　}\n　　b(10);\n\n// 结果 function c(){ console.log(\"d\"); }\n```\n### <span id='8'>9. alert(1&&2),alert(1||0) </span>\n\n    alert(1&&2)的结果是2\n    只要“&&”前面是false，无论“&&”后面是true还是false，结果都将返“&&”前面的值;\n    只要“&&”前面是true，无论“&&”后面是true还是false，结果都将返“&&”后面的值;\n    alert(0||1)的结果是1\n    只要“||”前面为false,不管“||”后面是true还是false，都返回“||”后面的值。\n    只要“||”前面为true,不管“||”后面是true还是false，都返回“||”前面的值。\n\n### <span id='9'>10. mouseenter和mouseover的区别</span>\n\n    mouseover事件：不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。\n    mouseenter事件：只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。\n    mouseout事件：不论鼠标指针离开被选元素还是任何子元素，都会触发 mouseout 事件。\n    mouseleave事件：只有在鼠标指针离开被选元素时，才会触发 mouseleave 事件。\n\n### <span id='10'> 11. js字符串两边截取空白的trim的原型方法的实现</span>\n```js\n//我的笨方法，当时还想错了一些，回来后实现了一下，思路是这样\nString.prototype.trim = function () {\n    var arr=this.split(\"\");\n    while(1) {\n       if(arr[0]==\" \") {\n           arr.shift();\n           continue;\n        }\n        break;\n    }\n    while(1){\n        if(arr[arr.length-1]==\" \") {\n            arr.pop();\n            continue;\n        }\n        break;\n    }\n    return arr.join(\"\");\n}\n//后来面试官跟我说一句话就解决了，然而我正则都忘了，平时没怎么用\nString.prototype.trim = function () {\n    return this.replace(/(^\\s*)|(\\s*$)/g,'');\n};\n```\n\n### <span id='11'> 12. 三道判断输出的题都是经典的题</span>\n```js\n    //5.1\n    var a=4;\n    function b() {\n      a=3;\n      console.log(a);\n      function a(){};\n    }\n    b();\n    //明显输出是3，因为里面修改了a这个全局变量，那个function a(){}是用来干扰的，虽然函数声明会提升，就被a给覆盖掉了，这是我的理解\n    //5.2\n    //不记得具体的就类似如下\n    var baz=3;\n    var bazz={\n      baz: 2,\n      getbaz: function() {\n            return this.baz\n      }\n    }\n    console.log(bazz.getbaz())\n    var g=bazz.getbaz;\n    console.log(g());\n    //第一个输出是2，第二个输出是3，这题考察的就是this的指向，函数作为对象本身属性调用的时候this指向对象，作为普通函数调用的时候就指向全局了\n    //5.3\n    var arr=[1,2,3,4,5];\n    for(var i=0;i<arr.length;i++)\n    { \n      arr[i]=function(){alert(i)}\n    }\n    arr[3]();\n    //典型的闭包啊，看都不用看，肯定弹出5啊\n```\n### <span id='12'>13. position不同值和区别</span>\n\n    1.absolute: 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。\n    元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。(不占位)\n    2.relative: 生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。（占位）\n    3.static：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）\n    4.inherit：规定应该从父元素继承 position 属性的值。\n    5.fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。\n\n### <span id='13'>14. 讲述你对reflow和repaint的理解</span>\n\n> repaint就是重绘，reflow就是回流。repaint主要是针对某一个DOM元素进行的重绘，reflow则是回流，针对整个页面的重排\n\n### 严重性：\n\n在性能优先的前提下，性能消耗 reflow大于repaint。\n\n### 体现：\n\nrepaint是某个DOM元素进行重绘；reflow是整个页面进行重排，也就是页面所有DOM元素渲染。\n\n#### 如何触发：\n\nstyle变动造成repaint和reflow。\n不涉及任何DOM元素的排版问题的变动为repaint，例如元素的color/text-align/text-decoration等等属性的变动。\n除上面所提到的DOM元素style的修改基本为reflow。例如元素的任何涉及长、宽、行高、边框、display等style的修改。\n\n### 常见触发场景：\n\n#### 触发repaint：\n\n    color的修改，如color=#ddd；\n    text-align的修改，如text-align=center；\n    a:hover也会造成重绘。\n    :hover引起的颜色等不导致页面回流的style变动。\n\n#### 触发reflow：\n\n    width/height/border/margin/padding的修改，如width=778px；\n    动画，:hover等伪类引起的元素表现改动，display=none等造成页面回流；\n    appendChild等DOM元素操作；\n    font类style的修改；\n    background的修改，注意着字面上可能以为是重绘，但是浏览器确实回流了，经过浏览器厂家的优化，部分background的修改只触发repaint，当然IE不用考虑；\n    scroll页面，这个不可避免；\n    resize页面，桌面版本的进行浏览器大小的缩放，移动端的话，还没玩过能拖动程序，resize程序窗口大小的多窗口操作系统。\n    读取元素的属性（这个无法理解，但是技术达人是这么说的，那就把它当做定理吧）：读取元素的某些属性（offsetLeft、offsetTop、offsetHeight、offsetWidth、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、getComputedStyle()、currentStyle(in IE))；\n\n#### 如何避免：\n\n尽可能在DOM末梢通过改变class来修改元素的style属性：尽可能的减少受影响的DOM元素。\n避免设置多项内联样式：使用常用的class的方式进行设置样式，以避免设置样式时访问DOM的低效率。\n设置动画元素position属性为fixed或者absolute：由于当前元素从DOM流中独立出来，因此受影响的只有当前元素，元素repaint。\n牺牲平滑度满足性能：动画精度太强，会造成更多次的repaint/reflow，牺牲精度，能满足性能的损耗，获取性能和平滑度的平衡。\n避免使用table进行布局：table的每个元素的大小以及内容的改动，都会导致整个table进行重新计算，造成大幅度的repaint或者reflow。改用div则可以进行针对性的repaint和避免不必要的reflow。\n避免在CSS中使用运算式：学习CSS的时候就知道，这个应该避免，不应该加深到这一层再去了解，因为这个的后果确实非常严重，一旦存在动画性的repaint/reflow，那么每一帧动画都会进行计算，性能消耗不容小觑。\n\n[](https://segmentfault.com/a/1190000002629708)","source":"_posts/面试/网易.md","raw":"---\ntitle: 前端面试\ncategories:\n  - 前端技术\ntags:\n  - 前端面试\ndate: 2018-04-12 10:03:20\n---\n\n> 总结网易前端面试的一些题目，做准备， I will go to work in big wangyi company next year，Wish myself good luck.\n\n<!--- more -->\n\n* [=＝和===的区别？＝＝怎么进行类型转换的，说说有哪几种情况？](#0)\n\n* [布局：一个 div(200px*200px)在左侧，另一个 div 自适应在右侧](#1)\n\n* [给 Object 扩展一个方法 clone，实现深度克隆对象](#2)\n\n* [px、em、rem](#3)\n\n* [用 html,css 实现一个 div 居中在窗口](#4)\n\n* [用css实现，两行文本，间距10px,字体是14px,距顶端和底端15px,拒左边10px](#5)\n\n* [扩展Date的format方法](#6)\n\n* [写出下面结果](#7)\n\n* [alert(1&&2),alert(1||0)](#8)\n\n* [mouseenter和mouseover的区别](#9)\n\n* [js字符串两边截取空白的trim的原型方法的实现](#10)\n\n* [三道判断输出的题都是经典的题](#11)\n\n* [position不同值和区别](#12)\n\n* [讲述你对reflow和repaint的理解](#13)\n\n* [讲述你对reflow和repaint的理解](#14)\n\n\n\n### <span id='0'>1. =＝和===的区别？＝＝怎么进行类型转换的，说说有哪几种情况？</span>\n\n    ==匹配两个变量的的值，如果类型不匹配，会强制类型转换，\n    ===不但匹配两个变量的值，还会匹配两个变量的数据类型是否相同，如果其中有一项不相同，匹配失败。\n    ===不会类型转换，执行效率高。\n\n### <span id='1'>2. 布局：一个 div(200px*200px)在左侧，另一个 div 自适应在右侧</span>\n\n1.  如果不考虑浏览器的兼容问题的话，可以使用 css3 的新增属性 calc();calc 是 calculate 的简写，汉语为计算的意思。\n```css\n  .left {\n    width: 200px;\n    float: left;\n    height: 200px;\n    background: pink;\n  }\n  .right {\n    float: left;\n    width: calc(100% - 200px);\n    height: 200px;\n    background: yellow;\n  }\n```\n2.  可以使用百分比进行布局，该方法不需考虑浏览器的兼容性.但与第一种进行比较， 右侧 div 的宽度百分比需要自己去进行计算。\n```css\n  // 要依赖父元素\n  .left {\n    width: 200px;\n    float: left;\n    height: 200px;\n    background: pink;\n  }\n  .right {\n    float: left;\n    width: 85%;\n    height: 200px;\n    background: yellow;\n  }\n```\n\n3.  使用绝对元素进行定位\n\n\n```css\n.left {\n  width: 200px;\n  height: 200px;\n  position: absolute;\n  background: pink;\n}\n.right {\n  left: 200px;\n  right: 0;\n  height: 200px;\n  position: absolute;\n  background: yellow;\n}\n```\n\n4.  div 的宽度在不进行设置的情况下会自动填满父标签的宽度。所以我们可以并不对右侧 div 的宽度进行设置\n\n\n```css\n.left {\n  width: 200px;\n  height: 300px;\n  float: left;\n  background: pink;\n}\n.right {\n  height: 300px;\n  margin-left: 200px;\n  background: yellow;\n}\n```\n\n5.  flex 布局\n\n\n```css\n// 要依赖父元素\n.container {\n  width: 1000px;\n  height: 400px;\n  border: 1px solid red;\n  display: flex; /*flex布局*/\n}\n.left {\n  width: 200px;\n  height: 100%;\n  background: gray;\n  flex: none;\n}\n.right {\n  height: 100%;\n  background: green;\n  flex: 1; /*flex布局*/\n}\n```\n\n6.  table 布局\n    // 要依赖父元素\n\n\n```css\n.container {\n  width: 1000px;\n  height: 400px;\n  border: 1px solid red;\n  display: table; /*table布局*/\n}\n.left {\n  width: 200px;\n  height: 100%;\n  background: gray;\n  display: table-cell;\n}\n.right {\n  height: 100%;\n  background: green;\n  display: table-cell;\n}\n```\n7.  BFC(块级格式化上下文)\n```css\n.container {\n  width: 1000px;\n  height: 400px;\n  border: 1px solid red;\n}\n.left {\n  width: 200px;\n  height: 100%;\n  background: gray;\n  float: left;\n}\n.rigth {\n  overflow: hidden; /* 触发bfc */\n  background: green;\n}\n```\n\n### <span id='2'>3. 给 Object 扩展一个方法 clone，实现深度克隆对象</span>\n\n[javaScript 中浅拷贝和深拷贝的实现](javaScript中浅拷贝和深拷贝的实现)\n\n### <span id='3'>4. px、em、rem</span>\n\n> 有何区别\n\n* px 在缩放页面时无法调整那些使用它作为单位的字体、按钮等的大小；\n* em 的值并不是固定的，会继承父级元素的字体大小，代表倍数；\n* rem 的值并不是固定的，始终是基于根元素 html 的，也代表倍数。\n\n> em\n\nem 的使用是相对于其父级的字体大小的，即倍数。浏览器的默认字体高都是 16px，未经调整的浏览器显示 1em = 16px。但是有一个问题，如果设置 1.2em 则变成 19.2px，问题是 px 表示大小时数值会忽略掉小数位的（你想像不出来半个像素吧）。而且 1em = 16px 的关系不好转换，因此，常常人为地使 1em = 10px。这里要借助字体的 % 来作为桥梁。\n\n因为默认时字体 16px = 100%，则有 10px = 62.5%。所以首先在 body 中全局声明 font-size=62.5%=10px，也就是定义了网页 body 默认字体大小为 10px，由于 em 有继承父级元素字体大小的特性，如果某元素的父级没有设定字体大小，那么它就继续了 body 默认字体大小 1em = 10px。\n\n但是由于 em 是相对于其父级字体的倍数的，当出现有多重嵌套内容时，使用 em 分别给它们设置字体的大小往往要重新计算。比如说你在父级中声明了字体大小为 1.2em，那么在声明子元素的字体大小时设置 1em 才能和父级元素内容字体大小一致，而不是 1.2em（避免 1.2\\*1.2=1.44em）, 因为此 em 非彼 em。再举个例子：\n\n`<span>Outer <span>inner</span> outer</span>`\n\n```css\nbody {\n  font-size: 62.5%;\n}\nspan {\n  font-size: 1.6em;\n}\n```\n\n> rem\n\nrem 的出现再也不用担心还要根据父级元素的 font-size 计算 em 值了，因为它始终是基于根元素（<html>）的。比如默认的 html font-size=16px，那么想设置 12px 的文字就是：12÷16=0.75(rem)\n仍然是上面的例子，CSS 改为：\n\n```css\nhtml {\n  font-size: 62.5%;\n}\nspan {\n  font-size: 16px;\n  font-size: 1.6rem;\n}\n```\n\n结果：内外 <span> 的内容均为 16px。\n\n> 需要注意的是，为了兼容不支持 rem 的浏览器，我们需要在各个使用了 rem 地方前面写上对应的 px 值，这样不支持的浏览器可以优雅降级。\n\n### <span id='4'>5. 用 html,css 实现一个 div 居中在窗口</span>\n\n  1. Flex 布局, 不考虑兼容老式浏览器的话，用Flex布局简单直观一劳永逸\n\n  ```css\n      .out{\n          width: 200px;\n          height: 200px;\n          background: pink;\n          display: flex;\n          display: -webkit-flex; /* Safari */\n          /*align-items:center;    /* 处理垂直居中 */\n      }\n      .in {\n          width: 100px;\n          height: 100px;\n          background: blue;\n          margin: auto;           /* 水平垂直居中 */\n          word-wrap: break-word;  /*如果是字母数字， 处理换行 */\n      }\n  ```\n\n  2. 不知道自己高度的情况下, 利用绝对定位，结合transform: translate（）属性。\n\n    ```css\n        .out{\n        width: 200px; \n        height: 200px;\n        background: pink;\n        position: relative;\n        }\n        .in {\n        background: blue;\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        }\n    ```\n  3. 已知容器高度的情况下，利用定位\n\n    ```css\n        .out {\n            width: 200px; \n            height: 200px;\n            background: pink;\n            position: relative;\n        }\n        .in {\n            width: 100px;\n            height: 100px;\n            background: blue;\n            position: absolute;\n            /*第一种*/\n            top: 50%;\n            left: 50%;\n            margin-top:-50px;\n            margin-left:-50px;\n            /*第二种*/\n            top:0;\n            right:0;\n            bottom:0;\n            left:0;\n            margin:auto;\n        }\n    ```\n\n  4. 已知容器高度， 利用display: table-cell;\n\n    ```css\n        .out{\n            width: 200px;\n            height: 200px;\n            background: pink;\n            display:table-cell;\n            vertical-align:middle;\n        }\n\n        .in {\n            width: 100px;\n            height: 100px;\n            background: blue;\n            margin: 0 auto;\n        }\n    ```\n\n### <span id='5'>6. 用css实现，两行文本，间距10px,字体是14px,距顶端和底端15px,拒左边10px</span>\n\n> word-spacing 对中文没有作用， 对字母有作用，从空格隔那开始起作用，而letter-spacing对两者都有作用，是字间的距离，包括空格哪里的也会隔开\n\n    ```css\n    .out{\n        font-size: 14px;\n        letter-spacing: 10px;\n        padding: 15px 0 15px 10px;\n    }\n    ```\n\n### <span id='6'>7. 扩展Date的format方法</span>\n\n```js\nDate.prototype.format = function (format) {\n    var o = {\n        \"M+\": this.getMonth() + 1,\n        \"d+\": this.getDate(),\n        \"h+\": this.getHours(),\n        \"m+\": this.getMinutes(),\n        \"s+\": this.getSeconds(),\n        \"q+\": Math.floor((this.getMonth() + 3) / 3),\n        \"S\": this.getMilliseconds()\n    };\n    if (/(y+)/.test(format)) {\n        format = format.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n    }\n    for (var k in o) {\n        if (new RegExp(\"(\" + k + \")\").test(format)) {\n            format = format.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : (\"00\" + o[k]).substr((\"\" + o[k]).length));\n        }\n    }\n    return format;\n};\n```\n### <span id='7'>8. 写出下面结果</spanid>\n\n```js\n　　function b(c){\n　　　　console.log(c);\n　　　　function c(){\n　　　　　　　console.log(\"d\");\n　　　　}\n　　}\n　　b(10);\n\n// 结果 function c(){ console.log(\"d\"); }\n```\n### <span id='8'>9. alert(1&&2),alert(1||0) </span>\n\n    alert(1&&2)的结果是2\n    只要“&&”前面是false，无论“&&”后面是true还是false，结果都将返“&&”前面的值;\n    只要“&&”前面是true，无论“&&”后面是true还是false，结果都将返“&&”后面的值;\n    alert(0||1)的结果是1\n    只要“||”前面为false,不管“||”后面是true还是false，都返回“||”后面的值。\n    只要“||”前面为true,不管“||”后面是true还是false，都返回“||”前面的值。\n\n### <span id='9'>10. mouseenter和mouseover的区别</span>\n\n    mouseover事件：不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。\n    mouseenter事件：只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。\n    mouseout事件：不论鼠标指针离开被选元素还是任何子元素，都会触发 mouseout 事件。\n    mouseleave事件：只有在鼠标指针离开被选元素时，才会触发 mouseleave 事件。\n\n### <span id='10'> 11. js字符串两边截取空白的trim的原型方法的实现</span>\n```js\n//我的笨方法，当时还想错了一些，回来后实现了一下，思路是这样\nString.prototype.trim = function () {\n    var arr=this.split(\"\");\n    while(1) {\n       if(arr[0]==\" \") {\n           arr.shift();\n           continue;\n        }\n        break;\n    }\n    while(1){\n        if(arr[arr.length-1]==\" \") {\n            arr.pop();\n            continue;\n        }\n        break;\n    }\n    return arr.join(\"\");\n}\n//后来面试官跟我说一句话就解决了，然而我正则都忘了，平时没怎么用\nString.prototype.trim = function () {\n    return this.replace(/(^\\s*)|(\\s*$)/g,'');\n};\n```\n\n### <span id='11'> 12. 三道判断输出的题都是经典的题</span>\n```js\n    //5.1\n    var a=4;\n    function b() {\n      a=3;\n      console.log(a);\n      function a(){};\n    }\n    b();\n    //明显输出是3，因为里面修改了a这个全局变量，那个function a(){}是用来干扰的，虽然函数声明会提升，就被a给覆盖掉了，这是我的理解\n    //5.2\n    //不记得具体的就类似如下\n    var baz=3;\n    var bazz={\n      baz: 2,\n      getbaz: function() {\n            return this.baz\n      }\n    }\n    console.log(bazz.getbaz())\n    var g=bazz.getbaz;\n    console.log(g());\n    //第一个输出是2，第二个输出是3，这题考察的就是this的指向，函数作为对象本身属性调用的时候this指向对象，作为普通函数调用的时候就指向全局了\n    //5.3\n    var arr=[1,2,3,4,5];\n    for(var i=0;i<arr.length;i++)\n    { \n      arr[i]=function(){alert(i)}\n    }\n    arr[3]();\n    //典型的闭包啊，看都不用看，肯定弹出5啊\n```\n### <span id='12'>13. position不同值和区别</span>\n\n    1.absolute: 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。\n    元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。(不占位)\n    2.relative: 生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。（占位）\n    3.static：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）\n    4.inherit：规定应该从父元素继承 position 属性的值。\n    5.fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。\n\n### <span id='13'>14. 讲述你对reflow和repaint的理解</span>\n\n> repaint就是重绘，reflow就是回流。repaint主要是针对某一个DOM元素进行的重绘，reflow则是回流，针对整个页面的重排\n\n### 严重性：\n\n在性能优先的前提下，性能消耗 reflow大于repaint。\n\n### 体现：\n\nrepaint是某个DOM元素进行重绘；reflow是整个页面进行重排，也就是页面所有DOM元素渲染。\n\n#### 如何触发：\n\nstyle变动造成repaint和reflow。\n不涉及任何DOM元素的排版问题的变动为repaint，例如元素的color/text-align/text-decoration等等属性的变动。\n除上面所提到的DOM元素style的修改基本为reflow。例如元素的任何涉及长、宽、行高、边框、display等style的修改。\n\n### 常见触发场景：\n\n#### 触发repaint：\n\n    color的修改，如color=#ddd；\n    text-align的修改，如text-align=center；\n    a:hover也会造成重绘。\n    :hover引起的颜色等不导致页面回流的style变动。\n\n#### 触发reflow：\n\n    width/height/border/margin/padding的修改，如width=778px；\n    动画，:hover等伪类引起的元素表现改动，display=none等造成页面回流；\n    appendChild等DOM元素操作；\n    font类style的修改；\n    background的修改，注意着字面上可能以为是重绘，但是浏览器确实回流了，经过浏览器厂家的优化，部分background的修改只触发repaint，当然IE不用考虑；\n    scroll页面，这个不可避免；\n    resize页面，桌面版本的进行浏览器大小的缩放，移动端的话，还没玩过能拖动程序，resize程序窗口大小的多窗口操作系统。\n    读取元素的属性（这个无法理解，但是技术达人是这么说的，那就把它当做定理吧）：读取元素的某些属性（offsetLeft、offsetTop、offsetHeight、offsetWidth、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、getComputedStyle()、currentStyle(in IE))；\n\n#### 如何避免：\n\n尽可能在DOM末梢通过改变class来修改元素的style属性：尽可能的减少受影响的DOM元素。\n避免设置多项内联样式：使用常用的class的方式进行设置样式，以避免设置样式时访问DOM的低效率。\n设置动画元素position属性为fixed或者absolute：由于当前元素从DOM流中独立出来，因此受影响的只有当前元素，元素repaint。\n牺牲平滑度满足性能：动画精度太强，会造成更多次的repaint/reflow，牺牲精度，能满足性能的损耗，获取性能和平滑度的平衡。\n避免使用table进行布局：table的每个元素的大小以及内容的改动，都会导致整个table进行重新计算，造成大幅度的repaint或者reflow。改用div则可以进行针对性的repaint和避免不必要的reflow。\n避免在CSS中使用运算式：学习CSS的时候就知道，这个应该避免，不应该加深到这一层再去了解，因为这个的后果确实非常严重，一旦存在动画性的repaint/reflow，那么每一帧动画都会进行计算，性能消耗不容小觑。\n\n[](https://segmentfault.com/a/1190000002629708)","slug":"面试/网易","published":1,"updated":"2018-05-31T10:27:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjslmo3dn000zuox1bnirgy3b","content":"<blockquote>\n<p>总结网易前端面试的一些题目，做准备， I will go to work in big wangyi company next year，Wish myself good luck.</p>\n</blockquote>\n<a id=\"more\"></a>\n<ul>\n<li><p><a href=\"#0\">=＝和===的区别？＝＝怎么进行类型转换的，说说有哪几种情况？</a></p>\n</li>\n<li><p><a href=\"#1\">布局：一个 div(200px*200px)在左侧，另一个 div 自适应在右侧</a></p>\n</li>\n<li><p><a href=\"#2\">给 Object 扩展一个方法 clone，实现深度克隆对象</a></p>\n</li>\n<li><p><a href=\"#3\">px、em、rem</a></p>\n</li>\n<li><p><a href=\"#4\">用 html,css 实现一个 div 居中在窗口</a></p>\n</li>\n<li><p><a href=\"#5\">用css实现，两行文本，间距10px,字体是14px,距顶端和底端15px,拒左边10px</a></p>\n</li>\n<li><p><a href=\"#6\">扩展Date的format方法</a></p>\n</li>\n<li><p><a href=\"#7\">写出下面结果</a></p>\n</li>\n<li><p><a href=\"#8\">alert(1&amp;&amp;2),alert(1||0)</a></p>\n</li>\n<li><p><a href=\"#9\">mouseenter和mouseover的区别</a></p>\n</li>\n<li><p><a href=\"#10\">js字符串两边截取空白的trim的原型方法的实现</a></p>\n</li>\n<li><p><a href=\"#11\">三道判断输出的题都是经典的题</a></p>\n</li>\n<li><p><a href=\"#12\">position不同值和区别</a></p>\n</li>\n<li><p><a href=\"#13\">讲述你对reflow和repaint的理解</a></p>\n</li>\n<li><p><a href=\"#14\">讲述你对reflow和repaint的理解</a></p>\n</li>\n</ul>\n<h3 id=\"1-＝和-的区别？＝＝怎么进行类型转换的，说说有哪几种情况？\"><a href=\"#1-＝和-的区别？＝＝怎么进行类型转换的，说说有哪几种情况？\" class=\"headerlink\" title=\"1. =＝和===的区别？＝＝怎么进行类型转换的，说说有哪几种情况？\"></a><span id=\"0\">1. =＝和===的区别？＝＝怎么进行类型转换的，说说有哪几种情况？</span></h3><pre><code>==匹配两个变量的的值，如果类型不匹配，会强制类型转换，\n===不但匹配两个变量的值，还会匹配两个变量的数据类型是否相同，如果其中有一项不相同，匹配失败。\n===不会类型转换，执行效率高。\n</code></pre><h3 id=\"2-布局：一个-div-200px-200px-在左侧，另一个-div-自适应在右侧\"><a href=\"#2-布局：一个-div-200px-200px-在左侧，另一个-div-自适应在右侧\" class=\"headerlink\" title=\"2. 布局：一个 div(200px*200px)在左侧，另一个 div 自适应在右侧\"></a><span id=\"1\">2. 布局：一个 div(200px*200px)在左侧，另一个 div 自适应在右侧</span></h3><ol>\n<li><p>如果不考虑浏览器的兼容问题的话，可以使用 css3 的新增属性 calc();calc 是 calculate 的简写，汉语为计算的意思。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.left</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: pink;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"built_in\">calc</span>(100% - 200px);</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: yellow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以使用百分比进行布局，该方法不需考虑浏览器的兼容性.但与第一种进行比较， 右侧 div 的宽度百分比需要自己去进行计算。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 要依赖父元素</span><br><span class=\"line\"><span class=\"selector-class\">.left</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: pink;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">85%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: yellow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用绝对元素进行定位</p>\n</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.left</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: pink;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: yellow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>div 的宽度在不进行设置的情况下会自动填满父标签的宽度。所以我们可以并不对右侧 div 的宽度进行设置</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.left</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: pink;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: yellow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>flex 布局</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 要依赖父元素</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">1000px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">400px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid red;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex; <span class=\"comment\">/*flex布局*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.left</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: gray;</span><br><span class=\"line\">  <span class=\"attribute\">flex</span>: none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: green;</span><br><span class=\"line\">  <span class=\"attribute\">flex</span>: <span class=\"number\">1</span>; <span class=\"comment\">/*flex布局*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>table 布局<br>// 要依赖父元素</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">1000px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">400px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid red;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table; <span class=\"comment\">/*table布局*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.left</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: gray;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table-cell;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: green;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table-cell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>BFC(块级格式化上下文)<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">1000px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">400px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.left</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: gray;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.rigth</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden; <span class=\"comment\">/* 触发bfc */</span></span><br><span class=\"line\">  <span class=\"attribute\">background</span>: green;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"3-给-Object-扩展一个方法-clone，实现深度克隆对象\"><a href=\"#3-给-Object-扩展一个方法-clone，实现深度克隆对象\" class=\"headerlink\" title=\"3. 给 Object 扩展一个方法 clone，实现深度克隆对象\"></a><span id=\"2\">3. 给 Object 扩展一个方法 clone，实现深度克隆对象</span></h3><p><a href=\"javaScript中浅拷贝和深拷贝的实现\">javaScript 中浅拷贝和深拷贝的实现</a></p>\n<h3 id=\"4-px、em、rem\"><a href=\"#4-px、em、rem\" class=\"headerlink\" title=\"4. px、em、rem\"></a><span id=\"3\">4. px、em、rem</span></h3><blockquote>\n<p>有何区别</p>\n</blockquote>\n<ul>\n<li>px 在缩放页面时无法调整那些使用它作为单位的字体、按钮等的大小；</li>\n<li>em 的值并不是固定的，会继承父级元素的字体大小，代表倍数；</li>\n<li>rem 的值并不是固定的，始终是基于根元素 html 的，也代表倍数。</li>\n</ul>\n<blockquote>\n<p>em</p>\n</blockquote>\n<p>em 的使用是相对于其父级的字体大小的，即倍数。浏览器的默认字体高都是 16px，未经调整的浏览器显示 1em = 16px。但是有一个问题，如果设置 1.2em 则变成 19.2px，问题是 px 表示大小时数值会忽略掉小数位的（你想像不出来半个像素吧）。而且 1em = 16px 的关系不好转换，因此，常常人为地使 1em = 10px。这里要借助字体的 % 来作为桥梁。</p>\n<p>因为默认时字体 16px = 100%，则有 10px = 62.5%。所以首先在 body 中全局声明 font-size=62.5%=10px，也就是定义了网页 body 默认字体大小为 10px，由于 em 有继承父级元素字体大小的特性，如果某元素的父级没有设定字体大小，那么它就继续了 body 默认字体大小 1em = 10px。</p>\n<p>但是由于 em 是相对于其父级字体的倍数的，当出现有多重嵌套内容时，使用 em 分别给它们设置字体的大小往往要重新计算。比如说你在父级中声明了字体大小为 1.2em，那么在声明子元素的字体大小时设置 1em 才能和父级元素内容字体大小一致，而不是 1.2em（避免 1.2*1.2=1.44em）, 因为此 em 非彼 em。再举个例子：</p>\n<p><code>&lt;span&gt;Outer &lt;span&gt;inner&lt;/span&gt; outer&lt;/span&gt;</code></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">62.5%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">span</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.6em</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>rem</p>\n</blockquote>\n<p>rem 的出现再也不用担心还要根据父级元素的 font-size 计算 em 值了，因为它始终是基于根元素（<html>）的。比如默认的 html font-size=16px，那么想设置 12px 的文字就是：12÷16=0.75(rem)<br>仍然是上面的例子，CSS 改为：</html></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">62.5%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">span</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">16px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.6rem</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果：内外 <span> 的内容均为 16px。</span></p>\n<blockquote>\n<p>需要注意的是，为了兼容不支持 rem 的浏览器，我们需要在各个使用了 rem 地方前面写上对应的 px 值，这样不支持的浏览器可以优雅降级。</p>\n</blockquote>\n<h3 id=\"5-用-html-css-实现一个-div-居中在窗口\"><a href=\"#5-用-html-css-实现一个-div-居中在窗口\" class=\"headerlink\" title=\"5. 用 html,css 实现一个 div 居中在窗口\"></a><span id=\"4\">5. 用 html,css 实现一个 div 居中在窗口</span></h3><ol>\n<li><p>Flex 布局, 不考虑兼容老式浏览器的话，用Flex布局简单直观一劳永逸</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.out</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: pink;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: -webkit-flex; <span class=\"comment\">/* Safari */</span></span><br><span class=\"line\">    <span class=\"comment\">/*align-items:center;    /* 处理垂直居中 */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.in</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: blue;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: auto;           <span class=\"comment\">/* 水平垂直居中 */</span></span><br><span class=\"line\">    <span class=\"attribute\">word-wrap</span>: break-word;  <span class=\"comment\">/*如果是字母数字， 处理换行 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>不知道自己高度的情况下, 利用绝对定位，结合transform: translate（）属性。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.out</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">width</span>: <span class=\"number\">200px</span>; </span><br><span class=\"line\"><span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\"><span class=\"attribute\">background</span>: pink;</span><br><span class=\"line\"><span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.in</span> &#123;</span><br><span class=\"line\"><span class=\"attribute\">background</span>: blue;</span><br><span class=\"line\"><span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\"><span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\"><span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\"><span class=\"attribute\">transform</span>: <span class=\"built_in\">translate</span>(-50%, -50%);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>已知容器高度的情况下，利用定位</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.out</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>; </span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: pink;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.in</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: blue;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"comment\">/*第一种*/</span></span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-top</span>:-<span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>:-<span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"comment\">/*第二种*/</span></span><br><span class=\"line\">    <span class=\"attribute\">top</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">right</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>:auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>已知容器高度， 利用display: table-cell;</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.out</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: pink;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>:table-cell;</span><br><span class=\"line\">    <span class=\"attribute\">vertical-align</span>:middle;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.in</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: blue;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"6-用css实现，两行文本，间距10px-字体是14px-距顶端和底端15px-拒左边10px\"><a href=\"#6-用css实现，两行文本，间距10px-字体是14px-距顶端和底端15px-拒左边10px\" class=\"headerlink\" title=\"6. 用css实现，两行文本，间距10px,字体是14px,距顶端和底端15px,拒左边10px\"></a><span id=\"5\">6. 用css实现，两行文本，间距10px,字体是14px,距顶端和底端15px,拒左边10px</span></h3><blockquote>\n<p>word-spacing 对中文没有作用， 对字母有作用，从空格隔那开始起作用，而letter-spacing对两者都有作用，是字间的距离，包括空格哪里的也会隔开</p>\n</blockquote>\n<pre><code><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.out</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">14px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">letter-spacing</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">15px</span> <span class=\"number\">0</span> <span class=\"number\">15px</span> <span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"7-扩展Date的format方法\"><a href=\"#7-扩展Date的format方法\" class=\"headerlink\" title=\"7. 扩展Date的format方法\"></a><span id=\"6\">7. 扩展Date的format方法</span></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Date</span>.prototype.format = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">format</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">        <span class=\"string\">\"M+\"</span>: <span class=\"keyword\">this</span>.getMonth() + <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"string\">\"d+\"</span>: <span class=\"keyword\">this</span>.getDate(),</span><br><span class=\"line\">        <span class=\"string\">\"h+\"</span>: <span class=\"keyword\">this</span>.getHours(),</span><br><span class=\"line\">        <span class=\"string\">\"m+\"</span>: <span class=\"keyword\">this</span>.getMinutes(),</span><br><span class=\"line\">        <span class=\"string\">\"s+\"</span>: <span class=\"keyword\">this</span>.getSeconds(),</span><br><span class=\"line\">        <span class=\"string\">\"q+\"</span>: <span class=\"built_in\">Math</span>.floor((<span class=\"keyword\">this</span>.getMonth() + <span class=\"number\">3</span>) / <span class=\"number\">3</span>),</span><br><span class=\"line\">        <span class=\"string\">\"S\"</span>: <span class=\"keyword\">this</span>.getMilliseconds()</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"regexp\">/(y+)/</span>.test(format)) &#123;</span><br><span class=\"line\">        format = format.replace(<span class=\"built_in\">RegExp</span>.$<span class=\"number\">1</span>, (<span class=\"keyword\">this</span>.getFullYear() + <span class=\"string\">\"\"</span>).substr(<span class=\"number\">4</span> - <span class=\"built_in\">RegExp</span>.$<span class=\"number\">1.</span>length));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k <span class=\"keyword\">in</span> o) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"(\"</span> + k + <span class=\"string\">\")\"</span>).test(format)) &#123;</span><br><span class=\"line\">            format = format.replace(<span class=\"built_in\">RegExp</span>.$<span class=\"number\">1</span>, <span class=\"built_in\">RegExp</span>.$<span class=\"number\">1.</span>length == <span class=\"number\">1</span> ? o[k] : (<span class=\"string\">\"00\"</span> + o[k]).substr((<span class=\"string\">\"\"</span> + o[k]).length));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> format;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-写出下面结果\"><a href=\"#8-写出下面结果\" class=\"headerlink\" title=\"8. 写出下面结果\"></a><span id=\"7\">8. 写出下面结果</span></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\">c</span>)</span>&#123;</span><br><span class=\"line\">　　　　<span class=\"built_in\">console</span>.log(c);</span><br><span class=\"line\">　　　　<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">c</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">　　　　　　　<span class=\"built_in\">console</span>.log(<span class=\"string\">\"d\"</span>);</span><br><span class=\"line\">　　　　&#125;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　b(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结果 function c()&#123; console.log(\"d\"); &#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"9-alert-1-amp-amp-2-alert-1-0\"><a href=\"#9-alert-1-amp-amp-2-alert-1-0\" class=\"headerlink\" title=\"9. alert(1&amp;&amp;2),alert(1||0) \"></a><span id=\"8\">9. alert(1&amp;&amp;2),alert(1||0) </span></h3><pre><code>alert(1&amp;&amp;2)的结果是2\n只要“&amp;&amp;”前面是false，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”前面的值;\n只要“&amp;&amp;”前面是true，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”后面的值;\nalert(0||1)的结果是1\n只要“||”前面为false,不管“||”后面是true还是false，都返回“||”后面的值。\n只要“||”前面为true,不管“||”后面是true还是false，都返回“||”前面的值。\n</code></pre><h3 id=\"10-mouseenter和mouseover的区别\"><a href=\"#10-mouseenter和mouseover的区别\" class=\"headerlink\" title=\"10. mouseenter和mouseover的区别\"></a><span id=\"9\">10. mouseenter和mouseover的区别</span></h3><pre><code>mouseover事件：不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。\nmouseenter事件：只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。\nmouseout事件：不论鼠标指针离开被选元素还是任何子元素，都会触发 mouseout 事件。\nmouseleave事件：只有在鼠标指针离开被选元素时，才会触发 mouseleave 事件。\n</code></pre><h3 id=\"11-js字符串两边截取空白的trim的原型方法的实现\"><a href=\"#11-js字符串两边截取空白的trim的原型方法的实现\" class=\"headerlink\" title=\" 11. js字符串两边截取空白的trim的原型方法的实现\"></a><span id=\"10\"> 11. js字符串两边截取空白的trim的原型方法的实现</span></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//我的笨方法，当时还想错了一些，回来后实现了一下，思路是这样</span></span><br><span class=\"line\"><span class=\"built_in\">String</span>.prototype.trim = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr=<span class=\"keyword\">this</span>.split(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(arr[<span class=\"number\">0</span>]==<span class=\"string\">\" \"</span>) &#123;</span><br><span class=\"line\">           arr.shift();</span><br><span class=\"line\">           <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(arr[arr.length<span class=\"number\">-1</span>]==<span class=\"string\">\" \"</span>) &#123;</span><br><span class=\"line\">            arr.pop();</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr.join(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//后来面试官跟我说一句话就解决了，然而我正则都忘了，平时没怎么用</span></span><br><span class=\"line\"><span class=\"built_in\">String</span>.prototype.trim = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.replace(<span class=\"regexp\">/(^\\s*)|(\\s*$)/g</span>,<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"12-三道判断输出的题都是经典的题\"><a href=\"#12-三道判断输出的题都是经典的题\" class=\"headerlink\" title=\" 12. 三道判断输出的题都是经典的题\"></a><span id=\"11\"> 12. 三道判断输出的题都是经典的题</span></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//5.1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  a=<span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">b();</span><br><span class=\"line\"><span class=\"comment\">//明显输出是3，因为里面修改了a这个全局变量，那个function a()&#123;&#125;是用来干扰的，虽然函数声明会提升，就被a给覆盖掉了，这是我的理解</span></span><br><span class=\"line\"><span class=\"comment\">//5.2</span></span><br><span class=\"line\"><span class=\"comment\">//不记得具体的就类似如下</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> baz=<span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bazz=&#123;</span><br><span class=\"line\">  baz: <span class=\"number\">2</span>,</span><br><span class=\"line\">  getbaz: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.baz</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bazz.getbaz())</span><br><span class=\"line\"><span class=\"keyword\">var</span> g=bazz.getbaz;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g());</span><br><span class=\"line\"><span class=\"comment\">//第一个输出是2，第二个输出是3，这题考察的就是this的指向，函数作为对象本身属性调用的时候this指向对象，作为普通函数调用的时候就指向全局了</span></span><br><span class=\"line\"><span class=\"comment\">//5.3</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;arr.length;i++)</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">  arr[i]=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;alert(i)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr[<span class=\"number\">3</span>]();</span><br><span class=\"line\"><span class=\"comment\">//典型的闭包啊，看都不用看，肯定弹出5啊</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"13-position不同值和区别\"><a href=\"#13-position不同值和区别\" class=\"headerlink\" title=\"13. position不同值和区别\"></a><span id=\"12\">13. position不同值和区别</span></h3><pre><code>1.absolute: 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。\n元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。(不占位)\n2.relative: 生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。（占位）\n3.static：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）\n4.inherit：规定应该从父元素继承 position 属性的值。\n5.fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。\n</code></pre><h3 id=\"14-讲述你对reflow和repaint的理解\"><a href=\"#14-讲述你对reflow和repaint的理解\" class=\"headerlink\" title=\"14. 讲述你对reflow和repaint的理解\"></a><span id=\"13\">14. 讲述你对reflow和repaint的理解</span></h3><blockquote>\n<p>repaint就是重绘，reflow就是回流。repaint主要是针对某一个DOM元素进行的重绘，reflow则是回流，针对整个页面的重排</p>\n</blockquote>\n<h3 id=\"严重性：\"><a href=\"#严重性：\" class=\"headerlink\" title=\"严重性：\"></a>严重性：</h3><p>在性能优先的前提下，性能消耗 reflow大于repaint。</p>\n<h3 id=\"体现：\"><a href=\"#体现：\" class=\"headerlink\" title=\"体现：\"></a>体现：</h3><p>repaint是某个DOM元素进行重绘；reflow是整个页面进行重排，也就是页面所有DOM元素渲染。</p>\n<h4 id=\"如何触发：\"><a href=\"#如何触发：\" class=\"headerlink\" title=\"如何触发：\"></a>如何触发：</h4><p>style变动造成repaint和reflow。<br>不涉及任何DOM元素的排版问题的变动为repaint，例如元素的color/text-align/text-decoration等等属性的变动。<br>除上面所提到的DOM元素style的修改基本为reflow。例如元素的任何涉及长、宽、行高、边框、display等style的修改。</p>\n<h3 id=\"常见触发场景：\"><a href=\"#常见触发场景：\" class=\"headerlink\" title=\"常见触发场景：\"></a>常见触发场景：</h3><h4 id=\"触发repaint：\"><a href=\"#触发repaint：\" class=\"headerlink\" title=\"触发repaint：\"></a>触发repaint：</h4><pre><code>color的修改，如color=#ddd；\ntext-align的修改，如text-align=center；\na:hover也会造成重绘。\n:hover引起的颜色等不导致页面回流的style变动。\n</code></pre><h4 id=\"触发reflow：\"><a href=\"#触发reflow：\" class=\"headerlink\" title=\"触发reflow：\"></a>触发reflow：</h4><pre><code>width/height/border/margin/padding的修改，如width=778px；\n动画，:hover等伪类引起的元素表现改动，display=none等造成页面回流；\nappendChild等DOM元素操作；\nfont类style的修改；\nbackground的修改，注意着字面上可能以为是重绘，但是浏览器确实回流了，经过浏览器厂家的优化，部分background的修改只触发repaint，当然IE不用考虑；\nscroll页面，这个不可避免；\nresize页面，桌面版本的进行浏览器大小的缩放，移动端的话，还没玩过能拖动程序，resize程序窗口大小的多窗口操作系统。\n读取元素的属性（这个无法理解，但是技术达人是这么说的，那就把它当做定理吧）：读取元素的某些属性（offsetLeft、offsetTop、offsetHeight、offsetWidth、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、getComputedStyle()、currentStyle(in IE))；\n</code></pre><h4 id=\"如何避免：\"><a href=\"#如何避免：\" class=\"headerlink\" title=\"如何避免：\"></a>如何避免：</h4><p>尽可能在DOM末梢通过改变class来修改元素的style属性：尽可能的减少受影响的DOM元素。<br>避免设置多项内联样式：使用常用的class的方式进行设置样式，以避免设置样式时访问DOM的低效率。<br>设置动画元素position属性为fixed或者absolute：由于当前元素从DOM流中独立出来，因此受影响的只有当前元素，元素repaint。<br>牺牲平滑度满足性能：动画精度太强，会造成更多次的repaint/reflow，牺牲精度，能满足性能的损耗，获取性能和平滑度的平衡。<br>避免使用table进行布局：table的每个元素的大小以及内容的改动，都会导致整个table进行重新计算，造成大幅度的repaint或者reflow。改用div则可以进行针对性的repaint和避免不必要的reflow。<br>避免在CSS中使用运算式：学习CSS的时候就知道，这个应该避免，不应该加深到这一层再去了解，因为这个的后果确实非常严重，一旦存在动画性的repaint/reflow，那么每一帧动画都会进行计算，性能消耗不容小觑。</p>\n<p><a href=\"https://segmentfault.com/a/1190000002629708\" target=\"_blank\" rel=\"noopener\"></a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>总结网易前端面试的一些题目，做准备， I will go to work in big wangyi company next year，Wish myself good luck.</p>\n</blockquote>","more":"<ul>\n<li><p><a href=\"#0\">=＝和===的区别？＝＝怎么进行类型转换的，说说有哪几种情况？</a></p>\n</li>\n<li><p><a href=\"#1\">布局：一个 div(200px*200px)在左侧，另一个 div 自适应在右侧</a></p>\n</li>\n<li><p><a href=\"#2\">给 Object 扩展一个方法 clone，实现深度克隆对象</a></p>\n</li>\n<li><p><a href=\"#3\">px、em、rem</a></p>\n</li>\n<li><p><a href=\"#4\">用 html,css 实现一个 div 居中在窗口</a></p>\n</li>\n<li><p><a href=\"#5\">用css实现，两行文本，间距10px,字体是14px,距顶端和底端15px,拒左边10px</a></p>\n</li>\n<li><p><a href=\"#6\">扩展Date的format方法</a></p>\n</li>\n<li><p><a href=\"#7\">写出下面结果</a></p>\n</li>\n<li><p><a href=\"#8\">alert(1&amp;&amp;2),alert(1||0)</a></p>\n</li>\n<li><p><a href=\"#9\">mouseenter和mouseover的区别</a></p>\n</li>\n<li><p><a href=\"#10\">js字符串两边截取空白的trim的原型方法的实现</a></p>\n</li>\n<li><p><a href=\"#11\">三道判断输出的题都是经典的题</a></p>\n</li>\n<li><p><a href=\"#12\">position不同值和区别</a></p>\n</li>\n<li><p><a href=\"#13\">讲述你对reflow和repaint的理解</a></p>\n</li>\n<li><p><a href=\"#14\">讲述你对reflow和repaint的理解</a></p>\n</li>\n</ul>\n<h3 id=\"1-＝和-的区别？＝＝怎么进行类型转换的，说说有哪几种情况？\"><a href=\"#1-＝和-的区别？＝＝怎么进行类型转换的，说说有哪几种情况？\" class=\"headerlink\" title=\"1. =＝和===的区别？＝＝怎么进行类型转换的，说说有哪几种情况？\"></a><span id=\"0\">1. =＝和===的区别？＝＝怎么进行类型转换的，说说有哪几种情况？</span></h3><pre><code>==匹配两个变量的的值，如果类型不匹配，会强制类型转换，\n===不但匹配两个变量的值，还会匹配两个变量的数据类型是否相同，如果其中有一项不相同，匹配失败。\n===不会类型转换，执行效率高。\n</code></pre><h3 id=\"2-布局：一个-div-200px-200px-在左侧，另一个-div-自适应在右侧\"><a href=\"#2-布局：一个-div-200px-200px-在左侧，另一个-div-自适应在右侧\" class=\"headerlink\" title=\"2. 布局：一个 div(200px*200px)在左侧，另一个 div 自适应在右侧\"></a><span id=\"1\">2. 布局：一个 div(200px*200px)在左侧，另一个 div 自适应在右侧</span></h3><ol>\n<li><p>如果不考虑浏览器的兼容问题的话，可以使用 css3 的新增属性 calc();calc 是 calculate 的简写，汉语为计算的意思。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.left</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: pink;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"built_in\">calc</span>(100% - 200px);</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: yellow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以使用百分比进行布局，该方法不需考虑浏览器的兼容性.但与第一种进行比较， 右侧 div 的宽度百分比需要自己去进行计算。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 要依赖父元素</span><br><span class=\"line\"><span class=\"selector-class\">.left</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: pink;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">85%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: yellow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用绝对元素进行定位</p>\n</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.left</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: pink;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: yellow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>div 的宽度在不进行设置的情况下会自动填满父标签的宽度。所以我们可以并不对右侧 div 的宽度进行设置</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.left</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: pink;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: yellow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>flex 布局</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 要依赖父元素</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">1000px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">400px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid red;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex; <span class=\"comment\">/*flex布局*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.left</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: gray;</span><br><span class=\"line\">  <span class=\"attribute\">flex</span>: none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: green;</span><br><span class=\"line\">  <span class=\"attribute\">flex</span>: <span class=\"number\">1</span>; <span class=\"comment\">/*flex布局*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>table 布局<br>// 要依赖父元素</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">1000px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">400px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid red;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table; <span class=\"comment\">/*table布局*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.left</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: gray;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table-cell;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: green;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table-cell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>BFC(块级格式化上下文)<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">1000px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">400px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.left</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: gray;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.rigth</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden; <span class=\"comment\">/* 触发bfc */</span></span><br><span class=\"line\">  <span class=\"attribute\">background</span>: green;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"3-给-Object-扩展一个方法-clone，实现深度克隆对象\"><a href=\"#3-给-Object-扩展一个方法-clone，实现深度克隆对象\" class=\"headerlink\" title=\"3. 给 Object 扩展一个方法 clone，实现深度克隆对象\"></a><span id=\"2\">3. 给 Object 扩展一个方法 clone，实现深度克隆对象</span></h3><p><a href=\"javaScript中浅拷贝和深拷贝的实现\">javaScript 中浅拷贝和深拷贝的实现</a></p>\n<h3 id=\"4-px、em、rem\"><a href=\"#4-px、em、rem\" class=\"headerlink\" title=\"4. px、em、rem\"></a><span id=\"3\">4. px、em、rem</span></h3><blockquote>\n<p>有何区别</p>\n</blockquote>\n<ul>\n<li>px 在缩放页面时无法调整那些使用它作为单位的字体、按钮等的大小；</li>\n<li>em 的值并不是固定的，会继承父级元素的字体大小，代表倍数；</li>\n<li>rem 的值并不是固定的，始终是基于根元素 html 的，也代表倍数。</li>\n</ul>\n<blockquote>\n<p>em</p>\n</blockquote>\n<p>em 的使用是相对于其父级的字体大小的，即倍数。浏览器的默认字体高都是 16px，未经调整的浏览器显示 1em = 16px。但是有一个问题，如果设置 1.2em 则变成 19.2px，问题是 px 表示大小时数值会忽略掉小数位的（你想像不出来半个像素吧）。而且 1em = 16px 的关系不好转换，因此，常常人为地使 1em = 10px。这里要借助字体的 % 来作为桥梁。</p>\n<p>因为默认时字体 16px = 100%，则有 10px = 62.5%。所以首先在 body 中全局声明 font-size=62.5%=10px，也就是定义了网页 body 默认字体大小为 10px，由于 em 有继承父级元素字体大小的特性，如果某元素的父级没有设定字体大小，那么它就继续了 body 默认字体大小 1em = 10px。</p>\n<p>但是由于 em 是相对于其父级字体的倍数的，当出现有多重嵌套内容时，使用 em 分别给它们设置字体的大小往往要重新计算。比如说你在父级中声明了字体大小为 1.2em，那么在声明子元素的字体大小时设置 1em 才能和父级元素内容字体大小一致，而不是 1.2em（避免 1.2*1.2=1.44em）, 因为此 em 非彼 em。再举个例子：</p>\n<p><code>&lt;span&gt;Outer &lt;span&gt;inner&lt;/span&gt; outer&lt;/span&gt;</code></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">62.5%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">span</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.6em</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>rem</p>\n</blockquote>\n<p>rem 的出现再也不用担心还要根据父级元素的 font-size 计算 em 值了，因为它始终是基于根元素（<html>）的。比如默认的 html font-size=16px，那么想设置 12px 的文字就是：12÷16=0.75(rem)<br>仍然是上面的例子，CSS 改为：</html></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">62.5%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">span</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">16px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.6rem</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果：内外 <span> 的内容均为 16px。</span></p>\n<blockquote>\n<p>需要注意的是，为了兼容不支持 rem 的浏览器，我们需要在各个使用了 rem 地方前面写上对应的 px 值，这样不支持的浏览器可以优雅降级。</p>\n</blockquote>\n<h3 id=\"5-用-html-css-实现一个-div-居中在窗口\"><a href=\"#5-用-html-css-实现一个-div-居中在窗口\" class=\"headerlink\" title=\"5. 用 html,css 实现一个 div 居中在窗口\"></a><span id=\"4\">5. 用 html,css 实现一个 div 居中在窗口</span></h3><ol>\n<li><p>Flex 布局, 不考虑兼容老式浏览器的话，用Flex布局简单直观一劳永逸</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.out</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: pink;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: -webkit-flex; <span class=\"comment\">/* Safari */</span></span><br><span class=\"line\">    <span class=\"comment\">/*align-items:center;    /* 处理垂直居中 */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.in</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: blue;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: auto;           <span class=\"comment\">/* 水平垂直居中 */</span></span><br><span class=\"line\">    <span class=\"attribute\">word-wrap</span>: break-word;  <span class=\"comment\">/*如果是字母数字， 处理换行 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>不知道自己高度的情况下, 利用绝对定位，结合transform: translate（）属性。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.out</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">width</span>: <span class=\"number\">200px</span>; </span><br><span class=\"line\"><span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\"><span class=\"attribute\">background</span>: pink;</span><br><span class=\"line\"><span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.in</span> &#123;</span><br><span class=\"line\"><span class=\"attribute\">background</span>: blue;</span><br><span class=\"line\"><span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\"><span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\"><span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\"><span class=\"attribute\">transform</span>: <span class=\"built_in\">translate</span>(-50%, -50%);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>已知容器高度的情况下，利用定位</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.out</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>; </span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: pink;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.in</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: blue;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"comment\">/*第一种*/</span></span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-top</span>:-<span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>:-<span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"comment\">/*第二种*/</span></span><br><span class=\"line\">    <span class=\"attribute\">top</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">right</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>:auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>已知容器高度， 利用display: table-cell;</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.out</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: pink;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>:table-cell;</span><br><span class=\"line\">    <span class=\"attribute\">vertical-align</span>:middle;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.in</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: blue;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"6-用css实现，两行文本，间距10px-字体是14px-距顶端和底端15px-拒左边10px\"><a href=\"#6-用css实现，两行文本，间距10px-字体是14px-距顶端和底端15px-拒左边10px\" class=\"headerlink\" title=\"6. 用css实现，两行文本，间距10px,字体是14px,距顶端和底端15px,拒左边10px\"></a><span id=\"5\">6. 用css实现，两行文本，间距10px,字体是14px,距顶端和底端15px,拒左边10px</span></h3><blockquote>\n<p>word-spacing 对中文没有作用， 对字母有作用，从空格隔那开始起作用，而letter-spacing对两者都有作用，是字间的距离，包括空格哪里的也会隔开</p>\n</blockquote>\n<pre><code><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.out</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">14px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">letter-spacing</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">15px</span> <span class=\"number\">0</span> <span class=\"number\">15px</span> <span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"7-扩展Date的format方法\"><a href=\"#7-扩展Date的format方法\" class=\"headerlink\" title=\"7. 扩展Date的format方法\"></a><span id=\"6\">7. 扩展Date的format方法</span></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Date</span>.prototype.format = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">format</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">        <span class=\"string\">\"M+\"</span>: <span class=\"keyword\">this</span>.getMonth() + <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"string\">\"d+\"</span>: <span class=\"keyword\">this</span>.getDate(),</span><br><span class=\"line\">        <span class=\"string\">\"h+\"</span>: <span class=\"keyword\">this</span>.getHours(),</span><br><span class=\"line\">        <span class=\"string\">\"m+\"</span>: <span class=\"keyword\">this</span>.getMinutes(),</span><br><span class=\"line\">        <span class=\"string\">\"s+\"</span>: <span class=\"keyword\">this</span>.getSeconds(),</span><br><span class=\"line\">        <span class=\"string\">\"q+\"</span>: <span class=\"built_in\">Math</span>.floor((<span class=\"keyword\">this</span>.getMonth() + <span class=\"number\">3</span>) / <span class=\"number\">3</span>),</span><br><span class=\"line\">        <span class=\"string\">\"S\"</span>: <span class=\"keyword\">this</span>.getMilliseconds()</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"regexp\">/(y+)/</span>.test(format)) &#123;</span><br><span class=\"line\">        format = format.replace(<span class=\"built_in\">RegExp</span>.$<span class=\"number\">1</span>, (<span class=\"keyword\">this</span>.getFullYear() + <span class=\"string\">\"\"</span>).substr(<span class=\"number\">4</span> - <span class=\"built_in\">RegExp</span>.$<span class=\"number\">1.</span>length));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k <span class=\"keyword\">in</span> o) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"(\"</span> + k + <span class=\"string\">\")\"</span>).test(format)) &#123;</span><br><span class=\"line\">            format = format.replace(<span class=\"built_in\">RegExp</span>.$<span class=\"number\">1</span>, <span class=\"built_in\">RegExp</span>.$<span class=\"number\">1.</span>length == <span class=\"number\">1</span> ? o[k] : (<span class=\"string\">\"00\"</span> + o[k]).substr((<span class=\"string\">\"\"</span> + o[k]).length));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> format;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-写出下面结果\"><a href=\"#8-写出下面结果\" class=\"headerlink\" title=\"8. 写出下面结果\"></a><span id=\"7\">8. 写出下面结果</span></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\">c</span>)</span>&#123;</span><br><span class=\"line\">　　　　<span class=\"built_in\">console</span>.log(c);</span><br><span class=\"line\">　　　　<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">c</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">　　　　　　　<span class=\"built_in\">console</span>.log(<span class=\"string\">\"d\"</span>);</span><br><span class=\"line\">　　　　&#125;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　b(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结果 function c()&#123; console.log(\"d\"); &#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"9-alert-1-amp-amp-2-alert-1-0\"><a href=\"#9-alert-1-amp-amp-2-alert-1-0\" class=\"headerlink\" title=\"9. alert(1&amp;&amp;2),alert(1||0) \"></a><span id=\"8\">9. alert(1&amp;&amp;2),alert(1||0) </span></h3><pre><code>alert(1&amp;&amp;2)的结果是2\n只要“&amp;&amp;”前面是false，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”前面的值;\n只要“&amp;&amp;”前面是true，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”后面的值;\nalert(0||1)的结果是1\n只要“||”前面为false,不管“||”后面是true还是false，都返回“||”后面的值。\n只要“||”前面为true,不管“||”后面是true还是false，都返回“||”前面的值。\n</code></pre><h3 id=\"10-mouseenter和mouseover的区别\"><a href=\"#10-mouseenter和mouseover的区别\" class=\"headerlink\" title=\"10. mouseenter和mouseover的区别\"></a><span id=\"9\">10. mouseenter和mouseover的区别</span></h3><pre><code>mouseover事件：不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。\nmouseenter事件：只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。\nmouseout事件：不论鼠标指针离开被选元素还是任何子元素，都会触发 mouseout 事件。\nmouseleave事件：只有在鼠标指针离开被选元素时，才会触发 mouseleave 事件。\n</code></pre><h3 id=\"11-js字符串两边截取空白的trim的原型方法的实现\"><a href=\"#11-js字符串两边截取空白的trim的原型方法的实现\" class=\"headerlink\" title=\" 11. js字符串两边截取空白的trim的原型方法的实现\"></a><span id=\"10\"> 11. js字符串两边截取空白的trim的原型方法的实现</span></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//我的笨方法，当时还想错了一些，回来后实现了一下，思路是这样</span></span><br><span class=\"line\"><span class=\"built_in\">String</span>.prototype.trim = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr=<span class=\"keyword\">this</span>.split(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(arr[<span class=\"number\">0</span>]==<span class=\"string\">\" \"</span>) &#123;</span><br><span class=\"line\">           arr.shift();</span><br><span class=\"line\">           <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(arr[arr.length<span class=\"number\">-1</span>]==<span class=\"string\">\" \"</span>) &#123;</span><br><span class=\"line\">            arr.pop();</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr.join(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//后来面试官跟我说一句话就解决了，然而我正则都忘了，平时没怎么用</span></span><br><span class=\"line\"><span class=\"built_in\">String</span>.prototype.trim = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.replace(<span class=\"regexp\">/(^\\s*)|(\\s*$)/g</span>,<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"12-三道判断输出的题都是经典的题\"><a href=\"#12-三道判断输出的题都是经典的题\" class=\"headerlink\" title=\" 12. 三道判断输出的题都是经典的题\"></a><span id=\"11\"> 12. 三道判断输出的题都是经典的题</span></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//5.1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  a=<span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">b();</span><br><span class=\"line\"><span class=\"comment\">//明显输出是3，因为里面修改了a这个全局变量，那个function a()&#123;&#125;是用来干扰的，虽然函数声明会提升，就被a给覆盖掉了，这是我的理解</span></span><br><span class=\"line\"><span class=\"comment\">//5.2</span></span><br><span class=\"line\"><span class=\"comment\">//不记得具体的就类似如下</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> baz=<span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bazz=&#123;</span><br><span class=\"line\">  baz: <span class=\"number\">2</span>,</span><br><span class=\"line\">  getbaz: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.baz</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bazz.getbaz())</span><br><span class=\"line\"><span class=\"keyword\">var</span> g=bazz.getbaz;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g());</span><br><span class=\"line\"><span class=\"comment\">//第一个输出是2，第二个输出是3，这题考察的就是this的指向，函数作为对象本身属性调用的时候this指向对象，作为普通函数调用的时候就指向全局了</span></span><br><span class=\"line\"><span class=\"comment\">//5.3</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;arr.length;i++)</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">  arr[i]=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;alert(i)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr[<span class=\"number\">3</span>]();</span><br><span class=\"line\"><span class=\"comment\">//典型的闭包啊，看都不用看，肯定弹出5啊</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"13-position不同值和区别\"><a href=\"#13-position不同值和区别\" class=\"headerlink\" title=\"13. position不同值和区别\"></a><span id=\"12\">13. position不同值和区别</span></h3><pre><code>1.absolute: 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。\n元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。(不占位)\n2.relative: 生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。（占位）\n3.static：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）\n4.inherit：规定应该从父元素继承 position 属性的值。\n5.fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。\n</code></pre><h3 id=\"14-讲述你对reflow和repaint的理解\"><a href=\"#14-讲述你对reflow和repaint的理解\" class=\"headerlink\" title=\"14. 讲述你对reflow和repaint的理解\"></a><span id=\"13\">14. 讲述你对reflow和repaint的理解</span></h3><blockquote>\n<p>repaint就是重绘，reflow就是回流。repaint主要是针对某一个DOM元素进行的重绘，reflow则是回流，针对整个页面的重排</p>\n</blockquote>\n<h3 id=\"严重性：\"><a href=\"#严重性：\" class=\"headerlink\" title=\"严重性：\"></a>严重性：</h3><p>在性能优先的前提下，性能消耗 reflow大于repaint。</p>\n<h3 id=\"体现：\"><a href=\"#体现：\" class=\"headerlink\" title=\"体现：\"></a>体现：</h3><p>repaint是某个DOM元素进行重绘；reflow是整个页面进行重排，也就是页面所有DOM元素渲染。</p>\n<h4 id=\"如何触发：\"><a href=\"#如何触发：\" class=\"headerlink\" title=\"如何触发：\"></a>如何触发：</h4><p>style变动造成repaint和reflow。<br>不涉及任何DOM元素的排版问题的变动为repaint，例如元素的color/text-align/text-decoration等等属性的变动。<br>除上面所提到的DOM元素style的修改基本为reflow。例如元素的任何涉及长、宽、行高、边框、display等style的修改。</p>\n<h3 id=\"常见触发场景：\"><a href=\"#常见触发场景：\" class=\"headerlink\" title=\"常见触发场景：\"></a>常见触发场景：</h3><h4 id=\"触发repaint：\"><a href=\"#触发repaint：\" class=\"headerlink\" title=\"触发repaint：\"></a>触发repaint：</h4><pre><code>color的修改，如color=#ddd；\ntext-align的修改，如text-align=center；\na:hover也会造成重绘。\n:hover引起的颜色等不导致页面回流的style变动。\n</code></pre><h4 id=\"触发reflow：\"><a href=\"#触发reflow：\" class=\"headerlink\" title=\"触发reflow：\"></a>触发reflow：</h4><pre><code>width/height/border/margin/padding的修改，如width=778px；\n动画，:hover等伪类引起的元素表现改动，display=none等造成页面回流；\nappendChild等DOM元素操作；\nfont类style的修改；\nbackground的修改，注意着字面上可能以为是重绘，但是浏览器确实回流了，经过浏览器厂家的优化，部分background的修改只触发repaint，当然IE不用考虑；\nscroll页面，这个不可避免；\nresize页面，桌面版本的进行浏览器大小的缩放，移动端的话，还没玩过能拖动程序，resize程序窗口大小的多窗口操作系统。\n读取元素的属性（这个无法理解，但是技术达人是这么说的，那就把它当做定理吧）：读取元素的某些属性（offsetLeft、offsetTop、offsetHeight、offsetWidth、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、getComputedStyle()、currentStyle(in IE))；\n</code></pre><h4 id=\"如何避免：\"><a href=\"#如何避免：\" class=\"headerlink\" title=\"如何避免：\"></a>如何避免：</h4><p>尽可能在DOM末梢通过改变class来修改元素的style属性：尽可能的减少受影响的DOM元素。<br>避免设置多项内联样式：使用常用的class的方式进行设置样式，以避免设置样式时访问DOM的低效率。<br>设置动画元素position属性为fixed或者absolute：由于当前元素从DOM流中独立出来，因此受影响的只有当前元素，元素repaint。<br>牺牲平滑度满足性能：动画精度太强，会造成更多次的repaint/reflow，牺牲精度，能满足性能的损耗，获取性能和平滑度的平衡。<br>避免使用table进行布局：table的每个元素的大小以及内容的改动，都会导致整个table进行重新计算，造成大幅度的repaint或者reflow。改用div则可以进行针对性的repaint和避免不必要的reflow。<br>避免在CSS中使用运算式：学习CSS的时候就知道，这个应该避免，不应该加深到这一层再去了解，因为这个的后果确实非常严重，一旦存在动画性的repaint/reflow，那么每一帧动画都会进行计算，性能消耗不容小觑。</p>\n<p><a href=\"https://segmentfault.com/a/1190000002629708\" target=\"_blank\" rel=\"noopener\"></a></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjslmo3cb0001uox17mhyupxe","category_id":"cjslmo3ct0004uox16l2tzw6e","_id":"cjslmo3d40008uox18pxkd836"},{"post_id":"cjslmo3d30006uox1uxz9nqmn","category_id":"cjslmo3ct0004uox16l2tzw6e","_id":"cjslmo3du0012uox1pqikn20d"},{"post_id":"cjslmo3d40009uox17g2xpreh","category_id":"cjslmo3ct0004uox16l2tzw6e","_id":"cjslmo3dv0013uox1zrifzr9n"},{"post_id":"cjslmo3d5000auox11zwzlt0b","category_id":"cjslmo3ct0004uox16l2tzw6e","_id":"cjslmo3dv0014uox1mwkout6z"},{"post_id":"cjslmo3d6000buox1xtauuhan","category_id":"cjslmo3ct0004uox16l2tzw6e","_id":"cjslmo3dx0017uox1wd9q3fh3"},{"post_id":"cjslmo3d7000cuox15u3i1hhi","category_id":"cjslmo3ct0004uox16l2tzw6e","_id":"cjslmo3dx0018uox1fdlm9vib"},{"post_id":"cjslmo3d9000duox19a3swhyh","category_id":"cjslmo3ct0004uox16l2tzw6e","_id":"cjslmo3dy001buox1xjeip6ye"},{"post_id":"cjslmo3d9000euox1rwagd37v","category_id":"cjslmo3ct0004uox16l2tzw6e","_id":"cjslmo3dy001cuox1bl975y53"},{"post_id":"cjslmo3dc000huox1jeobix48","category_id":"cjslmo3ct0004uox16l2tzw6e","_id":"cjslmo3dy001fuox1s34ltg7n"},{"post_id":"cjslmo3dd000iuox1lleer6vy","category_id":"cjslmo3ct0004uox16l2tzw6e","_id":"cjslmo3dz001guox1qwflxh64"},{"post_id":"cjslmo3de000juox1wmj3ff2k","category_id":"cjslmo3ct0004uox16l2tzw6e","_id":"cjslmo3dz001juox1h8suuvr3"},{"post_id":"cjslmo3de000kuox1ozxlqv7z","category_id":"cjslmo3ct0004uox16l2tzw6e","_id":"cjslmo3dz001kuox1odazxx69"},{"post_id":"cjslmo3df000muox1noaoqch6","category_id":"cjslmo3ct0004uox16l2tzw6e","_id":"cjslmo3e0001nuox1fbghby0x"},{"post_id":"cjslmo3dl000vuox17f9wx83q","category_id":"cjslmo3ct0004uox16l2tzw6e","_id":"cjslmo3e0001ouox1nnfq2znn"},{"post_id":"cjslmo3dm000xuox1bkndxaps","category_id":"cjslmo3ct0004uox16l2tzw6e","_id":"cjslmo3e0001ruox1cwy5ih3l"},{"post_id":"cjslmo3dn000yuox1t759h1vn","category_id":"cjslmo3ct0004uox16l2tzw6e","_id":"cjslmo3e0001suox1e5vvubgf"},{"post_id":"cjslmo3dn000zuox1bnirgy3b","category_id":"cjslmo3ct0004uox16l2tzw6e","_id":"cjslmo3e1001vuox11wbhj8va"},{"post_id":"cjslmo3db000fuox11oszdev9","category_id":"cjslmo3du0011uox1vvyvtpqr","_id":"cjslmo3ea002luox19u1zx3yx"},{"post_id":"cjslmo3dc000guox1ow532hwf","category_id":"cjslmo3du0011uox1vvyvtpqr","_id":"cjslmo3ea002nuox1nybqjbz8"},{"post_id":"cjslmo3df000luox1zcpv5ys5","category_id":"cjslmo3dx0019uox1reqk2sge","_id":"cjslmo3ea002puox1iy2lccci"},{"post_id":"cjslmo3dg000nuox1htuori8l","category_id":"cjslmo3dy001euox1zs78rz7n","_id":"cjslmo3eb002ruox130dt29d2"},{"post_id":"cjslmo3dh000ouox14to7choo","category_id":"cjslmo3dz001iuox1kufbe4zl","_id":"cjslmo3eb002tuox1g9zg6ake"},{"post_id":"cjslmo3dh000puox1bhzwm456","category_id":"cjslmo3dz001iuox1kufbe4zl","_id":"cjslmo3eb002vuox1iabjssre"},{"post_id":"cjslmo3di000quox1uq9igqq6","category_id":"cjslmo3dz001iuox1kufbe4zl","_id":"cjslmo3eb002xuox1pq7y49m0"},{"post_id":"cjslmo3di000ruox12d8e7cm2","category_id":"cjslmo3dz001iuox1kufbe4zl","_id":"cjslmo3eb002zuox1juwpvcwu"},{"post_id":"cjslmo3dj000suox117gum2d7","category_id":"cjslmo3dz001iuox1kufbe4zl","_id":"cjslmo3eb0031uox1640qsydu"},{"post_id":"cjslmo3dk000tuox1gpks3esd","category_id":"cjslmo3dz001iuox1kufbe4zl","_id":"cjslmo3eb0033uox1tu4k8ygd"},{"post_id":"cjslmo3dk000uuox1egg5epjx","category_id":"cjslmo3dz001iuox1kufbe4zl","_id":"cjslmo3eb0035uox1kzu0536q"},{"post_id":"cjslmo3dm000wuox1mc247610","category_id":"cjslmo3dz001iuox1kufbe4zl","_id":"cjslmo3eb0037uox1cnhr1751"}],"PostTag":[{"post_id":"cjslmo3cb0001uox17mhyupxe","tag_id":"cjslmo3cv0005uox1vxkrujfw","_id":"cjslmo3d40007uox19n1di260"},{"post_id":"cjslmo3d30006uox1uxz9nqmn","tag_id":"cjslmo3du0010uox1129jcun1","_id":"cjslmo3ea002kuox16n421dn8"},{"post_id":"cjslmo3d40009uox17g2xpreh","tag_id":"cjslmo3dw0015uox1pkglmkv7","_id":"cjslmo3ea002muox1cy2vj8g3"},{"post_id":"cjslmo3d5000auox11zwzlt0b","tag_id":"cjslmo3dw0015uox1pkglmkv7","_id":"cjslmo3ea002ouox11laf7y87"},{"post_id":"cjslmo3d6000buox1xtauuhan","tag_id":"cjslmo3dw0015uox1pkglmkv7","_id":"cjslmo3eb002quox18en3j7zy"},{"post_id":"cjslmo3d7000cuox15u3i1hhi","tag_id":"cjslmo3dw0015uox1pkglmkv7","_id":"cjslmo3eb002suox1632l6odg"},{"post_id":"cjslmo3d9000duox19a3swhyh","tag_id":"cjslmo3dw0015uox1pkglmkv7","_id":"cjslmo3eb002uuox1km3hpynj"},{"post_id":"cjslmo3d9000euox1rwagd37v","tag_id":"cjslmo3e0001puox1gp6sgt0c","_id":"cjslmo3eb002wuox1friehmts"},{"post_id":"cjslmo3db000fuox11oszdev9","tag_id":"cjslmo3e1001tuox1qdilregq","_id":"cjslmo3eb002yuox1kynkl05o"},{"post_id":"cjslmo3dc000guox1ow532hwf","tag_id":"cjslmo3e1001tuox1qdilregq","_id":"cjslmo3eb0030uox1fj440fbe"},{"post_id":"cjslmo3dc000huox1jeobix48","tag_id":"cjslmo3dw0015uox1pkglmkv7","_id":"cjslmo3eb0032uox14xcnfb11"},{"post_id":"cjslmo3dd000iuox1lleer6vy","tag_id":"cjslmo3e20020uox12kf790mu","_id":"cjslmo3eb0034uox1t0vv5xvu"},{"post_id":"cjslmo3de000juox1wmj3ff2k","tag_id":"cjslmo3e30023uox10cje5pv7","_id":"cjslmo3eb0036uox1nms10upb"},{"post_id":"cjslmo3de000kuox1ozxlqv7z","tag_id":"cjslmo3e30024uox168xgqpdz","_id":"cjslmo3ec0038uox1cabf8gmd"},{"post_id":"cjslmo3df000luox1zcpv5ys5","tag_id":"cjslmo3e40025uox1cy5q8xn1","_id":"cjslmo3ec0039uox1nmqn7hnn"},{"post_id":"cjslmo3df000muox1noaoqch6","tag_id":"cjslmo3e40026uox146z8qc3x","_id":"cjslmo3ec003auox1v8fov00g"},{"post_id":"cjslmo3dg000nuox1htuori8l","tag_id":"cjslmo3e40027uox1ztfom85l","_id":"cjslmo3ec003buox1drfm7mrx"},{"post_id":"cjslmo3dh000ouox14to7choo","tag_id":"cjslmo3e40028uox1t2svx2ay","_id":"cjslmo3ec003cuox1gmux6c0p"},{"post_id":"cjslmo3dh000puox1bhzwm456","tag_id":"cjslmo3e40028uox1t2svx2ay","_id":"cjslmo3ec003duox10jzlj25c"},{"post_id":"cjslmo3di000quox1uq9igqq6","tag_id":"cjslmo3e40028uox1t2svx2ay","_id":"cjslmo3ec003euox1x05qnaof"},{"post_id":"cjslmo3di000ruox12d8e7cm2","tag_id":"cjslmo3e40028uox1t2svx2ay","_id":"cjslmo3ec003fuox17cu7h5kw"},{"post_id":"cjslmo3dj000suox117gum2d7","tag_id":"cjslmo3e40028uox1t2svx2ay","_id":"cjslmo3ec003guox1bhlq5hxg"},{"post_id":"cjslmo3dk000tuox1gpks3esd","tag_id":"cjslmo3e40028uox1t2svx2ay","_id":"cjslmo3ec003huox17kks7ygm"},{"post_id":"cjslmo3dk000uuox1egg5epjx","tag_id":"cjslmo3e40028uox1t2svx2ay","_id":"cjslmo3ec003iuox1vpz4uuq9"},{"post_id":"cjslmo3dl000vuox17f9wx83q","tag_id":"cjslmo3e6002fuox1y6usc0te","_id":"cjslmo3ec003juox1qw0epva1"},{"post_id":"cjslmo3dm000wuox1mc247610","tag_id":"cjslmo3e40028uox1t2svx2ay","_id":"cjslmo3ec003kuox1tvva8au4"},{"post_id":"cjslmo3dm000xuox1bkndxaps","tag_id":"cjslmo3e6002huox126v394xh","_id":"cjslmo3ec003luox11hmvw33l"},{"post_id":"cjslmo3dn000yuox1t759h1vn","tag_id":"cjslmo3e6002huox126v394xh","_id":"cjslmo3ec003muox1076aojqr"},{"post_id":"cjslmo3dn000zuox1bnirgy3b","tag_id":"cjslmo3e6002huox126v394xh","_id":"cjslmo3ec003nuox1m1tp40al"}],"Tag":[{"name":"语法","_id":"cjslmo3cv0005uox1vxkrujfw"},{"name":"css3","_id":"cjslmo3du0010uox1129jcun1"},{"name":"js","_id":"cjslmo3dw0015uox1pkglmkv7"},{"name":"Git","_id":"cjslmo3e0001puox1gp6sgt0c"},{"name":"领悟","_id":"cjslmo3e1001tuox1qdilregq"},{"name":"VPN","_id":"cjslmo3e20020uox12kf790mu"},{"name":"vsCode插件","_id":"cjslmo3e30023uox10cje5pv7"},{"name":"服务器区别","_id":"cjslmo3e30024uox168xgqpdz"},{"name":"书籍收藏","_id":"cjslmo3e40025uox1cy5q8xn1"},{"name":"浏览器","_id":"cjslmo3e40026uox146z8qc3x"},{"name":"健康","_id":"cjslmo3e40027uox1ztfom85l"},{"name":"英语","_id":"cjslmo3e40028uox1t2svx2ay"},{"name":"前端框架","_id":"cjslmo3e6002fuox1y6usc0te"},{"name":"前端面试","_id":"cjslmo3e6002huox126v394xh"}]}}